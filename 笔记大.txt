一111111111111111111111
﻿牛犇

 第一阶段课程内容共19天
 云计算系统管理、 云计算应用管理、系统&服务管理进阶

 云计算系统管理	
	DAY01	开学典礼、云网络基础			
   	DAY02	Linux系统简介、安装Linux系统、Linux基本操作		
	DAY03	命令行基础、目录和文件管理			
	DAY04	管理用户和组、tar备份与恢复、cron计划任务		
	DAY05	教学环境介绍、权限和归属			
	DAY06	软件包管理、分区规划及使用、NTP时间同步	
	DAY07	LVM逻辑卷、综合串讲、综合练习		

		
 云计算应用管理	
	DAY01	Shell脚本基础、使用变量、条件测试及选择、列表式循环
	DAY02	系统安全保护、配置用户环境、防火墙策略管理			
	DAY03	ISCSI共享存储、数据库服务基础、管理表数据	
	DAY04	配置NFS共享、HTTP服务基础		
	DAY05	网页内容访问、部署动态网站	、安全Web服务	
	DAY06	综合串讲、综合练习		


 系统&服务管理进阶	
	DAY01	扩展的几个应用、发布网络YUM源、vim编辑技巧、源码编译安装	
	DAY02	KVM构建及管理、virsh控制工具、镜像管理、虚拟机快建技术
	DAY03	DNS服务基础、特殊解析、DNS子域授权、缓存DNS
	DAY04	Split分离解析、RAID磁盘阵列、进程管理、日志管理、systemctl控制
	DAY05	批量装机环境、配置PXE引导、kickstart自动应答	
	DAY06	rsync同步操作、inotify实时同步、Cobbler网络装机		
			
##################################################################################################

  准备笔记本与笔（默写），U盘（后期存储备份教学数据）
  先讲解后练习，勤奋的练习



##################################################################
一 教学环境
1.真机是Linux   账户:student  密码:tedu
      
2.虚拟化软件: 虚拟众多的硬件
      虚拟机被损坏,与真机无关


########################################
典型服务模式
• C/S,Client/Server架构
– 由服务器提供资源或某种功能
– 客户机使用资源或功能


##############################################
TCP/IP协议简介
• TCP/IP是最广泛支持的通信协议集合
 – 包括大量Internet应用中的标准协议
 – 支持跨网络架构、跨操作系统平台的通信

• 主机与主机之间通信的三个要素　　　　　
 – IP地址(IP address)
  – 子网掩码(subnet mask)
 – IP路由(IP router):涉及路由器

#################################################
IP地址(IP address):唯一标识网络中一个节点地址
• 地址组成(点分十进制):
– 一共32个二进制数
　11110000.00001111.10101010.11111100

　　 11111111 = 255

  例子： 　1.2.3.4   192.168.1.1    10.11.12.13

#################################################

为虚拟机win2008配置IP地址
利用管理员进行登录，密码为：tedu


配置IP地址：　　192.168.1.1　　子网掩码：255.255.255.0
– 右击桌面网络 --＞属性 --＞更改适配器设置
– 双击“本地连接” --＞ 属性
– 双击“Internet协议版本4(TCP/IPv4)”　　　
– 配置完成后,单击“确定”完成

查看IP地址：　
– 右击桌面网络 --＞属性 --＞更改适配器设置
– 双击“本地连接” --＞ 详细信息

采用ipconfig命令的方式，查看IP地址：
   　windows键　＋　ｒ＝　开始＋运行
　　　输入cmd-->敲回车--＞输入　ipconfig-->敲回车
　　　--＞输入　exit　关闭命令行界面

################################################
• IP地址的分类
– A类:1 ~ 127       　网+主+主+主
– B类:128 ~ 191  　 网+网+主+主
– C类:192 ~ 223   　网+网+网+主

• 组播及科研专用
– D类:224 ~ 239 组播
– E类:240 ~ 254 科研


   192.168.1.1=只看ip地址的第一个数字,进行判别分类


################################################
IP地址由网络位与主机位，两部来组成
 网络位=座机号码的区号，标识一个网络
 主机位=编号

子网掩码：用来区分IP地址的网络位与主机位
　　　　　利用二进制的１标识网络位
　　　　　利用二进制的0标识主机位
　192.168.1.1＝11000000.10101000.00000001.00000001
                        11111111.11111111.11111111.00000000
                         255.255.255.0

　座机号码：区号－号码（编号）
　　北京：010－12345678＝北京区域，编号为12345678的座机
　　石家庄：0311－7354444＝石家庄区域,编号为7354444的座机

　区号：标识区域

　192.168.1.1　＝　192.168.1网络，编号为１的主机
　192.168.１.2　＝　192.168.１网络，编号为２的主机
　相同网络通信，网络位相同

　192.168.1.1  255.255.255.0 = 192.168.1.1/24

   192.168.1.1/24 :该IP地址有24个网络位

　1.该IP地址是哪一类 　 2.判别网络位与主机位
################################################
克隆虚拟机win2008　　　　　　　　　　
1.关闭虚拟机win2008
2.进行虚拟机克隆
　双击＂虚拟系统管理器＂--＞右击＂win2008＂--＞克隆--＞克隆

3.修改win2008-clone桌面背景
  双击＂控制面板＂--＞显示--＞更改桌面背景---＞保存修改

4.配置win2008-clone的IP地址：192.168.1.2  255.255.255.0
　
 – 右击桌面网络 --＞属性 --＞更改适配器设置
 – 双击“本地连接” --＞ 属性
 – 双击“Internet协议版本4(TCP/IPv4)”　　　
 – 配置完成后,单击“确定”完成

采用ipconfig命令的方式，查看IP地址：
   　windows键　＋　ｒ＝　开始＋运行
　　　输入cmd-->敲回车--＞输入　ipconfig-->敲回车
　　　--＞输入　exit　关闭命令行界面

################################################
采用命令方式，测试网络联通性：
　　ping　　命令
　　ping  　对方IP地址　　　ping命令是双向，有去有回
　　ping 　192.168.1.1　

　　ping 　192.168.1.２　

###############################################
　ftp://172.40.50.114

###############################################
网关地址:一个网络到另一个网络的关口　（解决不同网络通信）

DNS服务器：将网站的域名解析为,对应的IP地址
  
         www.qq.com-------＞腾讯的服务器
         www.baidu.com-------＞百度的服务器

###############################################





一222222222222222




#################################################################
Linux系统简介

什么是Linux?
Linux是一种操作系统：可以让计算机硬件正常工作

Unix/Linux发展史
• UNIX诞生，1970-1-1

Linux的诞生                                            
• Linux之父,Linus Torwalds
– 1991年10月,发布0.02版(第一个公开版)内核
– 1994年03月,发布1.0版内核
– 标准读音:　哩呐科斯

版本号:主版本.次版本.修订号

Linux发行版本
• 发行版的名称/版本由发行方决定
– Red Hat Enterprise Linux（RHEL） 5/6/7
– Suse Linux Enterprise 12
– Debian Linux 7.8
– Ubuntu Linux 14.10/15.04
– ......
################################################
• CentOS,社区企业操作系统
– Community Enterprise Operating System
– http://www.centos.org/

• 基于Linux的企业服务器
• 嵌入式系统
• 高性能大型运算

###############################################
安装Linux系统
CentOS,社区企业操作系统,建议2G以上内存

 Ctrl + Alt = 鼠标回到真机

#################################################
预备知识

Linux目录结构：树型结构
• 最顶层为根目录(/)
– Unix/Linux的基本哲学理念:一切皆文件

　　根目录(/)：所有的数据都在此目录下（Linux系统的起点）

      路径：/abc/nsd/1.txt
   /dev：存放设备(硬盘或键盘或鼠标或显示器.....)相关的数据

Linux管理员用户为:root  　　进行登录


Linux磁盘表示

　hd,表示IDE设备
　sd,表示SCSI设备
　vd,表示虚拟设备

　/dev/sda:表示SCSI设备，第一块
　/dev/sdb:表示SCSI设备，第二块
　/dev/sdc:表示SCSI设备，第三块
　/dev/sdd:表示SCSI设备，第四块
#################################################
Linux基本操作

命令行基本操作
获取命令行界面
• 虚拟控制台切换( Ctrl + Alt + Fn 组合键)
– tty1:图形桌面
– tty2~tty6:字符控制台

• 右键 "打开终端"
    编辑--->配置文件首选项--->修改字体大小

• 命令行提示标识的含义
– [当前用户@主机名 工作目录]$

– 若当前用户是root,则最后一个字符为 #
[root@svr7 桌面]#
– 否则,最后一个字符为 $
[teacher@svr7 桌面]$

 Ctrl  shift 　+ =　终端字体变大
 Ctrl  － =　终端字体变小

##################################################
查看及切换目录
• pwd — Print Working Directory
– 用途:查看当前工作目录

• cd — Change Directory
– 用途:切换工作目录
– 格式:cd [目标文件夹位置]

• ls — List
– 格式:ls [选项]... [目录或文件名]...


[root@localhost ~]# pwd        #显示当前所在位置
[root@localhost ~]# cd /abc　　　　＃切换到/abc目录
bash: cd: /abc: 没有那个文件或目录
[root@localhost ~]# cd   /　　　　　＃切换到　/　目录
[root@localhost /]# pwd
[root@localhost /]# ls　　　　　＃显示当前目录内容

[root@localhost /]# cd /boot
[root@localhost /boot]# pwd
[root@localhost /boot]# ls

[root@localhost /]# cd /opt
[root@localhost /opt]# pwd
[root@localhost /opt]# ls
　颜色：
　　蓝色：目录
　　黑色：文件
  
[root@localhost /]# ls
[root@localhost /]# ls /root
[root@localhost /]# ls /home
[root@localhost /]# ls /opt
[root@localhost /]# ls /boot
[root@localhost /]# ls /root

]# ls /root/anaconda-ks.cfg
]# cat /root/anaconda-ks.cfg  #查看文件内容
]# cat /etc/passwd　　　#查看文件内容
]# cat /etc/hosts　　　　#查看文件内容
]# cat /etc/fstab　　　　#查看文件内容
]# cat /etc/redhat-release　#查看当前系统版本
###############################################
以 / 开始的绝对路径
以当前为参照的相对路径

[root@localhost /]# cd /etc/pki/
[root@localhost pki]# pwd
[root@localhost pki]# ls
[root@localhost pki]# cd /etc/pki/CA    #绝对路径
[root@localhost CA]# pwd

[root@localhost CA]# cd /etc/pki/
[root@localhost pki]# pwd
[root@localhost pki]# ls
[root@localhost pki]# cd CA　　　　＃相对路径
[root@localhost CA]# pwd

[root@localhost CA]# cd /
[root@localhost /]# ls root     #相对路径
[root@localhost /]# ls /root    #绝对路径

###############################################
 　　.. :表示上一级目录　　　　　　　　　

[root@localhost /]# cd ..   　　　　#后退
[root@localhost /]# cd /etc/pki/
[root@localhost pki]# pwd
/etc/pki
[root@localhost pki]# cd ..
[root@localhost etc]# pwd
/etc
[root@localhost etc]# cd ..
[root@localhost /]# pwd
/
[root@localhost /]# cd /etc/pki/
[root@localhost pki]# cd ../..　　　＃一次性后退两层
[root@localhost /]# pwd
#################################################
• 真机列出CPU处理器信息
[root@svr7 桌面]# lscpu
.......
CPU(s):                4
.......
型号名称：        Intel(R) Core(TM) i5-4430S CPU @ 2.70GHz
.......

• 真机检查内存大小、空闲情况
[root@svr7 桌面]# cat /proc/meminfo
MemTotal:       16330728 kB
.......

查看主机名和IP信息
• 列出当前系统的主机名称
[root@localhost /]# hostname　　#查看当前主机名
localhost.localdomain
[root@localhost /]# hostname　 A.tedu.cn  #临时设置

[root@localhost /]# hostname　　#查看当前主机名

[root@localhost /]# exit   　　 #关闭当前终端
开启一个新的终端进行验证：
[root@A /]#　hostname

• 列出已激活的网卡连接信息
[root@A ~]# ifconfig　　　　　　　　　　　#查看IP地址信息
[root@A ~]# ifconfig eth0 192.168.1.1　#临时设置IP地址
[root@A ~]# ifconfig eth0

[root@A ~]# ping  192.168.1.1
按Ctrl + c 结束正在运行的命令

lo: 本地回环接口，专用于测试
        inet 127.0.0.1  netmask 255.0.0.0

　　127.0.0.1：永久代表本机

[root@A ~]# ping  127.0.0.1
按Ctrl + c 结束正在运行的命令

##########################################
可以永久设置主机名与IP地址与子网掩码与网关地址与DNS服务器地址

修改主机名：设置系统主机名-->输入新的名字-->确定-->确定
[root@A ~]# nmtui
[root@nsd1903 ~]# hostname
nsd1903.tedu.cn
[root@nsd1903 ~]# 

修改IP地址与子网掩码　
[root@A ~]#　nmtui
　编辑连接 -->eth0-->编辑ipv4-->显示-->将自动修改手动
　-->按空格　勾选　自动连接    　    #每次开机自动生效
　-->按空格　勾选　对所有用户有效  

激活配置
[root@A ~]#　nmtui
　启用连接 -->eth0-->敲回车　禁用-->敲回车　激活
　最终eth0前面有一个＊代表激活状态

###############################################

创建文档
• mkdir — Make Directory
– 格式:mkdir  [/路径/]目录名...
[root@nsd1903 ~]# mkdir nsd01 　　  #当前创建目录
[root@nsd1903 ~]# pwd
/root
[root@nsd1903 ~]# ls
[root@nsd1903 ~]# mkdir /opt/nsd02　＃在指定路径下创建
[root@nsd1903 ~]# ls /opt/
• touch命令
– 用途:新建空文件　格式:touch 文件名...
[root@nsd1903 ~]# touch  1.txt　　　　#当前创建文件
[root@nsd1903 ~]# ls
[root@nsd1903 ~]# touch  /opt/2.txt　＃在指定路径下创建
[root@nsd1903 ~]# ls /opt/


文本内容操作
• less分屏阅读工具
• 格式:less [选项] 文件名...

– 优势:支持前后翻页
• 基本交互操作
– 按 / 键向后查找(n、N切换)

[root@nsd1903 ~]# less /etc/passwd
　　按键盘　上　下　可以进行滚动
　　/a   　　#全文查找ａ　(n、N切换)
　　按ｑ退出

• head、tail 命令
– 格式:　head -n 数字 文件名
　　　　tail -n 数字 文件名

[root@nsd1903 ~]# head -2 /etc/passwd  #显示头两行内容
[root@nsd1903 ~]# head -3 /etc/passwd

[root@nsd1903 ~]# tail -2 /etc/passwd　＃显示尾两行内容
[root@nsd1903 ~]# tail -3 /etc/passwd


• grep工具
– 用途:输出包含指定字符串的行
– 格式:grep 　'查找条件' 　　目标文件

[root@nsd1903 ~]# grep　 root  　/etc/passwd

[root@nsd1903 ~]# grep 　a　 /etc/passwd

#############################################
关机及重启操作
• 关机:poweroff
[root@svr7 ~]# poweroff

• 重启:reboot
[root@svr7 ~]# reboot

#############################################
编辑命令或路径的技巧：　Tab可以进行补全       
[root@nsd1903 ~]# if(tab)(tab)
if         ifdown     ifup
ifcfg      ifenslave  
ifconfig   ifstat     
[root@nsd1903 ~]# ifco(tab)

[root@nsd1903 ~]# cat /et(tab)/red(tab)
CentOS Linux release 7.5.1804 (Core)
 
]# ls /etc/sysconfig/network-scripts/ifcfg-eth0 

]# ls /et(tab)/sysco(tab)/netw(tab)-(tab)/ifc(tab)-e(tab)





一33333333333333












如何编写命令行　　　　　　　　

• Linux命令
– 用来实现某一类功能的指令或程序
　　在Linux中执行大多数命令，都要找到相应的程序，将程序运行

– 命令的执行依赖于解释器(默认的解释器：/bin/bash)

　绿色：可以执行的程序

　内核：可以调配计算机硬件资源

　用户的指令------＞解释器------＞内核------＞调配计算机硬件

################################################
命令行的一般格式
• 基本用法
– 命令字     [选项]...     [参数1]    [参数2]...

– 短选项:-l、-A、-c、-d、.. ..
– 多个短选项-->复合选项:-lh、-lA、-ld、.. ..
– 长选项:--help、.. ..


查看命令的帮助信息
　　格式： 命令　 --help
 
[root@nsd1903 ~]# cat  --help
[root@nsd1903 ~]# cat  -n  /etc/passwd      #添加行号
[root@nsd1903 ~]# cat  -n  /etc/redhat-release 

[root@nsd1903 ~]# head -2 /etc/passwd
[root@nsd1903 ~]# tail -3 /etc/passwd

#################################################
快速编辑技巧
• Tab键自动补全
 – 可补齐命令字、选项、参数、文件路径、软件名、服务名

• 快捷键　　　　　　　　　　　　　　
 – Ctrl + l:清空整个屏幕
 – Ctrl + c:废弃当前编辑的命令行（结束正在运行的命令）
 – Esc + . 或 Alt + .:粘贴上一个命令的参数

 – Ctrl + u:清空至行首
 – Ctrl + k:清空至行尾
 – Ctrl + w:往回删除一个单词(以空格界定)

[root@nsd1903 ~]# ls /etc/redhat-release 
/etc/redhat-release
[root@nsd1903 ~]# cat 　Alt + .
[root@nsd1903 ~]# cat -n 　Alt + .
[root@nsd1903 ~]# head -1　 Alt + .

　青色：快捷方式
#################################################
mount挂载操作:　让目录成为设备的访问点

安装软件，前提具备软件的安装包
１.互联网下载
２.从光盘中获得软件安装包

#############################################
Windows读取光盘的内容
 光盘-----＞光驱设备-----＞CD驱动器图标(访问点)


如何让Linux读取光盘的内容
 光盘-----＞光驱设备-----＞访问点(自己创建目录)　　/dvd
          /dev/hdc
          /dev/sr0
 访问点就是一个目录


1.图形利用鼠标，将光盘放入，虚拟光驱设备
2.命令行查看光驱设备
[root@nsd1903 ~]# ls /dev/sr0
/dev/sr0
[root@nsd1903 ~]# ls /dev/cdrom
/dev/cdrom
[root@nsd1903 ~]# ls -l /dev/cdrom   #显示详细信息
lrwxrwxrwx. 1 root root 3 4月   3 10:58 /dev/cdrom -> sr0
３.创建访问点
[root@nsd1903 ~]# mkdir /dvd
[root@nsd1903 ~]# ls /
[root@nsd1903 ~]# ls /dvd

• 使用mount命令
– 格式:mount 　设备路径　　　 挂载点目录
[root@nsd1903 ~]# mount　 /dev/cdrom 　/dvd/

[root@nsd1903 ~]# ls /dvd
[root@nsd1903 ~]# ls /dvd/Packages/

　　煤矿------＞洞口

• 使用umount命令
– 格式:umount 挂载点目录
[root@nsd1903 ~]#　umount /dvd
[root@nsd1903 ~]# ls /dvd
[root@nsd1903 ~]#　mkdir /abc
[root@nsd1903 ~]#　mount /dev/cdrom  /abc
[root@nsd1903 ~]# ls /abc

注意：
　１.当前路径不要在挂载点目录内
[root@nsd1903 dvd]# umount /dvd/
umount: /dvd：目标忙。
        (有些情况下通过 lsof(8) 或 fuser(1) 可以
         找到有关使用该设备的进程的有用信息)

   2.允许一个设备，具有多个不同的挂载点
   3.一个挂载点，不允许挂载多个设备
  ４.挂载点的选择，自己创建的目录

#################################################
目录和文件管理
• pwd — Print Working Directory
– 用途:查看当前工作目录

• cd — Change Directory
– 用途:切换工作目录
– 格式:cd [目标文件夹位置]
   
　　/root：Linux中管理员的家目录
　　/home:存放所有普通用户家目录

    ~:用户家目录
  ~user表示用户user的家目录
[root@nsd1903 /]# useradd  tom   #创建用户tom
[root@nsd1903 /]# ls /home/

[root@nsd1903 /]# useradd dc    #创建用户dc
[root@nsd1903 /]# ls /home/

[root@nsd1903 /]# cd ~dc    #切换到普通用户dc的家目录
[root@nsd1903 dc]# pwd
[root@nsd1903 dc]# cd ~tom
[root@nsd1903 tom]# pwd


  . 表示当前目录,经常与复制命令连用
  .. 表示父目录
################################################
ls 列出文档及属性
• ls — List
– 格式:ls [选项]... [目录或文件名]

• 常用命令选项
 – -l:以长格式显示,显示详细属性
 – -A:包括名称以 . 开头的隐藏文档
 – -d:显示目录本身(而不是内容)的属性
 – -h:提供易读的容量单位(K、M等)

]# ls -l /etc/redhat-release 

]# ls -l /etc/passwd
]# ls -l /etc/fstab 
]# ls -l /etc/sysconfig/network-scripts/ifcfg-eth0 
]# ls -l /root/　　　　＃显示目录内容的详细属性
]# ls -l /

]# ls -l /etc/passwd
]# ls -l -h /etc/passwd
]# ls -lh /etc/passwd　　　#显示详细属性时，加上大小单位
]# ls -lh /var/log/messages  

]# ls -ld  /root    #显示目录本身的详细属性
]# ls -ld  /
　　　　　　　　　　　　　　　
]# ls -A /root　　　　　＃显示目录的全部内容，包括隐藏数据
]# touch /opt/.nsd01.txt
]# ls /opt/
]# ls -A /opt/

#################################################
使用通配符
• 针对不确定的文档名称,以特殊字符表示
– *:任意多个任意字符
– ?:单个字符
[root@nsd1903 ~]# ls /root/a*    #显示/root下以a开头
/root/anaconda-ks.cfg

[root@nsd1903 ~]# ls /boot/vm*

[root@nsd1903 ~]# ls /dev/tty*　　#显示/dev下以tty开头

[root@nsd1903 ~]# ls /etc/*tab  　#显示/etc下以tab结尾
[root@nsd1903 ~]# ls /etc/*.conf

显示以r开头，以.conf结尾
[root@nsd1903 ~]# ls /etc/r*.conf
[root@nsd1903 ~]# ls /dev/tty*
[root@nsd1903 ~]# ls /dev/tty?
[root@nsd1903 ~]# ls /dev/tty??
[root@nsd1903 ~]# ls /dev/tty???

• 针对不确定的文档名称,以特殊字符表示
– [a-z]:多个字符或连续范围中的一个,若无则忽略
– {a,min,xy}:多组不同的字符串,全匹配

[root@nsd1903 ~]# ls /dev/tty[1-8]

[root@nsd1903 ~]# ls /dev/tty[3-6]

[root@nsd1903 ~]# ls /dev/tty{1,3,5,7,9,21}

[root@nsd1903 ~]# ls /dev/tty{38,S0}

##############################################
别名的定义:简化复杂的命令

• 查看已设置的别名
– alias [别名名称]
• 定义新的别名
– alias 别名名称= '实际执行的命令行'
• 取消已设置的别名
– unalias [别名名称]

[root@nsd1903 ~]# hostname      
nsd1903.tedu.cn
[root@nsd1903 ~]# hn
bash: hn: 未找到命令...
[root@nsd1903 ~]# alias hn='hostname'　　＃定义别名
[root@nsd1903 ~]# hn
nsd1903.tedu.cn
[root@nsd1903 ~]# alias      　　 #显示所有有效别名
[root@nsd1903 ~]# unalias hn　　　＃删除hn别名
[root@nsd1903 ~]# hn
bash: hn: 未找到命令...
[root@nsd1903 ~]# 

###############################################
mkdir 创建目录
• mkdir — Make Directory
– 格式:mkdir [-p] [/路径/]目录名...
   -p:创建父目录
[root@server0 ~]#  mkdir -p /vod/movie/cartoon
[root@server0 ~]#　ls /vod
[root@server0 ~]#　ls /vod/movie

[root@nsd1903 ~]#  mkdir -p /opt/aa/bb/cc/dd
[root@nsd1903 ~]#  ls /opt/
[root@nsd1903 ~]#  ls /opt/aa
[root@nsd1903 ~]#  ls /opt/aa/bb/
[root@nsd1903 ~]#  ls /opt/aa/bb/cc/

rm 删除
• rm — Remove
– 格式:rm [选项]... 文件或目录...
• 常用命令选项
– -r、-f:递归删除(含目录)、强制删除
    -r:递归,目录本身以及目录下所有

[root@nsd1903 ~]# mkdir /opt/nsd01
[root@nsd1903 ~]# mkdir /opt/nsd02
[root@nsd1903 ~]# touch /opt/1.txt
[root@nsd1903 ~]# ls /opt/
1.txt  nsd01  nsd02
[root@nsd1903 ~]# rm -rf /opt/1.txt
[root@nsd1903 ~]# ls /opt/
nsd01  nsd02
[root@nsd1903 ~]# rm -rf /opt/* 
[root@nsd1903 ~]# ls /opt/
################################################
mv 移动/改名
• mv — Move
– 格式:mv   原文件      目标路径
[root@nsd1903 ~]# rm -rf /opt/*
[root@nsd1903 ~]# mkdir /opt/nsd
[root@nsd1903 ~]# touch /opt/1.txt
[root@nsd1903 ~]# ls /opt/
[root@nsd1903 ~]# mv /opt/1.txt  /opt/nsd
[root@nsd1903 ~]# ls /opt/
nsd
[root@nsd1903 ~]# ls /opt/nsd

重命名：路径不变的移动
[root@nsd1903 ~]# ls /opt/
[root@nsd1903 ~]# mv /opt/nsd/  /opt/abc
[root@nsd1903 ~]# ls /opt/

[root@nsd1903 ~]# mv /opt/abc/ /opt/student
[root@nsd1903 ~]# ls /opt/
#################################################
cp 复制
• cp — Copy
– 格式:cp [选项]... 原文件     目标路径

• 常用命令选项
– -r:递归,复制目录时必须有此选项

[root@nsd1903 ~]# rm -rf /opt/*
[root@nsd1903 ~]# cp /etc/passwd /opt/
[root@nsd1903 ~]# ls /opt/

[root@nsd1903 ~]# cp /etc/fstab  /opt/
[root@nsd1903 ~]# ls /opt/

[root@nsd1903 ~]# cp -r /home/ /opt/
[root@nsd1903 ~]# ls /opt/

[root@nsd1903 ~]# cp -r /boot/ /opt/
[root@nsd1903 ~]# ls /opt/

复制时出现同名进行覆盖
在本次命令执行，临时取消别名的操作
[root@nsd1903 ~]# cp -r /boot/ /opt/
cp：是否覆盖"/opt/boot/grub2/device.map"？
 按 Ctrl + c　取消操作
[root@nsd1903 ~]# \cp -r /boot/ /opt/
[root@nsd1903 ~]# \cp -r /boot/ /opt/


复制可以支持两个以上的参数，永远会把最后一个参数作为目标，其它的所有参数都会作为源
]# cp -r /root /etc/shadow    /etc/hosts /etc/login.defs  /opt/
]# ls /opt/

复制可以与　．　连用：将源数据，复制到当前路径下
]# cd /opt/
]# pwd
]# cp /etc/resolv.conf  .
]# ls
]# cd /etc/sysconfig/network-scripts/
]# pwd
]# cp /etc/passwd  .
]# ls

复制时，可以重新命名目标路径下的名称

[root@nsd1903 /]# rm -rf /opt/*
[root@nsd1903 /]# cp /etc/passwd /opt/
[root@nsd1903 /]# ls /opt/

[root@nsd1903 /]# cp /etc/passwd /opt/nsd
[root@nsd1903 /]# ls /opt/

[root@nsd1903 /]# cp -r /boot/ /opt/abc
[root@nsd1903 /]# ls /opt/

请描述下列，两次复制的不同：
[root@nsd1903 /]# rm -rf /opt/*
[root@nsd1903 /]# cp -r /home/  　/opt/test
[root@nsd1903 /]# cp -r /home/　 /opt/test
　第一次复制，将/home复制到/opt目录下改名为test
　第二次复制，将/home复制到/opt/test目录下
##############################################
Linux文件的最后必须没有 /  

##############################################

   

一4444444444










使用vim创建/修改文件内容

  三模式：命令模式　　　插入模式（输入模式）　　末行模式

[root@nsd1903 ~]# vim /opt/xiha.txt

	命--------i 键---＞插入模式(Esc 键回到命令模式)
	令
	模
	式--------: 键---＞ 末行模式 (Esc 键回到命令模式)

   末行模式  :wq 　保存并退出
　　　　　　:q! 　强制不保存并退出



查找文本内容
• 根据字符串模式提取文本行
– grep [选项] '匹配模式' 文本文件...
　
• 常用命令选项　　　　　　　　
– -v,取反匹配
– -i,忽略大小写

[root@nsd1903 ~]# grep root /etc/passwd

[root@nsd1903 ~]# grep Root /etc/passwd
[root@nsd1903 ~]# grep -i Root /etc/passwd

]# grep -v root /etc/passwd　　#不包含root的行


• 常用的匹配模式
– word　 包含字符串word
– ^word 　以字符串word开头
– word$ 　以字符串word结尾

[root@nsd1903 ~]# grep root /etc/passwd

[root@nsd1903 ~]# grep ^root /etc/passwd

[root@nsd1903 ~]# grep root$ /etc/passwd
[root@nsd1903 ~]# grep bash$ /etc/passwd

##############################################
重定向输出操作：将前面命令的输出，写入到后面文本文件中
　　>：覆盖重定向
　　＞>：追加重定向
[root@nsd1903 ~]# ls --help
[root@nsd1903 ~]# ls --help > /opt/ls.txt
[root@nsd1903 ~]# less  /opt/ls.txt

[root@nsd1903 ~]# hostname
[root@nsd1903 ~]# hostname > /opt/ls.txt 
[root@nsd1903 ~]# cat /opt/ls.txt
[root@nsd1903 ~]# hostname >> /opt/ls.txt 
[root@nsd1903 ~]# cat /opt/ls.txt

]# cat /etc/redhat-release    >> /opt/ls.txt 
]# cat /opt/ls.txt

[root@nsd1903 ~]# echo 123456

[root@nsd1903 ~]# echo 123456 > /opt/ls.txt 
[root@nsd1903 ~]# cat /opt/ls.txt

[root@nsd1903 ~]# echo NSD1903 >> /opt/ls.txt 
[root@nsd1903 ~]# cat /opt/ls.txt

###############################################
管道操作:连接或桥梁
    | :将前面命令的输出，传递给后面命令，当做后面命令的参数

　/etc/passwd文件的８到12行内容
　]# head -12 /etc/passwd     |　 tail -5 

　]# head -12 /etc/passwd    | tail -5  | cat -n

　]# cat -n /etc/passwd　 |　 head -12　 | 　tail -5
　
　]# ifconfig | head -2
　]# ifconfig | less

################################################
管理用户和组           
  
     用户： 1.登录操作系统　　２.方便对不同用户进行访问控制
　　组:方便管理用户

　　用户唯一标识： UID 
　　组唯一标识： GID 

   　Linux管理员root的UID永远为0

	Linux一个用户至少属于一个组
　　基本组：与用户同名，有系统创建加入完成
　　附加组（从属组）：管理员创建加入完成


添加用户
用户基本信息存放在 /etc/passwd 文件（系统级配置文件）

　root:x:0:0:root:/root:/bin/bash
用户名:密码占位符:UID:基本组的GID:用户描述信息:家目录:解释器

• 使用 useradd 命令
– useradd [选项]... 用户名
• 常用命令选项
– -u 用户id、-d 家目录路径、-s 登录解释器、-G 附加组

[root@nsd1903 ~]# useradd nsd01
[root@nsd1903 ~]# ls /home/

[root@nsd1903 ~]# id nsd01  #查看用户基本信息

[root@nsd1903 ~]# id haxi
id: haxi: no such user

[root@nsd1903 ~]# grep nsd01 /etc/passwd #查看用户信息

[root@nsd1903 ~]# useradd  nsd02
[root@nsd1903 ~]# grep nsd /etc/passwd

[root@nsd1903 ~]# useradd -u 1600 nsd03  ＃指定UID创建
[root@nsd1903 ~]# grep nsd /etc/passwd
[root@nsd1903 ~]# useradd  nsd04
[root@nsd1903 ~]# grep nsd /etc/passwd

]# useradd -d /mnt/abc nsd06　　＃指定用户的家目录创建
]# grep nsd06 /etc/passwd


-s 登录解释器
　/sbin/nologin：禁止用户登录系统的解释器
[root@nsd1903 ~]# useradd -s /sbin/nologin  nsd07
[root@nsd1903 ~]# grep nsd07 /etc/passwd

-G 附加组
[root@nsd1903 ~]# groupadd tarena　　　　＃创建组
[root@nsd1903 ~]# useradd -G tarena nsd08
[root@nsd1903 ~]# id nsd08
uid=1605(nsd08) gid=1606(nsd08) 组=1606(nsd08),1605(tarena)

#############################################
设置登录密码
• 使用 passwd 命令
– passwd [用户名]
[root@nsd1903 ~]# useradd nsd10
[root@nsd1903 ~]# passwd nsd10
更改用户 nsd10 的密码 。
新的 密码：　　　　　　　　　　＃设置新的密码
无效的密码： 密码少于 8 个字符
重新输入新的 密码：　　　　　　　＃重新输入新的密码
passwd：所有的身份验证令牌已经成功更新。
[root@nsd1903 ~]# su - nsd10    #命令行临时切换身份
[nsd10@nsd1903 ~]$ passwd 
更改用户 nsd10 的密码 。
为 nsd10 更改 STRESS 密码。
（当前）UNIX 密码：　　　　　　　　＃输入旧密码
新的 密码：　　　　　　　　　　　　＃设置新的密码
重新输入新的 密码：　　　　　　　　＃重新输入新的密码
passwd：所有的身份验证令牌已经成功更新。
[nsd10@nsd1903 ~]$ exit



非交互式设置密码
– echo '密码'　　 | 　　passwd 　--stdin　 用户名

[root@nsd1903 ~]# echo 123 | passwd --stdin nsd10
更改用户 nsd10 的密码 。
passwd：所有的身份验证令牌已经成功更新。

[root@nsd1903 ~]# echo redhat | passwd --stdin nsd10
更改用户 nsd10 的密码 。
passwd：所有的身份验证令牌已经成功更新。

###############################################
用户密码信息存放在 /etc/shadow 文件
[root@nsd1903 ~]# tail -1 /etc/shadow
nsd10:$6$pOWNdlhE$z9/irH93UkWigQr0FQgPC.3NmZGfVMtr6oym4
jWMWFCKRGeq4qYOysgXCR.1q9ztNfMJ91HJxGG34
V3Jq3b0n/:17990:０:99999:7:::

 用户名:密码加密字符串:上一次修改密码的时间    

#################################################

修改用户属性
• 使用 usermod 命令
– usermod [选项]... 用户名

• 常用命令选项
– -u 用户id、-d 家目录路径、-s 登录解释器
– -G 附加组

[root@nsd1903 ~]# useradd nsd11
[root@nsd1903 ~]# grep nsd11 /etc/passwd
[root@nsd1903 ~]# id nsd11

]# usermod -u 1700 -d /opt/nsd11 -G tarena -s /sbin/nologin  nsd11

]# id  nsd11

]# grep nsd11 /etc/passwd

#################################################
删除用户
• 使用 userdel 命令
– userdel [-r] 用户名
    -r:连同家目录一并删除

[root@server0 ~]# userdel -r alex
[root@server0 ~]# id alex
id: alex: no such user

###############################################
管理组账号

添加组
组基本信息存放在 /etc/group 文件
[root@nsd1903 ~]# grep  stugrp  /etc/group
 stugrp:x:1610:
  组名:组的密码占位符:组的GID编号:组的成员列表

• 使用 groupadd 命令
– groupadd [-g 组ID] 组名

[root@nsd1903 ~]# groupadd stugrp
[root@nsd1903 ~]# grep stugrp /etc/group
stugrp:x:1610:
[root@nsd1903 ~]# useradd kenji
[root@nsd1903 ~]# useradd jack
[root@nsd1903 ~]# useradd natasha
[root@nsd1903 ~]# useradd kaka

管理组成员
组成员信息存放在 /etc/gshadow 文件
• 使用 gpasswd 命令
– gpasswd -a 用户名 　组名
– gpasswd -d 用户名　 组名

[root@nsd1903 ~]# gpasswd -a kenji stugrp
[root@nsd1903 ~]# grep stugrp /etc/group

[root@nsd1903 ~]# gpasswd -a natasha stugrp
[root@nsd1903 ~]# grep stugrp /etc/group

[root@nsd1903 ~]# gpasswd -a kaka stugrp
[root@nsd1903 ~]# grep stugrp /etc/group

[root@nsd1903 ~]# gpasswd -d kaka stugrp
[root@nsd1903 ~]# grep stugrp /etc/group

[root@nsd1903 ~]# gpasswd -a jack stugrp
[root@nsd1903 ~]# grep stugrp /etc/group

##################################################
删除组
• 使用 groupdel 命令
– groupdel 组名
[root@nsd1903 ~]# groupdel stugrp
[root@nsd1903 ~]# grep stugrp /etc/group

#################################################
tar备份与恢复
  
  Linux压缩格式：
      -z  gzip ----＞　.gz
　　　-j bzip2 ----＞ .bz2
      -J  xz ----＞ .xz


归档和压缩
• 归档的含义
– 将许多零散的文件整理为一个文件
– 文件总的大小基本不变

• 压缩的含义
– 按某种算法减小文件所占用空间的大小
– 恢复时按对应的逆向算法解压

• tar 集成备份工具
– -c:创建tar包
– -x:释放tar包
– -f:指定tar包文件名称
– -z、-j、-J:调用 .gz、.bz2、.xz 格式的工具进行处理
– -t:显示tar包的文件清单
– -C:指定释放路径

tar制作压缩包（tar包）
 
　格式: tar 　选项　 /路径/压缩包的名字     /路径/源文件 ....


 tar 　-zcf　 /路径/压缩包的名字     /路径/源文件 ....

 tar 　-jcf　 /路径/压缩包的名字     /路径/源文件 ....

 tar 　-Jcf　 /路径/压缩包的名字     /路径/源文件 ....
　　 -z gzip .gz    -j bzip2 .bz2      -J  xz .xz
红色：压缩
]# rm -rf /opt/*
]# tar -zcf /opt/file.tar.gz  /home/  /etc/passwd
]# ls /opt/
]# tar -tf /opt/file.tar.gz       　  #查看包里面内容
]# tar -tf /opt/file.tar.gz  ｜　less

]# tar -jcf /opt/nsd.tar.bz2  /home/  /etc/passwd
]# tar -tf /opt/nsd.tar.bz2  
]# ls /opt/

]# tar -Jcf /opt/abc.tar.xz   /home/  /etc/passwd
]# tar -tf /opt/abc.tar.xz  
]# ls /opt/         



]# mkdir /nsd1903
]# tar -xf　 /opt/abc.tar.xz    -C 　/nsd1903/
]# ls 　/nsd1903/
]# ls 　/nsd1903/home/
]# ls 　/nsd1903/etc/

#################################################
案例2:创建一个备份包
使用 tar 工具完成以下备份任务:
– 创建一个名为 /root/backup.tar.bz2 的归档文件
– 其中包含 /usr/local 目录中的内容
– tar 归档必须使用 bzip2 进行压缩

]# tar -jcf /root/backup.tar.bz2   /usr/local/
]# ls /root/
]# tar -tf /root/backup.tar.bz2   #查看包的内容

###############################################





一5555555





教学环境介绍

• 每个学员机上有三台预先配置好的虚拟机
– server —— 作为练习用服务器
– desktop —— 作为练习用客户机

– classroom —— 提供网关/DNS/软件素材等资源

　开机时，优先开启classroom虚拟机

使用rht-vmctl辅助工具
• 控制教学用虚拟机
– 格式:rht-vmctl 控制指令 虚拟机名

reset(还原)

真机上操作：
]# rht-vmctl reset classroom　　//先重置资源服务器
]# rht-vmctl reset server
]# rht-vmctl reset desktop　　 //再重置答题虚拟机

虚拟机server
  1.利用root用户进入系统，密码为redhat
  2.查看系统版本:RHEL 7.0
  3.查看主机名:server0.example.com
  4.查看虚拟机eth0的IP地址:172.25.0.11

虚拟机desktop
   1.利用root用户进入系统，密码为redhat
　2.查看系统版本:RHEL 7.0
　3.查看主机名:desktop0.example.com
　4.查看虚拟机eth0的IP地址:172.25.0.10

##################################################
利用真机，远程管理
１.真机测试通信
[student@room9pc01 ~]$ ping 172.25.0.11
[student@room9pc01 ~]$ ping 172.25.0.10

2.真机进行远程管理
　　ssh   用户名@对方的IP地址
     -X:在远程管理时，开启对方的图形程序

[student@room9pc01 ~]$ ssh root@172.25.0.11
Last login: Mon Apr  8 10:37:39 2019 from 172.25.0.250
[root@server0 ~]# hostname

[root@server0 ~]# ifconfig | head -2

[root@server0 ~]# exit 　　#退出远程管理

补充快捷键:   Ctrl + shift + t　开启一个新的终端

################################################

[root@server0 ~]# exit　　　　　＃退出远程管理
登出
Connection to 172.25.0.11 closed.

[student@room9pc01 ~]$ ssh -X root@172.25.0.11
Last login: Mon Apr  8 10:46:47 2019
/usr/bin/xauth:  file /root/.Xauthority does not exist
[root@server0 ~]# firefox

[root@server0 ~]# 

##################################################
权限和归属

基本权限
基本权限的类别
• 访问方式(权限)
– 读取:允许查看内容-read    r 
– 写入:允许修改内容-write     w
– 可执行:允许运行和切换-execute  x 

      文本文件:
           r: cat less head tail 
           w: vim 修改并且保存   重定向　>    >>
           x: 写Shell脚本


• 权限适用对象(归属)
 – 所有者:拥有此文件/目录的用户-user  u
 – 所属组:拥有此文件/目录的组-group     g
 – 其他用户:除所有者、所属组以外的用户-other o

　　１.txt      lisi  lisi

################################################
查看权限
• 使用 ls -l 命令
– ls -ld 文件或目录...
  
  以－开头　代表为文本文件
  以ｄ开头　代表为目录
  以 l开头　代表为快捷方式

[root@server0 ~]# ls -ld /etc/

[root@server0 ~]# ls -l /etc/passwd

[root@server0 ~]# ls -ld /home/student

[root@server0 ~]# ls -l /etc/shadow

[root@server0 ~]# ls -ld /tmp
##########################################
设置基本权限
• 使用 chmod 命令
– chmod  归属关系+-=权限类别 　文档...

     [-R]:递归，目录本身及目录下所有

[root@server0 ~]# mkdir /nsd01
[root@server0 ~]# ls -ld /nsd01
[root@server0 ~]# chmod u-w /nsd01
[root@server0 ~]# ls -ld /nsd01

[root@server0 ~]# chmod g+w /nsd01
[root@server0 ~]# ls -ld /nsd01

[root@server0 ~]# chmod u=rwx /nsd01
[root@server0 ~]# ls -ld /nsd01

[root@server0 ~]# chmod o+w /nsd01
[root@server0 ~]# ls -ld /nsd01
[root@server0 ~]# chmod u=rwx,g=rx,o=--- /nsd01
[root@server0 ~]# ls -ld /nsd01

[root@server0 ~]# mkdir -p /opt/aa/bb/cc
[root@server0 ~]# ls /opt/

[root@server0 ~]# chmod -R o=--- /opt/aa
[root@server0 ~]# ls -ld /opt/aa
[root@server0 ~]# ls -ld /opt/aa/bb/
[root@server0 ~]# ls -ld /opt/aa/bb/cc/

###############################################
Linux如何判断一个用户的具备的权限：　　　匹配及停止
　１.查看用户对于该文档，所处的角色      所有者>所属组>其他人
　２.查看相应角色位置的权限
　

###############################################
 Permission denied：权限不足

目录的 r 权限:能够 ls 浏览此目录内容
目录的 w 权限:能够执行 rm/mv/cp/mkdir/touch/等更改目录内容的操作
目录的 x 权限:能够 cd 切换到此目录

#################################################
以root用户新建/nsddir目录，在此目录下新建readme.txt文件
并进一步完成下列操作
 1）使用户lisi能够在此目录下创建子目录  切换用户 su  -  lisi
     chmod o+w  /nsddir/
 2）使用户lisi不能够在此目录下创建子目录
     chmod o-w  /nsddir/
 3）使用户lisi能够修改readme.txt文件内容
     chmod o+w  /nsddir/readme.txt
 4）调整此目录的权限，使所有用户都不能cd进入此目录
     chmod u-x,g-x,o-x  /nsddir/
 5）为此目录及其下所有文档设置权限 rwxr-x---
     chmod -R  u=rwx,g=rx,o=---  /nsddir/
　　　-R：递归设置权限，目录下及目录下所有

###############################################

设置文档归属
• 使用 chown 命令
– chown [-R] 属主 文档...
– chown [-R] :属组 文档...
– chown [-R] 属主:属组 文档...

[root@server0 ~]# mkdir /nsd03
[root@server0 ~]# ls -ld /nsd03

[root@server0 ~]# groupadd tarena
[root@server0 ~]# chown lisi:tarena /nsd03
[root@server0 ~]# ls -ld /nsd03

[root@server0 ~]# chown student /nsd03
[root@server0 ~]# ls -ld /nsd03

[root@server0 ~]# chown :root /nsd03
[root@server0 ~]# ls -ld /nsd03

################################################
利用root用户新建/nsd06目录，并进一步完成下列操作　
1）将属主设为gelin01，属组设为tarena组              
[root@server0 /]# useradd gelin01
[root@server0 /]# useradd gelin02
[root@server0 /]# groupadd tarena
[root@server0 /]# chown gelin01:tarena  /nsd06
2）使用户gelin01对此目录具有rwx权限
      除属主与属组之外的人，对此目录无任何权限
[root@server0 /]# chmod o=--- /nsd06
3）使用户gelin02能进入、查看此目录内容
[root@server0 /]# gpasswd -a  gelin02  tarena
4）将gelin01加入tarena组, 将nsd06目录的权限设为rw-r-x---
      再测试gelin01用户能否进入此目录
[root@server0 /]# gpasswd -a  gelin01  tarena
[root@server0 /]# chmod u=rw,g=rx /nsd06

################################################
实现lisi用户可以读取/etc/shadow文件内容，您有几种办法?

1.修改其他人权限　　
         chmod  o+r  /etc/shadow
2.利用所属组
         chown :lisi /etc/shadow
         chmod  g+r  /etc/shadow
3.利用所有者
         chown  lisi /etc/shadow
         chmod  u+r  /etc/shadow
4.利用ACL策略
　　　　　setfacl -m  u:lisi:r  /etc/shadow


###############################################
附加权限（特殊权限）

Set GID
• 附加在属组的 x 位上
– 属组的权限标识会变为 s
– 适用于目录,Set GID可以使目录下新增的文档自动设
置与父目录相同的属组
– 继承所属组身份

[root@server0 ~]# mkdir /nsd09
[root@server0 ~]# ls -ld /nsd09

[root@server0 ~]# chown :tarena /nsd09
[root@server0 ~]# ls -ld /nsd09
[root@server0 ~]# mkdir /nsd09/test01
[root@server0 ~]# ls -ld /nsd09/test01

[root@server0 ~]# chmod g+s /nsd09/
[root@server0 ~]# ls -ld /nsd09/

[root@server0 ~]# mkdir /nsd09/test02
[root@server0 ~]# ls -ld /nsd09/test02
[root@server0 ~]# mkdir /nsd09/test02/abc
[root@server0 ~]# ls -ld /nsd09/test02/abc
################################################
Set UID
• 附加在属主的 x 位上
– 属主的权限标识会变为 s
– 适用于可执行文件,Set UID可以让使用者具有文件属
主的身份及部分权限

[root@server0 ~]# cp /usr/bin/mkdir /usr/bin/hahadir

[root@server0 ~]# chmod u+s /usr/bin/hahadir 
[root@server0 ~]# ls -l /usr/bin/hahadir

[root@server0 ~]# ls -l /usr/bin/mkdir 

[root@server0 ~]# su - dc

[dc@server0 ~]$ /usr/bin/mkdir dc01
[dc@server0 ~]$ /usr/bin/hahadir dc02
[dc@server0 ~]$ exit
        
###############################################
Sticky Bit
• 附加在其他人的 x 位上
– 其他人的权限标识会变为 t
– 适用于开放 w 权限的目录,可以阻止用户滥用 w 写入
权限(禁止操作别人的文档)

]# mkdir /home/public/
]# chmod ugo=rwx /home/public/ 

]# chmod o+t /home/public/

#############################################
acl访问控制列表(ACL策略)

acl策略的作用
• 文档归属的局限性
– 任何人只属于三种角色:属主、属组、其他人
– 无法实现更精细的控制

• acl访问策略
– 能够对个别用户、个别组设置独立的权限
– 大多数挂载的EXT3/4、XFS文件系统默认已支持

设置acl访问控制策略
• 使用 getfacl、setfacl 命令
– getfacl 文档...
– setfacl  -m u:用户名:权限类别 文档...
– setfacl  -m g:组名:权限类别 文档...
– setfacl  -b 文档...               #删除所有ACL策略
– setfacl  -m u:用户名   文档...      #删除单条指定ACL策略

　　　[-R]：递归设置ACL策略




一6666666666666666





教学环境介绍

– 格式:rht-vmctl 控制指令 虚拟机名

reset(还原)

真机上操作：
　]# rht-vmctl reset classroom　 //先重置资源服务器
　]# rht-vmctl reset server
　]# rht-vmctl reset desktop　　 //再重置练习虚拟机





虚拟机server
  1.利用root用户进入系统，密码为redhat
  2.查看系统版本:RHEL 7.0
  3.查看主机名:server0.example.com
  4.查看虚拟机eth0的IP地址:172.25.0.11   

虚拟机desktop
   1.利用root用户进入系统，密码为redhat
　2.查看系统版本:RHEL 7.0
　3.查看主机名:desktop0.example.com
　4.查看虚拟机eth0的IP地址:172.25.0.10

##################################################
软件包管理

零散软件管理
1.首先需要具备软件的安装包
2.构建Web服务或FTP服务，共享光盘所有内容
　　　Web服务:提供网页内容的服务

3.将虚拟机classroom已经构建完成Web服务，已经共享光盘所有内容4.真机浏览器，访问测试
　　　	 classroom.example.com

          content/rhel7.0/x86_64/dvd/Packages/
5.下载软件包

• 使用wget下载工具
– wget 软件包的URL网址　　＃默认下载到当前目录下

– wget 软件包的URL网址 　-O(大写) 　/目录路径/新文件名

提供FTP功能的软件包(vsftpd)

当前页面查找:vsftpd

[root@server0 ~]# wget  http://classroom.example.com/content/rhel7.0/x86_64/dvd/Packages/vsftpd-3.0.2-9.el7.x86_64.rpm

[root@server0 ~]# ls

• RPM Package Manager,RPM包管理器
– rpm -q 软件名             　　　   #查询该软件是否已经安装
– rpm -ivh 软件名-版本信息.rpm...　　#安装软件包
– rpm -e 软件名...

[root@server0 ~]# rpm -q firefox    
firefox-24.5.0-1.el7.x86_64
[root@server0 ~]# rpm -q haha
未安装软件包 haha 
[root@server0 ~]# rpm -q bash
bash-4.2.45-5.el7.x86_64
[root@server0 ~]# rpm -q hostname

[root@server0 ~]# rpm -q zip

[root@server0 ~]# rpm -q httpd

]# rpm -ivh /root/vsftpd-3.0.2-9.el7.x86_64.rpm 

]# rpm -q vsftpd　　　#查询是否安装成功

]# rpm -e vsftpd　　　　#卸载软件
]# rpm -q vsftpd　　　#查询是否卸载成功
#################################################
了解:导入新的红帽签名
]# wget http://classroom.example.com/content/rhel7.0/x86_64/dvd/RPM-GPG-KEY-redhat-release

]# rpm --import /root/RPM-GPG-KEY-redhat-release 
]# rpm -q vsftpd

]# rpm -ivh /root/vsftpd-3.0.2-9.el7.x86_64.rpm 

########################################
升级Linux内核

1.下载新的内核软件包
]# wget http://classroom.example.com/content/rhel7.0/x86_64/errata/Packages/kernel-3.10.0-123.1.2.el7.x86_64.rpm

]# ls
 
2.安装新的内核软件包
[root@server0 qw~]# uname -r  #查看内核版本

]# rpm -ivh /root/kernel-3.10.0-123.1.2.el7.x86_64.rpm 

[root@server0 ~]# uname -r
[root@server0 ~]# reboot 

[student@room9pc01 ~]$ ssh -X root@172.25.0.11
[root@server0 ~]# uname -r
3.10.0-123.1.2.el7.x86_64
[root@server0 ~]# 
################################################
安装软件包常见提示:
1.软件包已经安装
]# rpm -ivh /root/vsftpd-3.0.2-9.el7.x86_64.rpm 
准备中...                                            ################################# [100%]
	软件包 vsftpd-3.0.2-9.el7.x86_64 已经安装

[root@server0 ~]# LANG=en　　　　＃讲当前系统语言修改英文
]# rpm -ivh /root/vsftpd-3.0.2-9.el7.x86_64.rpm 
Preparing...                                         ################################# [100%]
	package vsftpd-3.0.2-9.el7.x86_64 is already installed
[root@server0 ~]#
 
2.软件包的依赖关系
]# rpm -ivh /root/bind-chroot-9.9.4-14.el7.x86_64.rpm 
错误：依赖检测失败：
	bind = 32:9.9.4-14.el7 被 bind-chroot-32:9.9.4-14.el7.x86_64 需要

################################################
Yum软件包管理
　　自动解决软件包的依赖关系

Yum配置及使用(Yum软件包仓库)

服务：为客户端自动解决依赖关系安装软件包

服务端：虚拟机classroom　
　　　1.众多的软件包　　2.仓库数据文件　　３.构建web或ftp服务
              　光盘中既具备软件包，又具备仓库数据文件
　　　　　　　软件包	Packages
　　　　　　　仓库数据文件　repodata
　　　总结：构建web或ftp服务，共享光盘所有内容

客户端：指定服务端位置
　　客户端配置文件:/etc/yum.repos.d/*.repo
        　错误的客户端配置文件，会影响正确的客户端配置文件  
　　　[] name  baseurl  enabled  gpgcheck      

[root@server0 ~]# rm -rf /etc/yum.repos.d/*
[root@server0 ~]# vim /etc/yum.repos.d/dvd.repo
[nsd1903]　　　　　　　＃仓库标识　　
name=rhel7　　　　　　＃仓库描述信息
baseurl=http://classroom.example.com/content/rhel7.0/x86_64/dvd　　　　　　　＃指定服务端在哪里
enabled=1　　　　　　　＃启用本文件
gpgcheck=0　　　　　　　＃不检测软件包的签名

[root@server0 ~]# yum repolist   #列出仓库信息
 
源标识              源名称            状态
nsd1903             rhel7             4,305
repolist: 4,305
[root@server0 ~]# 

Yum的使用:
[root@server0 ~]# yum -y install httpd
[root@server0 ~]# rpm -q httpd
httpd-2.4.6-17.el7.x86_64

]# yum -y install sssd
]# yum -y install gcc
]# yum -y install bind-chroot
]# yum -y install vsftpd
]# yum -y install system-config-kickstart 


[root@server0 ~]# yum 　remove　 gcc　  #卸载


[root@server0 ~]# yum clean all　　＃清空缓存

################################################
分区规划及使用
 
  扇区大小默认为512字节

硬盘（块设备）分区管理

一块硬盘的“艺术”之旅
• 识别硬盘 => 分区规划 => 格式化 => 挂载使用
　毛坯楼层 => 打隔断 => 装修 => 入驻

一 识别硬盘
[root@server0 ~]# lsblk 　　　　＃显示当前系统中硬盘
　NAME    　SIZE 　　TYPE 
　vda     　10G 　　 disk 
　└─vda1   10G  　part 
　vdb    　 10G  　　disk 

二 分区规划
     
     分区模式：MBR 主引导记录分区模式
　　• MBR/msdos 分区模式
　　– 1~4个主分区　或者　3个主分区+1个扩展分区(n个逻辑分区)
　　– 最大支持容量为 2.2TB 的磁盘
　　– 扩展分区不能格式化
　　
　　/dev/sda5：该设备标识的含义
　　　　　　　　第一块SCSI接口的设备，第五个分区
　　　　　　　　第一块SCSI接口的设备，第一个逻辑分区


[root@server0 ~]# fdisk  /dev/vdb 
  n 创建新的分区----->回车----->回车---->回车----->在last结束时 +1G
  p 查看分区表
  n 创建新的分区----->回车----->回车---->回车----->在last结束时 +2G
  d 删除分区
  w 保存并退出    

[root@server0 ~]# lsblk
[root@server0 ~]# ls  /dev/vdb[1-2]

三　格式化:赋予空间文件系统
　　文件系统：数据在空间存储的规则

　　Windows: FAT  NTFS
    Linux:
         RHEL6:ext4
         RHEL7:xfs

• mkfs 工具集
– mkfs.ext3 分区设备路径
– mkfs.ext4 分区设备路径
– mkfs.xfs 分区设备路径
– mkfs.vfat -F 32 分区设备路径

[root@server0 ~]# mkfs.ext4 /dev/vdb1　＃格式化文件系统
[root@server0 ~]# blkid /dev/vdb1   #查看文件系统类型

[root@server0 ~]# mkfs.xfs /dev/vdb2　＃格式化文件系统
[root@server0 ~]# blkid /dev/vdb2　　#查看文件系统类型

四　挂载设备进行使用                            
[root@server0 ~]# mkdir /mypart1
[root@server0 ~]# mount /dev/vdb1 /mypart1
[root@server0 ~]# df -h　　　#显示正在挂载设备的使用情况

[root@server0 ~]# mount /dev/vdb2 /mypart2
mount: 挂载点 /mypart2 不存在

[root@server0 ~]# mkdir /mypart2
[root@server0 ~]# mount /dev/vdb2 /mypart2
[root@server0 ~]# df -h　　　#显示正在挂载设备的使用情况
###################################################
五　永久挂载（开机自动挂载）
实现开机自动挂载
• 配置文件 /etc/fstab 的记录格式
   设备路径    挂载点         类型       参数      备份标记     检测顺序

vim命令模式　按o另起新的一行 进入插入模式

[root@server0 ~]# vim /etc/fstab
 /dev/vdb1 /mypart1  ext4  defaults 0 0
 /dev/vdb2 /mypart2  xfs  defaults 0 0

[root@server0 ~]# umount /mypart1  　#保证当前没有挂载
[root@server0 ~]# umount /mypart2　　#保证当前没有挂载

[root@server0 ~]# df -h
[root@server0 ~]# mount -a
   检测/etc/fstab开机自动挂载配置文件,格式是否正确
   检测/etc/fstab中,书写完成,但当前没有挂载的设备,进行挂载 
[root@server0 ~]# df -h
###################################################
综合分区，/dev/vdb继续分区
最终有3个主分区，分别为1G、2G、2G
   创建扩展分区 --->  两个逻辑分区，分别为1G、1G
[root@server0 ~]# fdisk  /dev/vdb
   p 查看分区表
   n 创建主分区----->回车----->回车---->回车----->在last结束时 +2G
   p 查看分区表
   n 创建扩展分区 
          ----->回车---->起始回车----->结束回车   将所有空间给扩展分区
   p 查看分区表
   n 创建逻辑分区----->起始回车------>结束+1G
   n 创建逻辑分区----->起始回车------>结束+1G
   p 查看分区表
   w 保存并退出
[root@server0 ~]# partprobe   #刷新分区表
[root@server0 ~]# lsblk 
#####################################################
总结：
1.识别硬盘　lsblk
2.分区规划    fdisk
3.刷新分区表　　partprobe
4.进行格式化　　mkfs.xfs  mkfs.ext4   blkid
5.挂载使用　mount  /etc/fstab开机自动挂载   mount -a  df -h
####################################################





一777777777777777




教学环境介绍

– 格式:rht-vmctl 控制指令 虚拟机名

reset(还原)

真机上操作：
　]# rht-vmctl reset classroom　 //先重置资源服务器
　]# rht-vmctl reset server
　]# rht-vmctl reset desktop　　 //再重置练习虚拟机

虚拟机server
  1.利用root用户进入系统，密码为redhat
  2.查看系统版本:RHEL 7.0
  3.查看主机名:server0.example.com
  4.查看虚拟机eth0的IP地址:172.25.0.11   

虚拟机desktop
   1.利用root用户进入系统，密码为redhat
　2.查看系统版本:RHEL 7.0
　3.查看主机名:desktop0.example.com
　4.查看虚拟机eth0的IP地址:172.25.0.10

##################################################
一 添加硬盘
1.虚拟机server进行关机
[root@server0 ~]# poweroff 
Connection to 172.25.0.11 closed by remote host.
Connection to 172.25.0.11 closed.
[student@room9pc01 ~]$ 

2.远程管理虚拟机server
[student@room9pc01 ~]$ ssh -X  root@172.25.0.11
[root@server0 ~]# lsblk

二 分区规划
  划分可以使用的5个分区,每个分区10G
[root@server0 ~]# fdisk  /dev/vdc
   p 查看分区表
   n 创建主分区----->回车----->回车---->回车----->在last结束时 +10G
         ....... 连续划分3个主分区
   p 查看分区表
   n 创建扩展分区 
          ----->回车---->起始回车----->结束回车   将所有空间给扩展分区
   p 查看分区表
   n 创建逻辑分区----->起始回车------>结束+10G
   n 创建逻辑分区----->起始回车------>结束+10G
   p 查看分区表
   w 保存并退出
[root@server0 ~]# lsblk 


LVM逻辑卷
       作用: 整合分散的空间   大小可以动态扩大

   1.零散空闲存储 (物理卷PV)
   2.整合的虚拟磁盘 (卷组VG)
   3.虚拟的分区 (逻辑卷LV)

   将众多的物理卷(PV),组建成卷组(VG),再从卷组中划分逻辑卷(LV)

####################################################
逻辑卷的制作
successfully(成功)                 
1.创建卷组名为systemvg
    格式: vgcreate 卷组名   设备路径........

[root@server0 ~]# vgcreate systemvg /dev/vdc[1-2]
 
[root@server0 ~]# pvs   #查看物理卷信息
[root@server0 ~]# vgs   #查看卷组信息

2.创建逻辑卷
    格式: lvcreate -n 逻辑卷名字   -L 逻辑卷大小   卷组名

[root@server0 ~]# lvcreate -n vo -L 16G systemvg 
  Logical volume "vo" created

[root@server0 ~]# lvs  #查看当前系统中,所有逻辑卷信息
                                          
[root@server0 ~]# vgs  #查看当前系统中,所有卷组信息
###################################################
逻辑卷的使用                                                    
1.查看逻辑卷设备文件
[root@server0 ~]# ls /dev/systemvg/vo 
[root@server0 ~]# ls -l /dev/systemvg/vo
[root@server0 ~]# ls /dev/dm-0

2.格式化文件系统,进行挂载
[root@server0 ~]# mkfs.xfs /dev/systemvg/vo 
[root@server0 ~]# blkid /dev/systemvg/vo

[root@server0 ~]# vim /etc/fstab 
 /dev/systemvg/vo  /mylv  xfs defaults 0 0
[root@server0 ~]# mount -a
[root@server0 ~]# df -h

##################################################
逻辑卷的扩展
一 卷组有足够的剩余空间
1.扩展空间的大小
[root@server0 ~]# vgs
[root@server0 ~]# lvextend -L 18G /dev/systemvg/vo 
[root@server0 ~]# lvs

2.扩展文件系统的大小
      扩展ext4: resize2fs 
      扩展xfs: xfs_growfs 
[root@server0 ~]# xfs_growfs /dev/systemvg/vo
[root@server0 ~]# df -h

二 卷组没有足够的剩余空间
1.扩展卷组的空间
[root@server0 ~]# vgextend systemvg /dev/vdc3
[root@server0 ~]# vgs

2.扩展逻辑卷空间的大小
[root@server0 ~]# vgs
[root@server0 ~]# lvextend -L 25G /dev/systemvg/vo 
[root@server0 ~]# lvs

2.扩展逻辑卷文件系统的大小
[root@server0 ~]# xfs_growfs /dev/systemvg/vo
[root@server0 ~]# df -h

###################################################
了解: 逻辑卷可以扩展,也可以缩小

###################################################
卷组划分空间的单位:PE 

   默认1PE为4M大小
[root@server0 ~]# vgdisplay systemvg   #显示卷组详细信息

  PE Size               4.00 MiB

 请划分一个250M的逻辑卷,命名为lvtest01
[root@server0 ~]# vgchange -s 1M systemvg  #修改PE的大小
[root@server0 ~]# vgdisplay systemvg

[root@server0 ~]# lvcreate -n lvtest01 -L 250M systemvg 
[root@server0 ~]# lvs

• 创建卷组的时候设置PE大小
– vgcreate -s PE大小 卷组名 空闲分区...

• 创建逻辑卷的时候指定PE个数
– lvcreate -l PE个数  -n 逻辑卷名 卷组名

################################################
逻辑卷的删除
 lvremove   vgremove   pvremove

  优先删除逻辑卷,再去删除卷组,最后删除物理卷

[root@server0 ~]# lvremove /dev/systemvg/vo 
  Logical volume systemvg/vo contains a filesystem in use.
[root@server0 ~]# umount /mylv/
[root@server0 ~]# lvremove /dev/systemvg/vo 
Do you really want to remove active logical volume vo? [y/n]: y
  Logical volume "vo" successfully removed
[root@server0 ~]# lvs

  删除卷组,需要首先删除,基于此卷组创建的所有逻辑卷
   命令格式:vgremove  卷组名
####################################################
find高级使用

查找文件
• 根据预设的条件递归查找对应的文件
– find [目录] [条件1] [-a|-o] [条件2] ...

– 常用条件表示:
  -type 类型(l快捷方式、d目录、f文本文件)
  -name "文档名称"
  -size +|-文件大小(k、M、G)
  -user 用户名
  -mtime 根据文件修改时间

############################################
  -type 类型(l快捷方式、d目录、f文本文件)

[root@server0 ~]# find /boot/ -type l
[root@server0 ~]# ls /boot/grub/menu.lst 
[root@server0 ~]# ls -l /boot/grub/menu.lst

[root@server0 ~]# find /boot/ -type d
[root@server0 ~]# find /boot/ -type f

[root@server0 ~]# find /root -type d
[root@server0 ~]# find /root -type f

[root@server0 ~]# man find   #权威帮助信息

################################################
-name '文档名称'

[root@server0 ~]# find /etc/ -name 'passwd'
[root@server0 ~]# find /etc/ -name 'passwd*'
[root@server0 ~]# find /etc/ -name '*passwd*'

[root@server0 ~]# mkdir /root/nsd01
[root@server0 ~]# mkdir /root/nsd1903
[root@server0 ~]# touch /root/nsd01.txt
[root@server0 ~]# find /root/ -name 'nsd*'

[root@server0 ~]# find /root/ -name 'nsd*'  -type f
[root@server0 ~]# find /root/ -name 'nsd*'  -type d

####################################################
  -size +|-文件大小(k、M、G)       百度 EB单位

[root@server0 ~]# find /boot/ -size +10M
[root@server0 ~]# find /boot/ -size +300k

  -user 用户名
[root@server0 ~]# find /  -user  student
[root@server0 ~]# ls -ld /home/student

[root@server0 ~]# find /  -user  student -type f

###################################################
 -mtime 根据文件修改时间
  所有的时间都是过去时间

 -mtime +10  #十天之前创建或修改的数据

 -mtime -10  #最近十天之内创建或修改的数据

 -mtime +90  #三个月之前创建或修改的数据

[root@server0 ~]# find /var/log/ -mtime +90
[root@server0 ~]# find /var/log/ -mtime +1000

[root@server0 ~]# ls -l /var/log/yum.log 
[root@server0 ~]# date    #查看当前系统时间
##################################################
find扩展使用
• 使用find命令的 -exec 操作
– find .. .. -exec 处理命令 {} \;
– 优势:以 {} 代替每一个find的查找结果,逐个处理,遇 \; 结束

]# find /boot/ -name 'vm*'
]# find /boot/ -name 'vm*' -exec  cp  {}  /opt  \;
]# ls /opt/

]# find /boot/ -size +10M
]# find /boot/ -size +10M  -exec  cp  {}  /opt  \;
]# ls /opt/

###################################################
案例4:查找并处理文件
• 使用find命令完成以下任务
– 请创建目录/root/findfiles/ 
– 找出所有 用户 student 拥有的文件
– 把它们拷贝到 /root/findfiles/ 文件夹中

]# mkdir /root/findfiles

]# find /  -user student -type f   -exec cp  {} /root/findfiles/  \;

]# ls -A /root/findfiles/

#################################################
查看当前系统时间:date
修改时间: date  -s  '年-月-日    时:分:秒'

[root@server0 ~]# date
[root@server0 ~]# date -s '2008-10-1  10:12:02'

[root@server0 ~]# date
[root@server0 ~]# date -s '2019-4-10 15:43'
[root@server0 ~]# date

################################################
NTP时间同步

NTP网络时间协议
• Network Time Protocol
– NTP服务器为客户机提供标准时间
– NTP客户机需要与NTP服务器保持沟通

NTP服务器:虚拟机classroom

NTP客户机:虚拟机server
1.安装chrony软件包
[root@server0 ~]# yum -y install chrony
    
软件包 chrony-1.29.1-1.el7.x86_64 已安装并且是最新版本
无须任何处理

[root@server0 ~]# rpm -q chrony
chrony-1.29.1-1.el7.x86_64

2.修改配置文件/etc/chrony.conf
[root@server0 ~]# vim  /etc/chrony.conf
  以#开头的行,为注释行
 #server 0.rhel.pool.ntp.org iburst
 #server 1.rhel.pool.ntp.org iburst
 #server 2.rhel.pool.ntp.org iburst
 server classroom.example.com iburst

3.重启服务(程序)
[root@server0 ~]# systemctl restart chronyd
[root@server0 ~]# systemctl enable chronyd  #开机自启

  daemon
    英 [ˈdi:mən] 美 ['di:mən]
    守护神;（希腊神话中）半人半神的精灵;[计]守护进程(程序)

4.验证
[root@server0 ~]# date -s '2008-10-1'
2008年 10月 01日 星期三 00:00:00 CST
[root@server0 ~]# date

[root@server0 ~]# systemctl restart chronyd
[root@server0 ~]# date
[root@server0 ~]# date
[root@server0 ~]# date
[root@server0 ~]# date

#################################################
cron计划任务

cron任务概述
• 用途:按照设置的时间间隔为用户反复执行某一项固
定的系统任务

• 软件包:cronie、crontabs
• 系统服务:crond
• 日志文件:/var/log/crond

如何编写crontab任务记录
• 配置格式可参考 /etc/crontab 文件
   分   时   日   月   周     任务命令行(绝对路径)

   *    *     *     *    *      #每分钟都执行一次
   30    8    *     *    *     #每天早晨八点半 执行一次

   0     21   *     *    1-5   #周一至周五 晚上的九点正

   0     21   *     *    1,3,5,7    #周一 周三 周五 周日 晚上的九点正

   1     8    1      *     1       #周一与每月一号都会执行

   0     */2   *     *    *      #每隔2个小时执行一次


	 *:匹配范围内任意时间
	,:分隔多个不连续的时间点
	-:指定连续时间范围
	/n:指定时间频率,每n ...


	执行周期 配置说明
	   分钟 从0到59之间的整数
	   小时 从0到23之间的整数
	   日期 从1到31之间的整数
	   月份 从1到12之间的整数
	   星期 0~7之间的整数,0或7代表星期日

管理计划任务策略
• 使用 crontab 命令
– 编辑:crontab -e [-u 用户名]
– 查看:crontab -l [-u 用户名]
– 清除:crontab -r [-u 用户名]

 每分钟记录当前系统的时间,写入到/opt/time.txt
[root@server0 ~]# date

[root@server0 ~]# date >>  /opt/time.txt
[root@server0 ~]# cat /opt/time.txt

[root@server0 ~]# crontab -e -u root
* * * * *  date >> /opt/time.txt

[root@server0 ~]# crontab -l -u root

[root@server0 ~]# ls /var/spool/cron/
[root@server0 ~]# cat /var/spool/cron/root #生成的任务文件

[root@server0 ~]# cat /opt/time.txt 

###############################################



LDAP


使用LDAP认证,实现网络用户认证,达到用户的集中管理
  
　　RHCSA　红帽认证管理员  
　　RHCE　红帽认证工程师
　　RHCA　红帽认证架构师

     网络用户:用户信息会放在网络中LDAP服务器
     本地用户:用户信息会放在/etc/passwd

LDAP服务器:虚拟机classroom

客户端:虚拟机server
1.安装sssd软件,与LDAP服务器沟通
[root@server0 /]# yum -y install sssd
[root@server0 /]# rpm -q sssd

2.安装authconfig-gtk图形的工具,进行配置客户端sssd软件
[root@server0 /]# yum -y install authconfig-gtk
[root@server0 /]# authconfig-gtk

完全合格的主机名  www.baidu.com　　　www.qq.com    
               classroom.example.com

     选择LDAP
      dc=example,dc=com             #指定服务端域名
      classroom.example.com         #指定服务端主机名
     勾选TLS加密
      使用证书加密:
     http://classroom.example.com/pub/example-ca.crt

     选择LDAP密码 

3.重起服务
[root@server0 ~]# systemctl  restart  sssd   #重起服务
[root@server0 ~]# systemctl  enable  sssd    #设置开机自启动
[root@server0 ~]# grep ldapuser0 /etc/passwd
[root@server0 ~]# id ldapuser0     #验证LDAP用户信息
          
###################################################      
家目录漫游

    在LDAP服务器搭建共享,共享所有普通用户的家目录

  LDAP服务器:虚拟机classroom

    虚拟机classroom已经完成共享所有操作

 虚拟机server:访问共享数据
[root@server0 ~]# mkdir /haha
[root@server0 ~]# ls /haha
[root@server0 ~]# showmount -e classroom.example.com
Export list for classroom.example.com:
/home/guests 172.25.0.0/255.255.0.0

[root@server0 ~]# mount classroom.example.com:/home/guests  /haha
[root@server0 ~]# df -h

[root@server0 ~]# mkdir /home/guests
[root@server0 ~]# mount classroom.example.com:/home/guests/   /home/guests
[root@server0 ~]# ls /home/guests

[root@server0 ~]# su - ldapuser0
上一次登录：三 4月 10 19:21:04 CST 2019pts/0 上
[ldapuser0@server0 ~]$ 

################################################




二11111111111








教学环境介绍

– 格式:rht-vmctl 控制指令 虚拟机名

reset(还原)

真机上操作：
　]# rht-vmctl reset classroom　 //先重置资源服务器
　]# rht-vmctl reset server
　]# rht-vmctl reset desktop　　 //再重置练习虚拟机
##################################################
Shell脚本基础

     脚本:一个可以执行的文件,运行可以实现某种功能

    创建用户zhangsan ------->  useradd zhangsan
   
1. 编写一个面世问候 /root/hello.sh 脚本
– 显示出一段话 “Hello World”
[root@server0 ~]# vim  /root/hello.sh
echo Hello World

[root@server0 ~]# chmod +x /root/hello.sh  #赋予执行权限
[root@server0 ~]# /root/hello.sh   #以绝对路径运行
 
规范Shell脚本的一般组成
• #! 环境声明,以下代码由那个程序进行运行
• # 注释文本
• 可执行代码



2. 编写一个能输出系统信息的 /root/sysinfo 脚本
1)输出当前红帽系统的版本信息
2)输出当前使用的内核版本
3)输出当前系统的主机名

[root@server0 ~]# vim /root/sysinfo
 #!/bin/bash
 cat /etc/redhat-release
 uname -r
 hostname
 ifconfig | head -2

[root@server0 ~]# chmod +x /root/sysinfo
[root@server0 ~]# /root/sysinfo

################################################
重定向输出
      >:只收集前面命令的正确输出
     2>:只收集前面命令的错误输出
     &>:收集前面命令的所有输出
[root@server0 ~]# echo 123 > /opt/1.txt
[root@server0 ~]# cat /opt/1.txt
[root@server0 ~]# cat /a
[root@server0 ~]# cat /opt/1.txt  /a

[root@server0 ~]# cat /opt/1.txt  /a   > /opt/b.txt
[root@server0 ~]# cat /opt/b.txt

[root@server0 ~]# cat /opt/1.txt  /a   2> /opt/b.txt 
[root@server0 ~]# cat /opt/b.txt

[root@server0 ~]# cat /opt/1.txt  /a  &> /opt/b.txt 
[root@server0 ~]# cat /opt/b.txt

##################################################
补充:
    单引号 '  ' :屏蔽所有的特殊符号,原样输出

  [root@server0 ~]# echo  ' * ? | . .. &  '

   $( ) 或 反撇号 ` `:将命令输出结果,直接参与下一次运行

[root@server0 opt]# cd /opt/
[root@server0 opt]# mkdir $(hostname)

[root@server0 opt]# date +%F
[root@server0 opt]# mkdir mydir-$(date +%F)

#################################################
 案例:书写一个创建用户,设置密码的脚本user.sh  
     /dev/null:黑洞设备	  

[root@server0 /]# vim /root/user.sh
 #!/bin/bash
 useradd nsd04 &> /dev/null
 echo 用户nsd04创建成功
 echo 123 | passwd --stdin  nsd04 &> /dev/null
 echo 用户nsd04密码设置成功

[root@server0 /]# chmod +x /root/user.sh
[root@server0 /]# /root/user.sh

  为了让脚本适应多变的环境与多种不同需求,所以使用变量

   变量:会变化的量      容器=存放可以变化的量

    以不变的名称,存放可以变化的值
    变量名=存放的值

• 以不变的名称存放的可能会变化的值         
 – 变量名=变量值
 – 方便以固定名称重复使用某个值
 – 提高对任务需求、运行环境变化的适应能力

[root@server0 /]# cat /root/user.sh 
 #!/bin/bash
 a=nsd07                     #定义变量a,储存值nsd07
 useradd  $a &> /dev/null
 echo  用户$a创建成功
 echo  123  |  passwd --stdin  $a  &>  /dev/null
 echo  用户$a密码设置成功


定义/赋值变量
• 设置变量时的注意事项
– 等号两边不要有空格
– 变量名只能由字母/数字/下划线组成,区分大小写
– 变量名不能以数字开头,不要使用关键字和特殊字符
– 若指定的变量名已存在,相当于为此变量重新赋值

查看/引用变量
– 引用变量值:$变量名
– 查看变量值:echo $变量名、echo ${变量名}
[root@server0 /]# a=redhat
[root@server0 /]# echo $a
[root@server0 /]# echo $a7
[root@server0 /]# echo ${a}7

变量的种类

环境变量:变量名为大写,变量的值有系统定义完成

   USER=存储当前登录系统的用户
[root@server0 /]# echo $USER
root
[root@server0 /]# su - student
[student@server0 ~]$ echo $USER
student
[student@server0 ~]$ exit
logout
[root@server0 /]# 

位置变量
• 在执行脚本时提供的命令行参数
– 表示为 $n,n为序号
– $1、$2、.. .. ${10}、${11}、.. ..

[root@server0 /]# vim /root/1.sh 
#!/bin/bash
echo $1
echo $2
[root@server0 /]# chmod +x /root/1.sh
[root@server0 /]# /root/1.sh dc tc

[root@server0 /]#  vim /root/user.sh
#!/bin/bash
#a=nsd07
useradd $1 &> /dev/null
echo 用户$1创建成功
echo 123 | passwd --stdin  $1 &> /dev/null
echo 用户$1密码设置成功
[root@server0 /]#  /root/user.sh dc


[root@server0 /]# vim /root/cat.sh
 #!/bin/bash
 cat -n  $1  |  head -$2

[root@server0 /]# chmod +x /root/cat.sh
[root@server0 /]# /root/cat.sh /etc/passwd   3
[root@server0 /]# /root/cat.sh /etc/shadow   2

  降低脚本的使用难度,可以产生交互
   read  -p '屏幕提示信息'

         1.直接产生交互
         2.记录用户在键盘上的输入内容
         3.将 用户在键盘上的输入内容,赋值给一个变量储存

[root@server0 /]# cat /root/user.sh 
#!/bin/bash
read -p '请输入您要创建的用户名:'   a
read -p '请输入您要设置的密码:'   b
useradd $a &> /dev/null
echo 用户$a创建成功
echo $b | passwd --stdin  $a &> /dev/null
echo 用户$a密码设置成功
[root@server0 /]# 



预定义变量
• 用来保存脚本程序的执行信息
– 直接使用这些变量
– 不能直接为这些变量赋值

   $# 已加载的位置变量的个数
   $? 程序退出后的状态值,0表示正常,其他值异常

[root@server0 /]# vim /root/1.sh 
 #!/bin/bash
 echo $1
 echo $2
 echo $#

[root@server0 /]# /root/1.sh  haha  xixi 
[root@server0 /]# /root/1.sh  haha  xixi dc tc
[root@server0 /]# /root/1.sh  

##################################################
条件测试

     [   测试表达式   ]


常用的测试选项
• 检查文件状态
  -e:文档存在为真
  -d:文档存在,且必须为目录才为真
  -f:文档存在,且必须为文件才为真
[root@server0 /]# [  -e   /etc/passwd  ]
[root@server0 /]# echo $?

[root@server0 /]# [  -d   /etc/passwd  ]
[root@server0 /]# echo $?

[root@server0 /]# [  -d   /etc/  ]
[root@server0 /]# echo $?

[root@server0 /]# [  -f   /etc/fstab  ]
[root@server0 /]# echo $?


• 比较整数大小
   -gt:大于
   -ge:大于等于
   -eq:等于
   -ne:不等于
   -lt:小于
   -le:小于等于
[root@server0 /]# [  1  -eq  1  ]
[root@server0 /]# echo $?
0
[root@server0 /]# [  1  -gt  1  ]
[root@server0 /]# echo $?
1
[root@server0 /]# [  1  -ge  1  ]
[root@server0 /]# echo $?
0

• 字符串比对 
     ==: 两个字符串一样为真
     !=: 两个字符串不一样为真
[root@server0 /]# [  haha  !=  student ]
[root@server0 /]# echo $?
0
[root@server0 /]# [ haha  ==  haha  ]
[root@server0 /]# echo $?
0
[root@server0 /]# [ $USER  == root  ]
[root@server0 /]# echo $?
0
##################################################
if选择结构

双分支
	if  [条件测试];then
	  命令序列xx
	else
	  命令序列yy
	fi

[root@server0 /]# vim /root/if01.sh 
 #!/bin/bash
 if  [  $1  -eq  1  ];then
   echo hello
 else
   echo hi
 fi
[root@server0 /]# /root/if01.sh  1
[root@server0 /]# /root/if01.sh  2

[root@server0 /]# vim /root/if02.sh   
 #!/bin/bash
 if [ $# -eq 0  ];then
   echo 您没有输入参数
 else
   echo 您一共输入了 $# 个参数
 fi

[root@server0 /]# /root/if02.sh dc tc
 您一共输入了2个参数
[root@server0 /]# /root/if02.sh 
 您没有输入参数

##################################################
if多分支处理

	if  [条件测试1];then
	  命令序列xx
	elif  [条件测试2];then
	  命令序列yy

	else
	  命令序列zz
	fi

案例:
   利用read 读入用户输入的成绩
   如果用户输入的成绩大于等于90,则输出 优秀
   如果用户输入的成绩大于等于80,则输出 良好
   如果用户输入的成绩大于等于70,则输出 一般
   如果用户输入的成绩大于等于60,则输出 合格
   如果以上条件均不满足,则输出 '再牛的肖邦,也弹不出哥的悲伤'

[root@server0 /]# vim  /root/if03.sh
 #!/bin/bash
 read  -p  '请输入您的成绩:'    num
 if  [ $num -ge 90 ];then
    echo 优秀
 elif [ $num -ge 80 ];then
    echo 良好
 elif [ $num -ge 70 ];then
    echo 一般
 elif [ $num -ge 60 ];then
    echo 合格
 else
    echo '再牛的肖邦,也弹不出哥的悲伤'
 fi 
[root@server0 /]# 

###################################################
案例:书写一个判断用户的脚本
   利用位置变量$1,进行判断:
     如果用户存在,输出用户基本信息(id 用户)
     如果用户不存在,则创建该用户,输出用户创建成功
   
[root@server0 /]# vim  /root/if04.sh 
 #!/bin/bash
 id $1 &> /dev/null
 if  [ $? -eq 0 ];then
  echo 用户已存在
  id $1
 else
  useradd $1
  echo 用户创建成功
 fi


案例:
   利用read 读入用户输入的IP地址
     如果本机能够ping通该IP地址,则输出 可以通信        
     如果本机不能够ping通该IP地址,则输出 不可以通信
    ping  -c选项:指定ping几个包结束
[root@server0 /]# vim  /root/if05.sh
 #!/bin/bash
 read -p  '请输入您要测试的IP地址:'   ip
 ping -c 2  $ip &> /dev/null
 if  [ $? -eq 0 ];then
   echo $ip可以通信
 else
   echo $ip不可以通信
 fi

##################################################

for循环结构:解决反复执行重复性的操作


	for  变量名  in 值列表
	do
	    命令序列
	done

[root@server0 /]# vim /root/for01.sh
 #!/bin/bash
 for  a  in  lisi  zhangsan  wangwu  dc  tc
 do
  useradd $a  &> /dev/null
  echo  $a创建成功
 done
[root@server0 /]# 

  值的列表可以不参与循环体
[root@server0 /]# cat /root/for01.sh
 #!/bin/bash
 for a  in  {1..10}
 do
  echo I LOVE DC
 done

  造数工具:  {起始..结束}    {3..27} = 制造连续的数字 3到27

[root@server0 /]# cat /root/for02.sh
 #!/bin/bash
 for  a  in  {1..10}
 do
  useradd nsd$a  &> /dev/null
  echo nsd$a创建成功
 done

####################################################
案例4:编写一个判断脚本
在 server0 上创建 /root/foo.sh 脚本
1)当运行/root/foo.sh redhat,输出为fedora
2)当运行/root/foo.sh fedora,输出为redhat
3)当没有任何参数或者参数不是 redhat 或者fedora时,
其错误输出产生以下信息: /root/foo.sh redhat|fedora

####################################################

案例5:编写一个批量添加用户脚本
在 server0 上创建 /root/batchusers 脚本
1)此脚本要求提供用户名列表文件作为参数
2)如果没有提供参数,此脚本应该给出提示
 Usage: /root/batchusers,退出并返回相应值
3)如果提供一个不存在的文件,此脚本应该给出提
示 Input file not found,退出并返回相应值
4)新用户的登录Shell为 /bin/false,无需设置密码
5)用户列表测试文件:
http://classroom/pub/materials/userlist
###################################################
















二222222222222222






教学环境介绍

– 格式:rht-vmctl 控制指令 虚拟机名

reset(还原)

真机上操作：
　]# rht-vmctl reset classroom　 //先重置资源服务器
　]# rht-vmctl reset server
　]# rht-vmctl reset desktop　　 //再重置练习虚拟机

####################################################
案例4:编写一个判断脚本
在 server0 上创建 /root/foo.sh 脚本
1)当运行/root/foo.sh redhat,输出为fedora
2)当运行/root/foo.sh fedora,输出为redhat
3)当没有任何参数或者参数不是 redhat 或者fedora时,
   其错误输出产生以下信息: /root/foo.sh redhat|fedora

[root@server0 ~]# vim /root/foo.sh    
 #!/bin/bash
 if [ $# -eq 0 ];then
  echo '/root/foo.sh redhat|fedora' >&2 #输出变成错误输出
  exit 38     #程序退出返回值
 elif [ $1 == redhat ];then
  echo fedora
 elif [ $1 == fedora ];then
  echo redhat 
 else
  echo '/root/foo.sh redhat|fedora' >&2 #输出变成错误输出
  exit 39     #程序退出返回值
 fi
 
[root@server0 ~]# /root/foo.sh tc  
[root@server0 ~]# echo  $?


####################################################

案例5:编写一个批量添加用户脚本
在 server0 上创建 /root/batchusers 脚本
1)此脚本要求提供用户名列表文件作为参数
2)如果没有提供参数,此脚本应该给出提示
  Usage: /root/batchusers,退出并返回相应值
3)如果提供一个不存在的文件,此脚本应该给出提
示 Input file not found,退出并返回相应值
4)新用户的登录Shell为 /bin/false,无需设置密码
5)用户列表测试文件:
[root@server0 ~]# vim /root/userlist 
duanwu
zhongqiu
zhsan
[root@server0 ~]# vim /root/batchusers
#!/bin/bash
if  [ $# -eq 0 ];then               #判断用户是否输入参数
 echo 'Usage: /root/batchusers' >&2
 exit 2
elif  [ -f $1 ];then      #判断用户输入参数,是否存在且为文件
 for a  in  $(cat  $1)
 do
  useradd  -s /bin/false $a  &> /dev/null
  echo  $a创建成功
 done
else
 echo  'Input file not found' >&2
 exit  3
fi
[root@server0 ~]# /root/batchusers  /root/userlist

###################################################
系统安全保护,SELinux安全机制
• Security-Enhanced Linux
– 美国NSA国家安全局主导开发,一套增强Linux系统安
全的强制访问控制体系
– 集成到Linux内核(2.6及以上)中运行
– RHEL7基于SELinux体系针对用户、进程、目录和文件
提供了预设的保护策略,以及管理工具

• SELinux的运行模式
– enforcing(强制)、permissive(宽松)
– disabled(彻底禁用)

 任何模式变成disabled(彻底禁用)模式,必须修改配置文件重启系统

• 切换运行模式
– 临时切换:setenforce 1|0
– 固定配置:/etc/selinux/config 文件
虚拟机server
[root@server0 ~]# getenforce     #查看当前SELinux状态
[root@server0 ~]# setenforce 0   #修改当前SELinux状态
[root@server0 ~]# getenforce 
[root@server0 ~]# vim /etc/selinux/config  #永久配置文件
   命令模式按大写的C,可以删除光标之后进入插入模式
 SELINUX=permissive
   
虚拟机desktop
[root@desktop0 ~]# getenforce 
[root@desktop0 ~]# setenforce 0
[root@desktop0 ~]# getenforce 
[root@desktop0 ~]# vim /etc/selinux/config 
 SELINUX=permissive
###################################################
配置用户环境

• 影响指定用户的 bash 解释环境
– ~/.bashrc,每次开启 bash 终端时生效

• 影响所有用户的 bash 解释环境
– /etc/bashrc,每次开启 bash 终端时生效

[root@server0 ~]# vim /root/.bashrc 
alias hello='echo hello'
[root@server0 ~]# vim /home/student/.bashrc
alias hi='echo hi'
[root@server0 ~]# vim /etc/bashrc 
alias tcc='echo dcc'
开启一个新的终端,再去测试(退出远程管理,在从新进行远程管理)
[root@server0 ~]# hello
[root@server0 ~]# hi       #执行失败
[root@server0 ~]# tcc

[root@server0 ~]# su - student
[student@server0 ~]$ hello     #执行失败
[student@server0 ~]$ hi
[student@server0 ~]$ tcc
[student@server0 ~]$ exit




真机上的操作:定义别名
[student@room9pc01 ~]$ vim /home/student/.bashrc 
   alias  gos='ssh -X root@172.25.0.11'
   alias  god='ssh -X root@172.25.0.10'

真机上新开一个终端,进行验证

##################################################
防火墙策略管理

一  虚拟机server搭建基本Web服务

Web服务:提供一个页面内容的服务

1.安装httpd软件包
[root@server0 ~]# yum -y install httpd
[root@server0 ~]# rpm -q httpd

2.重启httpd服务
[root@server0 ~]# systemctl restart httpd

3.本机通过浏览器进行测试:
[root@server0 ~]# firefox 172.25.0.11

4.在虚拟机server书写一个页面文件
      默认存放网页文件的路径: /var/www/html
      默认页面文件名称:index.html
[root@server0 ~]# vim /var/www/html/index.html
 <marquee><font  color=red><h1>NSD1903阳光明媚
   滚动          字体颜色  红色        标题字体
[root@server0 ~]# firefox 172.25.0.11

二  虚拟机server构建FTP服务器         
   FTP服务:文件传输服务
      默认FTP共享路径:/var/ftp

1.安装vsftpd软件包
[root@server0 ~]# yum -y install vsftpd

2.重启vsftpd服务
[root@server0 ~]# systemctl restart vsftpd

3.验证FTP服务:
[root@server0 ~]# firefox ftp://172.25.0.11

#################################################
防火墙策略
      作用:隔离

    硬件防火墙
    软件防火墙
    
firewalld服务基础

Linux的防火墙体系
 • 系统服务:firewalld
 • 管理工具:firewall-cmd、firewall-config


预设安全区域
• 根据所在的网络场所区分,预设保护规则集
– public:仅允许访问本机的sshd  ping  dhcpd服务
– trusted:允许任何访问
– block:阻塞任何来访请求(明确拒绝,客户端有接收回应)
– drop:丢弃任何来访的数据包(直接丢弃,客户端没有接收回应) 节省服务器资源


 数据包: 目标IP地址   源IP地址   数据

防火墙判定的规则:匹配及停止
1.查看请求数据包中源IP地址,然后查询防火墙所有区域,那个区域有该IP地址的规则,则进入该区域

2.进入默认区域public(由root指定)

###############################################
一  防火墙默认区域的修改
虚拟机server:
]# firewall-cmd --get-default-zone   #查看默认区域
虚拟机desktop:
]# ping  -c 2 172.25.0.11   #可以通信

虚拟机server:
]# firewall-cmd --set-default-zone=block   #修改默认区域
]# firewall-cmd --get-default-zone        #查看默认区域
虚拟机desktop:
]# ping -c 2 172.25.0.11   #不可以通信,有回应

虚拟机server:
]# firewall-cmd --set-default-zone=drop  #修改默认区域
]# firewall-cmd --get-default-zone      #查看默认区域
虚拟机desktop:
]# ping -c 2 172.25.0.11   #不可以通信,没有回应


二  默认区域public 仅允许访问本机的sshd  ping  dhcpd服务
虚拟机server:
]# firewall-cmd  --set-default-zone=public 
]# firewall-cmd  --get-default-zone 
虚拟机desktop:
]# ping -c 2 172.25.0.11   #可以通信

在区域中添加允许访问的服务或协议
             http:超文本传输协议
             https:安全超文本传输协议
             DNS:域名解析协议
             FTP:文件传输协议
             TFTP:简单文件传输协议
             telnet:远程管理协议
             pop3:邮件协议(用户收邮件协议)
             SMTP:邮件协议(用户发邮件协议)
             SNMP:简单的网络管理协议
虚拟机server:  
# firewall-cmd --zone=public --list-all  #查看区域规则
# firewall-cmd --zone=public --add-service=http #添加协议
# firewall-cmd --zone=public --list-all  #查看区域规则
虚拟机desktop
# firefox 172.25.0.11  #可以访问
# firefox ftp://172.25.0.11  #不可以访问

虚拟机server:
]# firewall-cmd --zone=public --add-service=ftp #添加协议
]# firewall-cmd --zone=public --list-all  #查看区域规则
虚拟机desktop
]# firefox ftp://172.25.0.11  #可以访问

####################################################
永久的防火墙规则  永久(permanent)
虚拟机server
]# firewall-cmd --reload    #重新加载所有防火墙策略
]# firewall-cmd --zone=public --list-all  #查看区域策略

]# firewall-cmd --permanent --zone=public --add-service=http        #永久添加策略

]# firewall-cmd --zone=public --list-all  #查看区域策略

]# firewall-cmd --reload   #重新加载所有防火墙策略
]# firewall-cmd --zone=public --list-all  #查看区域策略

####################################################
补充:
  单独拒绝虚拟机desktop访问虚拟机server所有请求
虚拟机server
]# firewall-cmd --zone=block --add-source=172.25.0.10
]# firewall-cmd --zone=block --list-all 

虚拟机desktop 访问测试 
]#  ping  172.25.0.11 #不可以访问
]#  firefox  172.25.0.11  #不可以访问
真机  访问测试
]#  ping  172.25.0.11 #可以访问
]#  firefox  172.25.0.11  #可以访问
####################################################
























































二333333333333


















教学环境介绍

– 格式:rht-vmctl 控制指令 虚拟机名

reset(还原)

真机上操作：
　]# rht-vmctl reset classroom　 //先重置资源服务器
　]# rht-vmctl reset server
　]# rht-vmctl reset desktop　　 //再重置练习虚拟机

####################################################
环境准备:
虚拟机server
]# firewall-cmd --set-default-zone=trusted  #允许所有访问

虚拟机desktop
]# firewall-cmd --set-default-zone=trusted  #允许所有访问

###################################################
在虚拟机server:划分一个3G的主分区
[root@server0 ~]# fdisk /dev/vdb

[root@server0 ~]# lsblk
[root@server0 ~]# ls /dev/vdb1

###################################################
iSCSI服务基础

iSCSI磁盘的工作模式(默认端口:3260)
• Internet SCSI,网际SCSI接口
– 一种基于C/S架构的虚拟磁盘技术
– 服务器提供磁盘空间,客户机连接并当成本地磁盘使用

• backstore,后端存储
– 对应到服务端提供实际存储空间的设备,需要起一个管理名称

• target,磁盘组(木质的箱子)
– 是客户端的访问目标,作为一个框架,由多个lun组成

• lun,逻辑单元(将后端存储放入磁盘组)
– 每一个lun需要关联到某一个后端存储设备,在客户端
会视为一块虚拟硬盘

   /dev/vdb1 (backstore,后端存储)
  
      大冰箱---->纸质的包装      木质的箱子

• ISCSI Qualified Name(iqn) 名称规范
– iqn.yyyy-mm.倒序域名:自定义标识
– 用来识别 target 磁盘组,也用来识别客户机身份

• 名称示例
– iqn.2016-02.com.example:server0
– iqn.2016-02.com.example:desktop0



服务端:虚拟机server 提供磁盘空间

一 所需软件包:targetcli(服务端软件)
[root@server0 ~]# yum -y install targetcli

二 运行targetcli进行配置
[root@server0 ~]# targetcli
   /> ls
 1)创建后端存储(backstore,后端存储)
   /> backstores/block  create  name=nsd dev=/dev/vdb1
   /> ls
 2)创建target,磁盘组(木质的箱子)
[root@server0 ~]# targetcli
   /> iscsi/ create iqn.2019-04.com.example:server0
   /> ls
 3)配置lun,关联(将后端存储放入磁盘组)
   /> iscsi/iqn.2019-04.com.example:server0/tpg1/luns     create /backstores/block/nsd 

   /> ls

  4)配置ACL访问控制,设置客户端声称的名字
/> iscsi/iqn.2019-04.com.example:server0/tpg1/acls create iqn.2019-04.com.example:desktop0

   /> ls
  5)设置本机提供服务端的IP地址与端口
 /> iscsi/iqn.2019-04.com.example:server0/tpg1/portals create   172.25.0.11
   /> ls

   /> exit   #保存并退出

三  重启服务端服务
[root@server0 ~]# systemctl restart target
[root@server0 ~]# systemctl enable target  #设置开机自启动
ln -s '/usr/lib/systemd/system/target.service' '/etc/systemd/system/multi-user.target.wants/target.service'

#提示:会制作一个快捷方式,不是报错

###################################################

客户端:虚拟机desktop 访问使用服务端提供磁盘空间
一 安装客户端软件
• 所需软件包:iscsi-initiator-utils
 Yum仓库软件包的补全:  1.Yum必须要有缓存  2.当前系统没有安装

 Yum必须要有缓存 :yum  repolist  可以生成缓存

[root@desktop0 ~]# rpm -q  iscsi-initiator-utils 
iscsi-initiator-utils-6.2.0.873-21.el7.x86_64

[root@desktop0 ~]# yum -y install  iscs(tab)

二 修改配置文件,指定客户端生成的命令
[root@desktop0 ~]# vim /etc/iscsi/initiatorname.iscsi 
InitiatorName=iqn.2019-04.com.example:desktop0

三 重启iscsid服务,用于识别客户端声称的名字
[root@desktop0 ~]# systemctl restart iscsid
  Warning: Unit file of iscsid.service changed on  
  disk, 'systemctl daemon-reload' recommended.
[root@desktop0 ~]# systemctl daemon-reload
[root@desktop0 ~]# systemctl restart iscsid

四  运行iscsiadm命令,发现服务端共享存储
  Linux查看命令帮助的方法 :  man  iscsiadm 
   全文查找/example   按n项下跳转匹配,看到EXAMPLES

   Ctrl    - ：减小字体
   Ctrl   Shift   + ：变大字体

]# iscsiadm --mode discoverydb --type sendtargets --portal 172.25.0.11 --discover

屏幕显示信息:
172.25.0.11:3260,1 iqn.2019-04.com.example:server0

五 重启iscsi服务(客户端服务),加载服务端共享存储

[root@desktop0 ~]# systemctl restart iscsi
[root@desktop0 ~]# systemctl enable iscsi
[root@desktop0 ~]# lsblk 

#################################################
数据库基本管理

  什么是数据库:存放数据的仓库

  数据库的结构: 在数据库里,有很多的库,在每一个库中有很多的表格

一 部署mariadb数据库服务器(默认的端口 3306)
   mariadb-server:提供服务端有关的系统程序

[root@server0 ~]# yum -y install mariadb-server
[root@server0 ~]# systemctl restart mariadb

二 数据库的基本操作
[root@server0 ~]# mysql        #进入数据库,默认无需密码
MariaDB [(none)]> show  databases;       #查看所有数据库
MariaDB [(none)]> create  database nsd;  #创建库

MariaDB [(none)]> show  databases;    #查看所有数据库
MariaDB [(none)]> drop  database  nsd;    #删除nsd库

MariaDB [(none)]> show databases;     #查看所有数据库

MariaDB [(none)]> create  database nsd1903;  #创建库
MariaDB [(none)]> show databases;  

MariaDB [(none)]> exit               #15:05

三  为数据库管理员设置密码

   数据库管理员为root,数据库所有用户信息,由mysql库中user表
   系统管理员为root,系统所有用户信息,由/etc/passwd

MariaDB [(none)]> exit
Bye
[root@server0 ~]#
 
• 为数据库账号修改密码
– mysqladmin [-u用户名] [-p[旧密码]] password  '新密码'

[root@server0 ~]# mysqladmin -u root  password '123'
[root@server0 ~]# mysql -u root -p    #交互式
Enter password: 

[root@server0 ~]# mysql -u root -p123  #非交互式

四  表格操作: 表记录  表字段

         编号      姓名      性别        联系方式         地址   
     1       dc     女           123              东村
     2       tc     女           456              西村
     3       lisi   男           789              北庄

   四大操作:  增 insert  删 delete   改 update  查 select

[root@server0 ~]# mysql -u root -p123
MariaDB [(none)]> show databases;
MariaDB [test]> use mysql;     #进入mysql库
MariaDB [mysql]> show  tables;  #查看当前库中有那些表格
MariaDB [mysql]> desc  user;   #查看表结构

数据库的导入操作
• 导入/恢复到数据库

]# wget http://classroom.example.com/pub/materials/users.sql

]# ls
导入数据到指定数据库:
]# mysql -u root -p123 nsd1903 < /root/users.sql 
]# mysql -u root -p123
> use nsd1903;
> show tables;                   
  +-------------------+
 | Tables_in_nsd1903 |  
  +-------------------+ 
 | base              |               
 | location          |
  +-------------------+

###################################################
表格的查询:
  select 表字段   from  表名;

]# mysql -u root -p123
> use nsd1903;
> select * from base;

> use mysql;
> select  *  from nsd1903.base;
> use nsd1903;

> select * from location;
> select name from base;
> select id,name from base;

有条件查询:
  查找base中密码为123的人?
> use nsd1903;
> select * from base;
> select * from base where password='123';

> select * from base where password='456';

> select * from base where name='tom';

> select id,name from base where name='tom';
> select name,password from base where name='tom';


• 禁止网络进行连接,只服务于本机
[root@server0 ~]# vim /etc/my.cnf  #主配置文件
[mysqld]
skip-networking   //手写,跳过网络监听
.. ..
[root@server0 ~]# systemctl restart mariadb

###############################################
数据库授权

– 除了 root 用户,此nsd1903数据库,只能被用户lisi查询,
此用户的密码为123

  不需要创建系统用户lisi

– GRANT  权限列表   ON  数据库名.表名   TO  用户名@客户机地址 IDENTIFIED BY '密码';

  grant select  on  nsd1903.*  to  lisi@localhost  identified by '123';

   当lisi从本地localhost进行登录,输入密码123,将会获得nsd1903库所有表的查询权限.
[root@server0 ~]# mysql -u root -p123

> grant select on nsd1903.* to lisi@localhost identified by '123';

> select user,host,password from mysql.user;

[root@server0 ~]# mysql -u lisi -p123
MariaDB [(none)]> exit
Bye

#################################################
案例4:使用数据库查询


2. 在系统 server0 上使用数据库 nsd1903,并使用相
应的 SQL 查询以回答下列问题:
  1)base表密码是 solicitous 的人的名字?
[root@server0 ~]# mysql -u root -p123
> use nsd1903;
> select * from base;
> select * from base where password='solicitous';

  2)有多少人的姓名是 Barbara 同时居住在 Sunnyvale?
> select * from base,location        
  where  base.name='Barbara'  and 
  location.city='Sunnyvale'   and  base.id=location.id; 

> select count(*) from base,location         
  where base.name='Barbara' and 
  location.city='Sunnyvale' and base.id=location.id; 

> insert base values('6','Barbara','789'); #插入表记录
> select * from base;

> insert location values('6','Sunnyvale'); #插入表记录
> select * from location;


1. 禁止空密码root用户访问 mariadb数据库
> use mysql;
> select user,host,password from user;

> select user,host,password from user where password='';
> delete from user where password='';

> select user,host,password from user;

> flush privileges;  #刷新user所有记录


[root@server0 ~]# mysql -u root -h server0.example.com
登录失败

####################################################






























二4444444444444





教学环境介绍

– 格式:rht-vmctl 控制指令 虚拟机名

reset(还原)

真机上操作：
　]# rht-vmctl reset classroom　 //先重置资源服务器
　]# rht-vmctl reset server
　]# rht-vmctl reset desktop　　 //再重置练习虚拟机

####################################################
环境准备:
虚拟机server
]# firewall-cmd --set-default-zone=trusted  #允许所有访问

虚拟机desktop
]# firewall-cmd --set-default-zone=trusted  #允许所有访问

####################################################
配置NFS共享

NFS共享概述
• Network File System,网络文件系统
– 用途:为客户机提供共享使用的文件夹
– 协议:NFS(TCP/UDP 2049)、RPC(TCP/UDP 111)

• 所需软件包:nfs-utils
• 系统服务:nfs-server

虚拟机server:
1.安装软件包nfs-utils
[root@serverq0 ~]# rpm -q nfs-utils
nfs-utils-1.3.0-0.el7.x86_64

2.创建共享目录
[root@server0 ~]# mkdir /public
[root@server0 ~]# echo 123 > /public/1.txt
[root@server0 ~]# ls /public/

3.修改配置文件/etc/exports,指定共享的目录
[root@server0 ~]# vim  /etc/exports
[root@server0 ~]# man  exports
– 共享的文件夹路径    客户机地址(权限)    客户机地址(权限) .. ..

  /public     *(ro)


[root@server0 ~]# systemctl restart nfs-server
[root@server0 ~]# systemctl enable nfs-server

#################################################
客户端虚拟机desktop 
1.查看服务端共享路径
[root@desktop0 ~]# showmount -e 172.25.0.11
Export list for 172.25.0.11:
/public  *
[root@desktop0 ~]# 

2.挂载访问
[root@desktop0 ~]# mkdir /mnt/nfs
[root@desktop0 ~]# mount 172.25.0.11:/public  /mnt/nfs/
[root@desktop0 ~]# df -h
[root@desktop0 ~]# ls /mnt/nfs

3.开机自动挂载
  _netdev:声明为网络设备
              开机启动Linux系统时,首先具备网络参数后,再进行挂载本设备

[root@desktop0 ~]# vim /etc/fstab
  设备路径    挂载点    类型     参数    备份标记   检测顺序
172.25.0.11:/public  /mnt/nfs  nfs  defaults,_netdev 0 0

[root@desktop0 ~]# umount /mnt/nfs/
[root@desktop0 ~]# df -h
[root@desktop0 ~]# mount -a
[root@desktop0 ~]# df -h
#####################################################

虚拟机server:
   1.利用NFS服务发布/nsd共享目录
[root@server0 ~]# mkdir /nsd
[root@server0 ~]# echo 123 > /nsd/a.txt
[root@server0 ~]# ls /nsd/
   2.允许所有客户端进行只读访问
[root@server0 ~]# cat /etc/exports
/public   *(ro)
/nsd   *(ro)

虚拟机desktop:
   1.完成开机自动挂载到本机/mnt/test目录
 172.25.0.11:/nsd  /mnt/test nfs defaults,_netdev 0 0

[root@desktop0 ~]# df  -ah  #显示当前系统,所有正在挂载信息
####################################################
HTTP服务基础

一 构建基本Web主机
Web通信基本概念
• 基于 B/S(Browser/Server)架构的网页服务
– 服务端提供网页
– 浏览器下载并显示网页
• Hyper Text Markup Language(html),超文本标记语言
• Hyper Text Transfer Protocol(http),超文本传输协议 默认端口 80



虚拟机server:
]# yum -y install httpd
]# systemctl restart httpd
]# echo '<h1>NSD1903' > /var/www/html/index.html

虚拟机desktop
]# firefox 172.25.0.11

####################################################
web服务器的软件
   httpd(Apache软件基金会)

• 提供的默认配置
– Listen:监听地址:端口(80)
– ServerName:本站点注册的DNS名称(空缺)
– DocumentRoot:网页根目录(/var/www/html)

  DNS服务器:虚拟机classroom提供域名解析
            server0.example.com
            www0.example.com
            webapp0.example.com
测试解析结果:
[root@server0 ~]# nslookup server0.example.com
[root@server0 ~]# nslookup www0.example.com
[root@server0 ~]# nslookup webapp0.example.com

##################################################
DocumentRoot:网页文件根目录(/var/www/html)   

虚拟机server
]# mkdir /var/www/myweb
]# echo '<h1>wo shi myweb' > /var/www/myweb/index.html
]# ls /var/www/myweb/
]# vim /etc/httpd/conf/httpd.conf 

 DocumentRoot "/var/www/myweb"

]# systemctl restart httpd

虚拟机desktop
]# firefox 172.25.0.11   #测试访问结果
#####################################################
网络路径与实际路径

客户端访问:
 firefox 172.25.0.11:80-->服务端  httpd-->DocumentRoot /var/www/myweb-->index.html


客户端 : firefox 172.25.0.11/abc
服务端实际路径: : /var/www/myweb/abc/index.html

客户端 : firefox 172.25.0.11/var/www/myweb/abc
服务端实际路径: /var/www/myweb/var/www/myweb/abc

虚拟机server
]# mkdir /var/www/myweb/abc
]# echo '<h1>wo shi abc' > /var/www/myweb/abc/index.html

虚拟机desktop
]# firefox 172.25.0.11      #测试访问结果
]# firefox 172.25.0.11/abc  #测试访问结果

##################################################
 客户端访问Web: 直接输入IP地址 = 服务端 DocumentRoot

###################################################
配置文件调用
• 配置文件路径
– /etc/httpd/conf/httpd.conf  #主配置文件
– /etc/httpd/conf.d/*.conf    #调用配置文件

###################################################
虚拟Web主机

虚拟主机的含义及类型
• 虚拟Web主机
– 由同一台服务器提供多个不同的Web站点

• 区分方式
 – 基于域名的虚拟主机
 – 基于端口的虚拟主机
 – 基于IP地址的虚拟主机
 
            server0.example.com
            www0.example.com
            webapp0.example.com

<VirtualHost  IP地址:端口>
  ServerName  此站点的DNS名称
  DocumentRoot  此站点的网页根目录
</VirtualHost>

]# vim /etc/httpd/conf.d/nsd01.conf
 <VirtualHost  *:80> #本机所有IP地址的80端口启用虚拟Web主机
   ServerName  server0.example.com  #设置网站访问的域名
   DocumentRoot  /var/www/qq        #设置网页文件根目录
 </VirtualHost>

 <VirtualHost  *:80>
   ServerName  www0.example.com
   DocumentRoot  /var/www/baidu
 </VirtualHost>
]# mkdir /var/www/qq  /var/www/baidu        
]# echo '<h1>QQ' > /var/www/qq/index.html
]# echo '<h1>百度' > /var/www/baidu/index.html

]# systemctl  restart  httpd

###############################################
 DocumentRoot 路径尽量放在/var/www , SELinux策略

###############################################
虚拟Web主机优先级,由上到下优先级递减
一旦使用了虚拟Web主机,所有的页面都必须使用虚拟Web主机来呈现

<VirtualHost  *:80>
  ServerName www0.example.com
  DocumentRoot  /var/www/baidu
</VirtualHost>
<VirtualHost  *:80>
  ServerName server0.example.com
  DocumentRoot  /var/www/qq
</VirtualHost>
<VirtualHost  *:80>
  ServerName  webapp0.example.com
  DocumentRoot  /var/www/myweb
</VirtualHost>
####################################################
补充: Samba共享服务 (Windows平台与Linux平台   跨平台的共享)

      协议:smb(沟通验证身份)   cifs(存储或传输数据)

默认情况下必须通用户验证,才可以访问
专门用于Samba共享服务,验证的用户:Samba共享帐号
1.必须要有相应的本地用户对应           
2.采用独立的密码设置             
                                     

虚拟机server:     
1.安装软件包samba
[root@server0 ~]# yum -y install samba

2.创建Samba共享帐号
]# useradd -s /sbin/nologin harry
]# pdbedit -a harry      #将用户添加为Samba共享帐号
new password:
retype new password:

   pdbedit -x 用户名     #删除Samba共享帐号
   pdbedit -L  #查看当前系统,所有的Samba共享帐号

3.修改配置文件
[root@server0 ~]# vim /etc/samba/smb.conf 
在命令模式下,输入G(大写)到全文的最后一行

[nsd]                #设置共享名
path = /common       #设置实际共享的目录

[root@server0 ~]# mkdir /common
[root@server0 ~]# echo 123 > /common/123.txt
[root@server0 ~]# ls /common/

4.重启smb服务
[root@server0 ~]# systemctl restart smb

5.修改SELinux策略,布尔值策略(功能的开关)
 samba_export_all_ro : Samba服务只读共享功能

]# getenforce   #查看SELinux状态
]# getsebool -a | grep samba   #查看SELinux所有布尔值

]# setsebool samba_export_all_ro  on  #修改SELinux布尔值

]# getsebool -a | grep samba
]# getenforce 


虚拟机desktop:
1.安装软件包,支持Samba共享的挂载,让本机识别cifs协议
]# yum -y install cifs-utils
]# rpm -q  cifs-utils

2.挂载访问Samba共享
]# mkdir /mnt/smb
]# mount -o user=harry,pass=123  //172.25.0.11/nsd   /mnt/smb/

格式:
mount -o user=用户名,pass=密码  //服务端IP地址/共享名   挂载点

]# df -h

3.开机自动挂载,书写/etc/fstab      

//172.25.0.11/nsd /mnt/smb  cifs defaults,_netdev,user=harry,pass=123 0 0

[root@desktop0 ~]# umount /mnt/smb/
[root@desktop0 ~]# mount -a
[root@desktop0 ~]# df -h

##############################################





















































二5555555555555555


















教学环境介绍  
– 格式:rht-vmctl   控制指令    虚拟机名

真机上操作：
　]# rht-vmctl reset classroom　 //先重置资源服务器
　]# rht-vmctl reset server
　]# rht-vmctl reset desktop　　 //再重置练习虚拟机
####################################################
环境准备:
虚拟机server
]# firewall-cmd --set-default-zone=trusted  #允许所有访问

虚拟机desktop
]# firewall-cmd --set-default-zone=trusted  #允许所有访问

####################################################
<VirtualHost  *:80>
  ServerName   www0.example.com
  DocumentRoot  /var/www/web01
</VirtualHost>
<VirtualHost  *:80>
  ServerName   server0.example.com
  DocumentRoot  /var/www/web02
</VirtualHost>
<VirtualHost  *:80>
  ServerName   webapp0.example.com
  DocumentRoot  /var/www/web03
</VirtualHost>
####################################################
- 实现客户端访问www0.example.com网页内容为  大圣又归来
- 实现客户端访问server0.example.com网页内容为 大圣归来
- 实现客户端访问webapp0.example.com网页内容为 大圣累了

####################################################
网页内容访问

客户机地址限制
• 使用 <Directory> 配置区段
– 每个文件夹自动继承其父目录的ACL访问权限
– 除非针对子目录有明确设置

	<Directory  目录的绝对路径>
	  .. ..
	 Require all denied|granted
	 Require ip IP或网段地址 .. ..
	</Directory>


	<Directory  /var/www/web01>
	 Require all denied   #拒绝所有人访问
	</Directory>

	<Directory  /var/www/web02>
	 Require all granted   #允许所有人访问
	</Directory>

	<Directory  /var/www/web03>
	 Require ip 172.25.0.11   #仅允许172.25.0.11访问
	</Directory>

##############################################
	<Directory  /var/www/web01>
	 Require all denied   #拒绝所有人访问
	</Directory>
	<Directory  /var/www/web01/abc>
	 Require all granted   #允许所有人访问
	</Directory>

   /var/www/web01/abc/index.html   #允许

   /var/www/web01/nsd/index.html   #拒绝

############################################
案例1:配置网页内容访问
在 Web 网站 http://server0.example.com 的          
DocumentRoot 目录下创建一个名为 private 的子目录
要求如下:
1.虚拟机server,查看DocumentRoot 目录路径
]# cat /etc/httpd/conf.d/nsd01.conf 

]# mkdir /var/www/web02/private

]# echo '<h1>wo shi private' > /var/www/web02/private/index.html

2.虚拟机desktop访问测试
]# firefox  server0.example.com/private

3.从虚拟机server0上,任何人都可以浏览 private的内容,
但是从其他系统不能访问这个目录的内容
[root@server0 ~]# cat /etc/httpd/conf.d/nsd02.conf
  <Directory  /var/www/web02/private>
	Require  ip  172.25.0.11   #仅允许172.25.0.11访问
  </Directory>

[root@server0 ~]# systemctl restart httpd

在虚拟机desktop测试: firefox server0.example.com/private
Forbidden

You don't have permission to access /private/ on this server.

####################################################
案例2:使用自定Web根目录
调整 Web 站点 http://server0.example.com 的网页目录,要求如下:
1)新建目录 /webroot,作为此站点新的网页目录
]# mkdir /webroot
]# echo '<h1>wo shi webroot' > /webroot/index.html
]# vim /etc/httpd/conf.d/nsd01.conf 
 ......
<VirtualHost *:80>
  ServerName server0.example.com
  DocumentRoot /webroot
</Virtualhost>
 ......
]# vim /etc/httpd/conf.d/nsd02.conf 
.......
<Directory /webroot>
    Require all granted    #允许所有人进行访问
</Directory>
[root@server0 ~]# systemctl restart httpd

2)修改SELinux策略,安全上下文(标签)    

[root@server0 ~]# ls -Zd /var/www/  #查看目录SELinux标签值
[root@server0 ~]# ls -Zd /webroot/

• 方式1:参照标准目录,重设新目录的属性
– chcon [-R] --reference=模板目录 新目录

[root@server0 ~]# chcon -R --reference=/var/www /webroot
[root@server0 ~]# ls -Zd /webroot

[root@server0 ~]# firefox server0.example.com

#####################################################
部署动态网站

 静态网站:
  • 服务端的原始网页 = 浏览器访问到的网页
    – 由Web服务软件处理所有请求
    – 文本(txt/html)、图片(jpg/png)等静态资源

 动态网站:
  • 服务端的原始网页 ≠ 浏览器访问到的网页
    – 由Web服务软件接受请求,动态程序转后端模块处理
  – PHP网页、Python网页、JSP网页......


部署Python动态页面,为站点 webapp0.example.com
虚拟机Server:
1.下载Python页面文件
[root@server0 ~]# cat /etc/httpd/conf.d/nsd01.conf 

[root@server0 ~]# cd /var/www/web03/
[root@server0 web03]# wget http://classroom.example.com/pub/materials/webinfo.wsgi

[root@server0 web03]# ls 

2.实现客户端方便访问,设置页面跳转(页面别名  地址重写)

  webapp0.example.com ---> webinfo.wsgi

  Alias  网络路径    实际路径
   网络路径为  /  : 用户直接输入域名
    当客户端访问  网络路径 ,将  实际路径 页面文件呈现

[root@server0 ~]# vim /etc/httpd/conf.d/nsd01.conf 

<VirtualHost *:80>
  ServerName webapp0.example.com
  DocumentRoot /var/www/web03
  Alias   /    /var/www/web03/webinfo.wsgi
   当用户直接访问网页文件根目录时,将webinfo.wsgi页面呈现
</Virtualhost>
[root@server0 ~]# systemctl restart httpd

3.虚拟机Server,安装mod_wsgi软件进行Pyhton页面代码的翻译
[root@server0 ~]# yum -y install mod_wsgi

4.修改配置文件,添加翻译配置
[root@server0 ~]# vim  /etc/httpd/conf.d/nsd01.conf 
<VirtualHost *:80>
  ServerName  webapp0.example.com
  DocumentRoot /var/www/web03
  WsgiScriptAlias   /    /var/www/web03/webinfo.wsgi 
</Virtualhost>

[root@server0 ~]# systemctl restart httpd

访问测试:firefox webapp0.example.com
页面内容显示 UNIX时间戳:
            从1970-1-1 0:0:0到现在时间所有经历的秒数

5.此虚拟主机侦听在端口8909
[root@server0 ~]# vim /etc/httpd/conf.d/nsd01.conf 
Listen 8909           #httpd监听8909端口
<VirtualHost *:8909>  #设置虚拟web主机的端口     15:15上课
  ServerName webapp0.example.com
  DocumentRoot /var/www/web03
  WsgiScriptAlias   /    /var/www/web03/webinfo.wsgi  
</Virtualhost>

6.修改SELinux策略,非默认端口开放的策略
]# semanage port -l | grep http
]# semanage port -a -t http_port_t -p tcp 8909
      -a:添加    -t:类型    -p:协议
]# semanage port -l | grep http

]# systemctl restart httpd
]# firefox webapp0.example.com:8909
##################################################
端口优先级最高,然后虚拟Web主机由上到下进行匹配

#################################################
安全Web服务

PKI公钥基础设施
• Public Key Infrastructure,公钥基础设施
– 公钥:主要用来加密数据
– 私钥:主要用来解密数据(与相应的公钥匹配)
– 数字证书:证明拥有者的合法性/权威性(单位名称、
有效期、公钥、颁发机构及签名、......)
– Certificate Authority,数字证书授权中心:负责证书
的申请/审核/颁发/鉴定/撤销等管理工作

虚拟机server部署安全的Web服务器       
1.部署网站证书(营业执照)
]# cd /etc/pki/tls/certs/
]# wget http://classroom.example.com/pub/tls/certs/server0.crt

]# ls

2.部署根证书(工商局的信息)
]# cd /etc/pki/tls/certs/
]# wget http://classroom.example.com/pub/example-ca.crt

]# ls

3.部署用于解密数据的秘钥
]# cd /etc/pki/tls/private/
]# wget http://classroom.example.com/pub/tls/private/server0.key

]# ls 

4.安装mod_ssl软件,实现加密Web传输
[root@server0 /]# yum -y install mod_ssl
[root@server0 /]# ls /etc/httpd/conf.d/

5.修改配置文件/etc/httpd/conf.d/ssl.conf
[root@server0 /]# vim /etc/httpd/conf.d/ssl.conf
 vim末行模式   :set  nu   开启行号功能

 59 DocumentRoot "/var/www/web01"
 60 ServerName www0.example.com:443
#指定网站证书
100 SSLCertificateFile /etc/pki/tls/certs/server0.crt

#指定秘钥
107 SSLCertificateKeyFile /etc/pki/tls/private/server0.key

#指定根证书
122 SSLCACertificateFile /etc/pki/tls/certs/example-ca.crt
[root@server0 /]# systemctl restart httpd
最后测试:
[root@server0 /]# firefox https://www0.example.com



















二66666666666666666666










教学环境介绍  
– 格式:rht-vmctl   控制指令    虚拟机名

真机上操作：
　]# rht-vmctl reset classroom　 //先重置资源服务器
　]# rht-vmctl reset server
　]# rht-vmctl reset desktop　　 //再重置练习虚拟机
####################################################
环境准备:
虚拟机server
]# firewall-cmd --set-default-zone=trusted  #允许所有访问

虚拟机desktop
]# firewall-cmd --set-default-zone=trusted  #允许所有访问

###################################################
基础邮件服务          

电子邮件通信
• 电子邮件服务器的基本功能
– 为用户提供电子邮箱存储空间(用户名@邮件域名)
– 处理用户发出的邮件 —— 传递给收件服务器
– 处理用户收到的邮件 —— 投递到邮箱


快速部署postfix邮件服务器
• 装包、配置、起服务
– 默认的标准配置即可为本机提供发/收邮件服务
– 若有必要,可扩大服务范围(邮件域)

DNS服务器:虚拟机classroom
         
         yg@server0.example.com
         xln@server0.example.com

虚拟机server:
1.安装软件postfix,提供邮件功能的软件
[root@server0 ~]# rpm -q postfixpostfix-2.10.1-6.el7.x86_64
[root@server0 ~]# 
                                                      
2. 修改配置文件/etc/postfix/main.cf
vim末行模式  :set  nu

99 myorigin = server0.example.com  #默认补全邮箱帐号后缀
116 inet_interfaces = all     #本机所有网卡都提供邮件服务
164 mydestination =  server0.example.com 
                                                              #判断为本域邮件依据

       收件人:xln@server0.example.com

3.重启postfix邮件服务
[root@server0 ~]# systemctl restart postfix
使用mail命令发信/收信
– mail -s  '邮件标题'    -r  发件人    收件人[@收件域]...

• mail 收信操作
– mail [-u 用户名]

[root@server0 ~]# useradd yg
[root@server0 ~]# useradd xln

[root@server0 ~]# mail -s 'test01' -r yg  xln
haha xixi hehe lele 
.                          #当只有一个点时,提交并发送邮件
EOT
[root@server0 ~]# echo dc | mail -s 'test02' -r yg  xln

[root@server0 ~]# mail -u xln
Heirloom Mail version 12.5 7/5/10.  Type ? for help.
"/var/mail/xln": 2 messages 2 new
>N  1 yg@server0.example.c  Thu Apr 18 10:31  18/588   

> 1     #输入邮件的编号1,查看邮件内容
####################################################
准备交换分区

交换空间(虚拟内存):缓解内存不足

mkswap  swapon  swapoff  swapon -s     swapon -a


parted分区工具(划分GPT分区模式)

   GPT分区模式: 128个主分区,最大空间18EB


[root@server0 ~]# parted /dev/vdb 
(parted) mktable  gpt      #初始化磁盘,不能重复执行
(parted) mkpart            #划分新的分区
分区名字?                                 #随便写
文件系统类型？[ext2]?  xfs    #随便写不起实际作用
起始点？ 0                       
结束点？ 2G   
 忽略/Ignore/放弃/Cancel? Ignore 
(parted) print 
(parted) unit GB     #显示单位
                                                  (parted) print 
(parted) quit
(parted) rm          #删除分区        
[root@server0 ~]# lsblk 
###################################################
配置IPv6地址

• IPv4 地址表示
– 32个二进制位,点 分隔的十进制数

• IPv6 地址表示
– 128个二进制位, 利用冒号分隔 8 部分,最终每一部分由16进制数标识
– 每段内连续的前置 0 可省略、连续的多个 : 可简化为 ::
– 例如: 2003:ac18:0000:0000:0000:0000:0000:0305
      2003:ac18::305


为虚拟机server:配置IPv6地址2003:ac18::305/64

1.利用nmcli命令查看网卡名称
[root@server0 ~]# nmcli connection show
名称         
System eth0

2.修改地址                                                            
]# nmcli connection modify 'System eth0' 
   ipv6.method manual ipv6.addresses 2003:ac18::305/64  
   connection.autoconnect yes

]# nmcli connection 修改  '识别的网卡名称' 
   ipv6.方法 手工配置 ipv6.地址 2003:ac18::305/64  
     每次开机自动启用

3.激活配置
[root@server0 ~]# nmcli connection up 'S(tab)'
[root@server0 ~]# ifconfig | less
  inet6 2003:ac18::305  prefixlen 64 

[root@server0 ~]# ping6 2003:ac18::305
##################################################

配置聚合连接(链路聚合)

• team,聚合连接(也称为链路聚合)
– 由多块网卡(team-slave)一起组建而成的虚拟网卡,即"组队"

– 作用1:热备份(activebackup)连接冗余


                eth1        eth2
                   
                               虚拟网卡 team0  192.168.1.1

虚拟机配置链路聚合:
1.创建虚拟网卡team0 ,参考 man teamd.conf 全文搜索/example

]# nmcli connection add type team      
 con-name team0 ifname  team0 autoconnect yes           
 config   '{"runner": {"name": "activebackup"}}'

]# nmcli connection 添加  类型  team(组队)
      配置文件名  team0  网卡命名为 team0  每次开机自动启用
      配置  链路聚合以activebackup(热备)工作的方式

]# ifconfig     #查看team0网卡的生成
 
如果有敲错,请删除从新创建team0
]# nmcli connection delete team0  

2.添加成员
]# nmcli connection add type team-slave 
 con-name team0-1 ifname eth1 master team0 

]# nmcli connection add type team-slave 
 con-name team0-2 ifname eth2 master team0

]# nmcli connection 添加   类型   组队-成员 
 配置文件名 team0-1  网卡设备名   eth1   主设备为 team0 

]# ls /etc/sysconfig/network-scripts/  #查看生成的配置文件

如果有敲错,请删除从新创建team0
]# nmcli connection delete team0-1  (生成配置文件名)
]# nmcli connection delete team0-2  (生成配置文件名)


3.配置IP地址,再激活
]# nmcli connection modify team0      
   ipv4.method manual ipv4.addresses 192.168.1.1/24 
   connection.autoconnect yes

]# nmcli connection up team0    #激活team0

]# ifconfig team0 | head -2    #查看team0的IP地址信息

]# teamdctl team0 state      #查看team0信息

]# ifconfig eth2 down        #将eth2网卡禁用
]# teamdctl team0 state      #查看team0信息

]# ifconfig eth2 up          #将eth2网卡启用










三111111111111111111



新教学环境的搭建

一 构建两台虚拟机
真机上运行:
[student@room9pc01 ~]$ clone-vm7 
Enter VM number: 8
Creating Virtual Machine disk image......	[OK]
Defining new virtual machine......		[OK]

[student@room9pc01 ~]$ clone-vm7 
Enter VM number: 9
Creating Virtual Machine disk image......	[OK]
Defining new virtual machine......		[OK]


虚拟机    用户为root   密码为123456

###################################################
真机管理虚拟机
  1.直接管理虚拟机,无需IP地址(将"虚拟系统管理软件"关闭)
[student@room9pc01 ~]$ virsh console  A
    退出: Ctrl + ]

[student@room9pc01 ~]$ virsh console  B
    退出: Ctrl + ]

  2.配置IP地址:                                               
     虚拟机A
        1.为eth0配置IP地址:192.168.4.7/24
        2.配置主机名:svr7.tedu.cn
     虚拟机B
        1.为eth0配置IP地址:192.168.4.207/24
        2.配置主机名:pc207.tedu.cn

[root@localhost /]# echo pc207.tedu.cn > /etc/hostname
[root@localhost /]# cat /etc/hostname
pc207.tedu.cn
[root@localhost /]# hostname
localhost.localdomain
[root@localhost /]# hostname pc207.tedu.cn

####################################################
[root@svr7 ~]# setip
Network name(eth0/eth1/eth2/eth3):eth0
Set IP(IP/24):192.168.4.7/24
Set Gateway(default none):


[root@svr7 ~]# ifconfig | head -2
eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 192.168.4.7  netmask 255.255.255.0  broadcast 192.168.4.255
[root@svr7 ~]# 

###################################################
真机设置别名
[student@room9pc01 ~]$ vim /home/student/.bashrc 
 alias goa='ssh -X root@192.168.4.7'
 alias gob='ssh -X root@192.168.4.207'

[student@room9pc01 ~]$ exit

新开一个终端,验证goa与gob

##################################################
虚拟机查看文件内容
[root@svr7 ~]# cat /etc/motd 

###################################################
为虚拟机A与虚拟机B构建Yum仓库

服务端:真机上构建ftp服务，共享光盘所有内容
1.安装vsftpd软件包                                          
]$ rpm -q vsftpd
vsftpd-3.0.2-22.el7.x86_64
]$ systemctl status  vsftpd  #查看服务状态

2.创建在/var/ftp/centos-1804      
 FTP服务默认共享:/var/ftp/
]$ ls /var/ftp/
]$ ls /var/ftp/centos-1804/
]$ firefox ftp://192.168.4.254/centos-1804/

3.开机自动挂载:
]$ vim /etc/fstab
/var/lib/libvirt/images/iso/CentOS7-1804.iso  /var/ftp/centos-1804 iso9660 defaults 0 0


客户端:虚拟机A与虚拟机B /etc/yum.repos.d/*.repo
[root@svr7 ~]# cat /etc/yum.repos.d/local.repo 
[local_repo]
name=CentOS-$releasever - Base
baseurl=ftp://192.168.4.254/centos-1804
enabled=1
gpgcheck=0
[root@svr7 ~]# yum -y install httpd

[root@pc207 ~]# cat /etc/yum.repos.d/local.repo 
[local_repo]
name=CentOS-$releasever - Base
baseurl=ftp://192.168.4.254/centos-1804
enabled=1
gpgcheck=0
[root@pc207 ~]# yum -y install httpd

###################################################

##################################################
补充:解决远程管理student用户虚拟机关闭问题
[student@room9pc01 ~]$ vim /home/student/.bash_logout 
里面的内容删除:/var/lib/libvirt/images/virt
 
####################################################
     虚拟机C
        1.为eth0配置IP地址:192.168.4.10/24
        2.配置主机名:C.tedu.cn
        3.使用真机FTP构建Yum仓库

     虚拟机D
        1.为eth0配置IP地址:192.168.4.20/24
        2.配置主机名:D.tedu.cn
        3.使用真机FTP构建Yum仓库

####################################################
扩展的几个应用

目录结构
• 认识Linux的目录层次:
– man hier

• 常见一级目录的用途
  /boot 	    存放系统引导必需的文件,包括内核、启动配置
  /bin、/sbin  存放各种命令程序
  /dev         存放硬盘、键盘、鼠标、光驱等各种设备文件
  /etc 		存放Linux系统及各种程序的配置文件
  /root、/home/用户名 分别是管理员root、普通用户的默认家目录
  /var 		存放日志文件、邮箱目录等经常变化的文件
  /proc 		存放内存中的映射数据,不占用磁盘
  /tmp 		存放系统运行过程中使用的一些临时文件

[root@svr7 ~]# ls -ld /tmp/

##################################################
权限的数值表示
• 权限的数值化
– 基本权限:r = 4,w = 2,x = 1
– 附加权限:SUID = 4,SGID = 2,Sticky Bit = 1

• 采用数值形式设置权限
– chmod [-R] nnn 文档...
– chmod [-R] xnnn 文档...


[root@svr7 ~]# mkdir /nsd01
[root@svr7 ~]# ls -ld /nsd01

[root@svr7 ~]# chmod 750 /nsd01
[root@svr7 ~]# ls -ld /nsd01

[root@svr7 ~]# chmod 700 /nsd01
[root@svr7 ~]# ls -ld /nsd01

[root@svr7 ~]# chmod 007 /nsd01
[root@svr7 ~]# ls -ld /nsd01

[root@svr7 ~]# chmod 077 /nsd01
[root@svr7 ~]# ls -ld /nsd01

###################################################

历史命令
• 管理/调用曾经执行过的命令
– history:查看历史命令列表
– history -c:清空历史命令
– !n:执行命令历史中的第n条命令
– !str:执行最近一次以str开头的历史命令
• 调整历史命令的数量
[root@svr7 ~]# vim /etc/profile
HISTSIZE=1000  //默认记录1000条


[root@svr7 ~]# history         #查看历史命令
[root@svr7 ~]# history -c      #清空历史命令
[root@svr7 ~]# history 
    1  history 
[root@svr7 ~]# 

[root@svr7 ~]# cat /etc/redhat-release 
[root@svr7 ~]# ls /root/
[root@svr7 ~]# cat /etc/hostname
[root@svr7 ~]# history 

[root@svr7 ~]# !cat  #执行历史命令中,最近一条以cat开头
##################################################
• du,统计文件的占用空间
– du [选项]... [目录或文件]...

– -s:只统计每个参数所占用的总空间大小
– -h:提供易读容量单位(K、M等)

[root@svr7 ~]# du -sh /root
[root@svr7 ~]# du -sh /etc/
[root@svr7 ~]# du -sh /

[root@svr7 ~]# du -sh /boot

• date,查看/调整系统日期时间
– date +%F、date +%R

– date +"%Y-%m-%d %H:%M:%S"
– date -s "yyyy-mm-dd HH:MM:SS"


[root@svr7 ~]# date
[root@svr7 ~]# date +%Y    #显示年
2019
[root@svr7 ~]# date +%m    #显示月
04
[root@svr7 ~]# date +%d    #显示日
19
[root@svr7 ~]# date +%H    #显示 时
14
[root@svr7 ~]# date +%M    #显示 分
08
[root@svr7 ~]# date +%S    #显示 秒

[root@svr7 ~]# date +%F    #显示 年-月-日

##################################################
制造快捷方式:

1.软连接 
  ln  -s   /路径/源文件      /路径/快捷方式名

若原始文件或目录被删除,连接文件将失效
软连接可存放在不同分区/文件系统

[root@svr7 ~]# cat /etc/redhat-release 
[root@svr7 ~]# ln -s /etc/redhat-release  /abc
[root@svr7 ~]# ls /

[root@svr7 ~]# ls -l /abc
[root@svr7 ~]# cat /abc

[root@svr7 ~]# ln -s /etc/redhat-release  /
[root@svr7 ~]# ls /

2.硬连接
  ln    /路径/源文件      /路径/快捷方式名

若原始文件被删除,连接文件仍可用
硬连接与原始文件必须在同一分区/文件系统

[root@svr7 ~]# ls /opt/
[root@svr7 ~]# echo 123 > /opt/A.txt

[root@svr7 ~]# ln /opt/A.txt /opt/B
[root@svr7 ~]# ls /opt/
[root@svr7 ~]# cat /opt/A.txt 
[root@svr7 ~]# cat /opt/B

[root@svr7 ~]# rm -rf /opt/A.txt 
[root@svr7 ~]# ls /opt/

[root@svr7 ~]# cat /opt/B

###################################################
获取命令帮助
1.利用--help选项
[root@svr7 ~]# date --help

2.利用man命令
[root@svr7 ~]# man  date

[root@svr7 ~]# man 5 passwd   #5表示文件类型的帮助信息

#################################################
 zip归档工具,跨平台的压缩归档格式

• 归档+压缩操作
– zip [-r] 备份文件.zip   被归档的文档...
[root@svr7 ~]# yum  -y install zip
[root@svr7 ~]# zip -r  /opt/test.zip  /etc/passwd /home/
[root@svr7 ~]# ls /opt
[root@svr7 ~]# zip -r  /opt/nb.zip   /etc/fstab   
[root@svr7 ~]# ls /opt

• 释放归档+解压操作
– unzip 备份文件.zip [-d 目标文件夹]    
[root@svr7 ~]# 
[root@svr7 ~]# mkdir /nsd02
[root@svr7 ~]# unzip /opt/test.zip -d /nsd02/

[root@svr7 ~]# ls /nsd02
[root@svr7 ~]# ls /nsd02/etc/
yum -y install unzip
####################################################
将FTP服务器上,RHCE测试脚本
     desktop0.sh  rht-labcheck  server0.sh
下载到本地/home/student/bin/赋予执行权限

[student@room9pc01 ~]$ chmod -R  +x /home/student/bin/
[student@room9pc01 ~]$ ls /home/student/bin/
clone-vm7  desktop0.sh  rht-labcheck  server0.sh
[student@room9pc01 ~]$ 

##################################################
自定义Yum仓库

1.真机:具备从互联网下载的软件包
真机:访问FTP服务将 tools.tar.gz 下载真机的桌面上

2.将真机的tools.tar.gz包,上传到虚拟机A的/root目录下
scp依赖于ssh, scp=ssh + cp

 scp  /本地路径/源文件      root@对方的IP地址:/对方的路径

[student@room9pc01 ~]$ scp /home/student/桌面/tools.tar.gz   root@192.168.4.7:/root/

[student@room9pc01 ~]$ goa
[root@svr7 ~]# ls /root/
Desktop  tools.tar.gz
[root@svr7 ~]# 

3.将tar进行解包
[root@svr7 ~]# tar -xf /root/tools.tar.gz -C  /
[root@svr7 ~]# ls /

[root@svr7 ~]# ls /tools/
[root@svr7 ~]# ls /tools/other/

4.仓库数据文件
[root@svr7 ~]# yum -y install createrepo
[root@svr7 ~]# createrepo /tools/other/

[root@svr7 ~]# ls /tools/other/
[root@svr7 ~]# ls /tools/other/repodata/

5.修改配置文件
[root@svr7 ~]# cd /etc/yum.repos.d/          
[root@svr7 yum.repos.d]# ls
[root@svr7 yum.repos.d]# vim local.repo 
[local_repo]
name=CentOS-$releasever - Base
baseurl=ftp://192.168.4.254/centos-1804
enabled=1
gpgcheck=0

[other]
name=my rpm
baseurl=file:///tools/other    #file://表示本机为服务端
enabled=1
gpgcheck=0
[root@svr7 yum.repos.d]# yum repolist

软件的安装:
[root@svr7 /]# yum -y install cmatrix

[root@svr7 /]# rpm -ql cmatrix      #显示包的安装清单
[root@svr7 /]# ls /usr/bin/cmatrix 
/usr/bin/cmatrix
[root@svr7 /]# cmatrix 
[root@svr7 /]# cmatrix -C  red

[root@svr7 /]# yum -y install oneko
[root@svr7 /]# oneko
[root@svr7 /]# oneko  &   #将程序放入后台

[root@svr7 /]# yum -y install sl
[root@svr7 /]# sl
##################################################
vim编辑技巧

 vi :Linux基本的文本编辑


命令模式操作
[root@svr7 ~]# cp   /etc/passwd  /opt/pass.txt
[root@svr7 ~]# vim  /opt/pass.txt

光标跳转
	上、下、左、右
	Home 键 或 ^、数字 0 		跳转到行首
	End 键 或“$”键 				跳转到行尾
	PgUp 键、PgDn 键 			向上翻页、向下翻页
	1G 或 gg 					跳转到全文的首行
	G 						跳转到全文的末尾行

复制/粘贴/删除
	复制 yy、#yy 		复制光标处的一行、#行
	粘贴 p、P 		粘贴到光标处之后、之前
	x 或 Delete键 		删除光标处的单个字符
	dd、#dd 			删除光标处的一行、#行
	d^ 				从光标处之前删除至行首
	d$或D(大写)		从光标处删除到行尾
	C(大写) 			从光标处删除到行尾,进入插入模式

查找/撤销/保存
	/root 		向后查找字符串“root”
	n、N 		跳至后/前一个结果
	u 			撤销最近的一次操作
	U 			撤销对当前行的所有修改
	Ctrl + r 	取消前一次撤销操作(反撤销)
	ZZ(大写) 	保存修改并退出

####################################################
末行模式操作

 读入其他文件内容
[root@svr7 ~]# echo 123 > /opt/1.txt
[root@svr7 ~]# echo abc > /opt/2.txt
[root@svr7 ~]# vim /opt/1.txt 
       :r  /opt/2.txt    #读入2.txt文件内容到当前文件
       :r  /etc/passwd  #读入/etc/passwd文件内容到当前文件


字符串替换
	:s /root/admin 		替换光标所在的当前行第一个“root”
	:s /root/admin/g   	替换光标所在的当前行所有的“root”
	:1,10 s/root/admin/g 	替换第1-10行所有的“root”
	:% s/root/admin/g	     替换文件内所有的“root”

[root@svr7 ~]# vim /opt/pass.txt


开关参数的控制
	:set  nu或nonu	 	显示/不显示行号
	:set  ai或noai 		启用/关闭自动缩进

###################################################













三222222222222222222








新教学环境的搭建

一 构建两台虚拟机
真机上运行:
                                           
     虚拟机A
        1.为eth0配置IP地址:192.168.4.7/24
        2.配置主机名:svr7.tedu.cn
     虚拟机B
        1.为eth0配置IP地址:192.168.4.207/24
        2.配置主机名:pc207.tedu.cn

##########################################################
真机:
   root密码:  teacher.com

##########################################################
U盘读取:
    文件系统:FAT   一般可以直接识别
   
       扩展FAT文件系统

    文件系统:NTFS
 
  [root@room9pc01 ~]# lsblk 
  NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT
  sda      8:0    0 465.8G  0 disk 
   ├─sda1   8:1    0 297.7G  0 part /var/lib/libvirt/ima
   └─sda2   8:2    0   100G  0 part /
  sdb      8:16   0 931.5G  0 disk 
   └─sdb1   8:17   0 931.5G  0 part 
  loop0    7:0    0   8.8G  0 loop /var/ftp/centos-1804
  [root@room9pc01 ~]# 

  [root@room9pc01 ~]# mount.ntfs-3g  /dev/sdb1     挂载点

########################################################
真机远程管理虚拟机A

KVM构建及管理

虚拟化概述
• virtualization 资源管理
– x个物理资源 --> y个逻辑资源
– 实现程度:完全、部分、硬件辅助(CPU)


• 虚拟化主要厂商及产品

	VMware 		VMware Workstation、vSphere
	Microsoft 	VirtualPC、Hyper-V
	RedHat 		KVM、RHEV
	Citrix 		Xen
	Oracle 		Oracle VM VirtualBox

安装虚拟化服务器平台
                                                                   
在虚拟机A:
• 主要软件包
– qemu-kvm	:为 kvm 提供底层仿真支持
– libvirt-daemon	:libvirtd 守护进程,管理虚拟机
– libvirt-client	:用户端软件,提供客户端管理命令
– libvirt-daemon-driver-qemu	:libvirtd 连接 qemu 的驱动
– virt-manager	:图形管理工具

#######################################################
虚拟化服务:libvirtd
[root@svr7 ~]# systemctl restart libvirtd
[root@svr7 ~]# systemctl enable libvirtd
[root@svr7 ~]# virt-manager   #运行图形管理虚拟化工具
[root@svr7 ~]# LANG=en  virt-manager   #以英文开启该工具

########################################################
使用虚拟化功能,需要CPU支持虚拟化功能

CPU支持虚拟化功能,有可能关闭
 开启----->BIOS中进行开启

########################################################
连接本地KVM
• 使用 virt-manager 客户端工具
– 应用程序 --> 系统工具 --> 虚拟系统管理器
– 默认连本机的 libvirtd 服务

真机上操作:
[student@room9pc01 ~]$ virt-manager 

virsh控制工具:
]$ virsh  console  虚拟机名字      #真机直接管理相应虚拟机
]$ virsh 
欢迎使用 virsh，虚拟化的交互式终端。

输入：'help' 来获得命令的帮助信息
       'quit' 退出

virsh # console  A


virsh nodeinfo  :查看KVM节点(服务器)信息

virsh list [--all]  :列出虚拟机

virsh net-list [--all]  :列出虚拟网络

virsh dominfo 虚拟机名称   :查看指定虚拟机的信息

]$ virsh dominfo win2008
]$ virsh autostart win2008    #将虚拟机设置为开机自启
域 win2008标记为自动开始

]$ virsh dominfo win2008 
]$ virsh autostart --disable win2008   #将虚拟机设置为开机不自启
域 win2008取消标记为自动开始

]$ virsh dominfo win2008

• 运行|重启|关闭指定的虚拟机
– virsh start|reboot|shutdown 虚拟机名称
• 强制关闭指定的虚拟机
– virsh destroy 虚拟机名称

[student@room9pc01 ~]$ virsh list --all
[student@room9pc01 ~]$ virsh start B
[student@room9pc01 ~]$ virsh list --all

[student@room9pc01 ~]$ virsh  shutdown B
域 B 被关闭
[student@room9pc01 ~]$ virsh list --all
[student@room9pc01 ~]$ virsh start B
[student@room9pc01 ~]$ virsh list
[student@room9pc01 ~]$ virsh destroy B
域 B 被删除
[student@room9pc01 ~]$ virsh list --all

##########################################################

• 一台KVM虚拟机的组成
– xml配置文件(虚拟机配置文件):定义虚拟机的名称、UUID、CPU、内
存、虚拟磁盘、网卡等各种参数设置
[student@room9pc01 ~]$ ls /etc/libvirt/qemu/


– 磁盘镜像文件:保存虚拟机的操作系统及文档数据,
镜像路径取决于xml配置文件中的定义
[student@room9pc01 ~]$ ls /var/lib/libvirt/images/


导出xml配置文件
– 查看:virsh dumpxml 虚拟机名
– 备份:virsh dumpxml 虚拟机名  > 虚拟机名.xml

   虚拟机的名称、UUID、虚拟磁盘文件路径、网卡唯一编号(MAC地址)   

#########################################################
一  新建一台全新的虚拟机,虚拟机名字nsd01
   
   虚拟机 :
       内存为  2048M  硬盘 9G  虚拟机名字nsd01  网络类型:private1

       软件包选择: 最小化安装     分区选择:自动分区   root密码设置为:1

二 利用,虚拟机nsd01作为模板,手动快速生成一台全新的虚拟机nsd02
  1.将虚拟机nsd01的磁盘文件复制一份,修改磁盘文件的名称
  [student@room9pc01 /]$ su - root
   密码： teacher.com
  [root@room9pc01 ~]# 

  ]# virsh destroy  nsd01           #强制关闭虚拟机nsd01
  ]# virsh  list  --all 
  ]# cd  /var/lib/libvirt/images/

  ]# du  -sh  nsd01.qcow2           #计算磁盘文件大小
  ]# cd  /var/lib/libvirt/images/

  ]# cp  nsd01.qcow2  nsd02.qcow2    #复制磁盘文件
  ]# du  -sh nsd02.qcow2 

  2.将虚拟机nsd01的xml文件复制一份,修改内容
  ]# mkdir /xmlfile
  ]# virsh dumpxml nsd01 > /xmlfile/haha.xml  #导出虚拟机xml文件
  ]# ls /xmlfile/
  haha.xml
  ]# vim  /xmlfile/haha.xml 

     修改虚拟机的名称: <name>nsd02</name>
   UUID:   <uuid></uuid>    #删除整行内容,按u撤销
     虚拟磁盘文件路径:  file='/var/lib/libvirt/images/nsd02.qcow2'
     网卡唯一编号(MAC地址)  :
       <mac address='52:54:00:32:a3:aa'/> #删除整行内容,按u撤销

   3.导入虚拟机信息
  ]# virsh define /xmlfile/haha.xml    #导入虚拟机信息
    定义域 nsd02（从 /xmlfile/haha.xml）

  ]# virsh list --all
  ]# virt-manager
   
   4.删除的命令
  ]# virsh list --all
  ]# virsh destroy  nsd02   #关机

  ]# virsh undefine  nsd02  #删除虚拟机nsd02,仅会删除/etc下xml文件
  ]# virsh list --all

  ]# ls /etc/libvirt/qemu   #被删除
  ]# ls /xmlfile/           #存在
  ]# ls /var/lib/libvirt/images/nsd02.qcow2  #默认保留磁盘文件

###########################################################
以nsd01虚拟机为模板,制作虚拟机nsd03
1.复制nsd01虚拟机的磁盘文件
[root@room9pc01 /]# cd /var/lib/libvirt/images/
[root@room9pc01 images]# cp nsd01.qcow2 nsd03.qcow2
[root@room9pc01 images]# ls

2.修改nsd01的xml文件
[root@room9pc01 /]# virsh dumpxml nsd01 > /xmlfile/nsd03.xml
[root@room9pc01 /]# ls /xmlfile/
[root@room9pc01 /]# vim  /xmlfile/nsd03.xml

     修改虚拟机的名称: <name>nsd03</name>
   UUID:   <uuid></uuid>    #删除整行内容,按u撤销
     虚拟磁盘文件路径:  file='/var/lib/libvirt/images/nsd03.qcow2'
     网卡唯一编号(MAC地址)  :
       <mac address='52:54:00:32:a3:aa'/> #删除整行内容,按u撤销

[root@room9pc01 /]# virsh define /xmlfile/nsd03.xml
[root@room9pc01 /]# virsh list --all
########################################################

编辑虚拟机设置
• 对虚拟机的配置进行调整
– 编辑:virsh  edit  虚拟机名

以nsd01虚拟机为模板,制作虚拟机nsd04                  
1.复制nsd01虚拟机的磁盘文件
[root@room9pc01 /]# cd /var/lib/libvirt/images/
[root@room9pc01 images]# cp nsd01.qcow2 nsd04.qcow2
[root@room9pc01 images]# ls

[root@room9pc01 /]# virsh list --all
[root@room9pc01 /]# virsh edit nsd01
     修改虚拟机的名称: <name>nsd04</name>
   UUID:   <uuid></uuid>    #删除整行内容,按u撤销
     虚拟磁盘文件路径:  file='/var/lib/libvirt/images/nsd04.qcow2'
     网卡唯一编号(MAC地址)  :
       <mac address='52:54:00:32:a3:aa'/> #删除整行内容,按u撤销

[root@room9pc01 /]# virsh list --all
##########################################################
COW技术原理
• Copy On Write,写时复制
– 前端盘直接映射原始盘的数据内容
– 当前端盘的旧数据有修改时,在修改之前自动将旧数据存入前端盘
– 对前端盘的修改不回写到原始


• qemu-img 通过 -b 选项复用指定后端盘
– qemu-img create -f qcow2 -b 后端盘 前端盘

– qemu-img info   磁盘文件    #查看磁盘文件的信息
– qemu-img create  磁盘文件   #快速产生一个任意大小的磁盘文件,内容为空


1.查看nsd01.qcow2磁盘文件的信息

]# qemu-img  info  /var/lib/libvirt/images/nsd01.qcow2 


#######################################################
通过写时复制技术,生成虚拟机abc01
– qemu-img create -f qcow2 -b 原始盘   前端盘    前端盘大小

1.以nsd01虚拟机磁盘文件为原始盘,产生abc01虚拟机的前端盘    

]# qemu-img create -f qcow2 -b /var/lib/libvirt/images/nsd01.qcow2   /var/lib/libvirt/images/abc01.qcow2  10G

]# qemu-img info /var/lib/libvirt/images/abc01.qcow2 

 前端盘大小最好大于原始盘
 一旦基于原始盘制作出前端盘,原始盘不能做任何改变

2.以前端盘abc01.qcow2产生虚拟机abc01
[root@room9pc01 /]# virsh edit nsd01
     修改虚拟机的名称: <name>abc01</name>
   UUID:   <uuid></uuid>    #删除整行内容,按u撤销
     虚拟磁盘文件路径:  file='/var/lib/libvirt/images/abc01.qcow2'
     网卡唯一编号(MAC地址)  :
       <mac address='52:54:00:32:a3:aa'/> #删除整行内容,按u撤销

[root@room9pc01 /]# 

#########################################################
1.以nsd01虚拟机磁盘文件为原始盘,产生nb虚拟机的前端盘    
]# qemu-img create -f qcow2 -b /var/lib/libvirt/images/nsd01.qcow2   /opt/nb.qcow2  10G

]# qemu-img info /opt/nb.qcow2 

2.以前端盘nb.qcow2产生虚拟机nb
[root@room9pc01 /]# virsh dumpxml nsd01 > /xmlfile/nb.xml
[root@room9pc01 /]# ls /xmlfile/
[root@room9pc01 /]# vim  /xmlfile/nb.xml
     修改虚拟机的名称: <name>nb</name>
   UUID:   <uuid></uuid>     #删除整行内容,  删错可以按u撤销
     虚拟磁盘文件路径:  file='/opt/nb.qcow2'
     网卡唯一编号(MAC地址)  :
       <mac address='52:54:00:32:a3:aa'/>  #删除整行内容
[root@room9pc01 /]# virsh define /xmlfile/nb.xml
[root@room9pc01 /]# virsh list --all
#########################################################

离线访问虚拟机的磁盘文件内容
• 基本用法
 guestmount  -a  虚拟机磁盘路径   -i  /挂载点

[root@room9pc01 /]# virsh destroy nb

[root@room9pc01 /]# mkdir /mnt/disk
[root@room9pc01 /]# ls /mnt/disk/
[root@room9pc01 /]# guestmount -a /opt/nb.qcow2 -i /mnt/disk/
[root@room9pc01 /]# ls /mnt/disk/

###########################################################
教学环境

虚拟机A:
]# LANG=en growpart /dev/vda  1  #扩展/dev/vda磁盘的第一个分区空间
]# lsblk 
]# blkid /dev/vda1 

]# xfs_growfs /dev/vda1       #扩展/dev/vda1文件系统
]# df -h

#########################################################















三3333333333333333333













新教学环境的搭建

一 构建两台虚拟机
真机上运行:
                                           
     虚拟机A
        1.为eth0配置IP地址:192.168.4.7/24
        2.配置主机名:svr7.tedu.cn
     虚拟机B
        1.为eth0配置IP地址:192.168.4.207/24
        2.配置主机名:pc207.tedu.cn

##########################################################
DNS服务基础

• DNS服务器的功能
– 正向解析:根据注册的域名查找其对应的IP地址
– 反向解析:根据IP地址查找对应的注册域名,不常用


一级DNS服务器    二级DNS服务器    三级DNS服务器

   所有有的域名都必须以点结尾

   www.qq.com.    www.baidu.com.

根域:                                . 点

一级域名:       .cn    .us     .tw    .hk    .kr    .jp 


二级域名:   .com.cn     .net.cn    .org.cn  .......

  
三级域名:   haxi.com.cn    nb.com.cn   dc.com.cn  .......

        

• Full Qualified Domain Name(FQDN),完全合格主机名

     主机头部,正确申请的域名结尾

   vip.nb.com.cn   www.nb.com.cn  tts.nb.com.cn 


####################################################
搭建Web服务器,此网站的FQDN为www.sina.com

####################################################
• BIND服务器端程序
– 主要执行程序:/usr/sbin/named
– 系统服务:named
– 默认端口:TCP/UDP 53
– 运行时的虚拟根环境:/var/named/chroot/

• 主配置文件:/etc/named.conf    #设置本机负责解析的域名    tedu.cn
• 地址库文件:/var/named/        #完全合格的域名与IP地址的对应关系

##################################################
虚拟机A构建基本DNS服务
1.安装软件包 bind  bind-chroot
bind-9.9.4-29.el7.x86_64  //域名服务包
bind-chroot-9.9.4-29.el7.x86_64  //提供虚拟根支持(牢笼政策)

2.修改主配置文件
[root@svr7 ~]# cp /etc/named.conf  /etc/named.bak
[root@svr7 ~]# vim /etc/named.conf 
options {
        directory       "/var/named";   #地址库文件存放位置
};
zone "tedu.cn" IN {           #指定负责解析域名
        type master;          #指定为权威主服务器
        file "tedu.cn.zone";  #指定地址库文件名称
};      

3.建立相应的地址库文件
[root@svr7 ~]# cd /var/named
[root@svr7 named]# cp -p named.localhost  tedu.cn.zone
    -p:保持源文件权限不变进行复制

[root@svr7 named]# ls -l tedu.cn.zone
[root@svr7 named]# vim  tedu.cn.zone
 所有的域名都必须以点结尾,都要写最后的点
  没有以点结尾,默认补全本地址库文件负责的域名

 tedu.cn.      NS  svr7        #声明负责解析tedu.cn域名为svr7主机
 svr7          A   192.168.4.7 #声明svr7主机的IP地址为192.168.4.7
 www           A   192.168.4.1 #正常解析记录
 ftp           A   192.168.4.2 #正常解析记录

4.重启named服务
[root@svr7 ~]# systemctl restart named

虚拟机B:
1.指定DNS服务器位置
  /etc/resolv.conf   #指定DNS服务器地址配置文件

]# echo nameserver  192.168.4.7  >  /etc/resolv.conf 
]# cat /etc/resolv.conf

2.测试DNS解析命令
]# nslookup www.tedu.cn
  
#########################################################
虚拟机A负责qq.com域名解析
1.修改主配置文件/etc/named.conf 
......
zone "qq.com" IN {
        type master;
        file "qq.com.zone";
};
2.建立地址库文件
[root@svr7 /]# cd /var/named/
[root@svr7 named]# cp -p  tedu.cn.zone   qq.com.zone
[root@svr7 named]# vim  qq.com.zone
 qq.com.        NS  svr7
 svr7	       A   192.168.4.7
 www            A   1.1.1.1
 ftp            A   2.2.2.2
[root@svr7 /]# !sys
systemctl restart named
[root@svr7 /]# 
#######################################################
特殊的解析记录
1.基于域名的负载均衡
[root@svr7 /]# vim /var/named/tedu.cn.zone 
tedu.cn.       NS  svr7
svr7           A  192.168.4.7
www            A  192.168.4.11
www            A  192.168.4.12
www            A  192.168.4.13
ftp            A  192.168.4.2

[root@svr7 /]# systemctl restart named

2.泛域名解析
[root@svr7 /]# vim /var/named/tedu.cn.zone 
tedu.cn.       NS  svr7
svr7           A   192.168.4.7
www            A   192.168.4.11
ftp            A   192.168.4.2
tedu.cn.       A   10.20.30.40
*              A   1.2.3.4

[root@svr7 /]# !sys
systemctl restart named
[root@svr7 /]# 

虚拟机B客户端测试: 
   nslookup hahahaha.tedu.cn
   nslookup tedu.cn

3.有规律的泛域名解析
          pc1.tedu.cn ------> 192.168.10.1
          pc2.tedu.cn ------> 192.168.10.2
          pc3.tedu.cn ------> 192.168.10.3
                  .......
          pc50.tedu.cn ------> 192.168.10.50

内置函数: $GENERATE   起始-结束     #制造连续范围的数字

[root@svr7 ~]# vim /var/named/tedu.cn.zone 
.......
$GENERATE  1-50  pc$   A  192.168.10.$

[root@svr7 ~]# !sys
systemctl restart named
[root@svr7 ~]# 

4.解析记录的别名
[root@svr7 ~]# vim /var/named/tedu.cn.zone 
.......
tts            CNAME     ftp

[root@svr7 ~]# !sys
systemctl restart named

虚拟机B客户端测试: 
[root@pc207 ~]# nslookup tts.tedu.cn
Server:		192.168.4.7
Address:	192.168.4.7#53

tts.tedu.cn	canonical name = ftp.tedu.cn.
Name:	ftp.tedu.cn
Address: 192.168.4.2

[root@pc207 ~]# 
#########################################################
DNS服务器的资源解析记录类型?
   NS     声明DNS服务器记录
   A      地址解析记录
   CNAME  解析记录别名

##########################################################


/etc/resolv.conf   #指定DNS服务器位置

客户端解析域名优先级
1./etc/hosts       #直接提供解析结果,只为本机提供服务
2./etc/resolv.conf  #寻找DNS服务器解析


[root@svr7 ~]# vim /etc/hosts 
......
192.168.4.4    www.360.com

[root@svr7 ~]# ping  www.360.com

#####################################################
DNS子域授权

     父域:www.qq.com
     子域:www.bj.qq.com

  虚拟机A负责解析qq.com域名
  虚拟机B负责解析bj.qq.com域名

虚拟机B:搭建为DNS服务器,负责解析的域名为bj.qq.com
[root@pc207 ~]# yum -y install bind bind-chroot
[root@pc207 ~]# cp /etc/named.conf /etc/named.bak
[root@pc207 ~]# vim /etc/named.conf 
 options {
        directory       "/var/named";
  };      
 zone "bj.qq.com" IN {
        type master;
        file "bj.qq.com.zone";
  };      
[root@pc207 ~]# cd /var/named/
[root@pc207 named]# cp -p named.localhost bj.qq.com.zone
[root@pc207 named]# vim bj.qq.com.zone
bj.qq.com.      NS      pc207
pc207           A       192.168.4.207
www             A       50.60.70.80
[root@pc207 /]# systemctl restart named
[root@pc207 /]# nslookup  www.bj.qq.com  192.168.4.207




子域授权

    虚拟机A负责解析qq.com域名
    虚拟机B负责解析bj.qq.com域名

    解析子域的域名,请求虚拟机A,可以解析
虚拟机A:
[root@svr7 ~]# vim /var/named/qq.com.zone 
 qq.com.       NS  svr7
 bj.qq.com.    NS  pc207
 svr7           A  192.168.4.7
 pc207          A  192.168.4.207
 www            A  192.168.4.10
 ftp            A  2.2.2.2
[root@svr7 ~]# systemctl restart named
[root@pc207 /]# nslookup www.bj.qq.com 192.168.4.7
Server:		192.168.4.7
Address:	192.168.4.7#53

Non-authoritative answer:   #非权威解答
Name:	www.bj.qq.com
Address: 50.60.70.80
[root@pc207 /]# 

递归解析:
   接受客户端解析请求,本机与其他DNS服务器交流,最终将解析结果带回来的过程

[root@svr7 ~]# vim /etc/named.conf   
options {
        directory       "/var/named";
        recursion no;
};


迭代解析:本机与其他DNS服务器交流


#######################################################
验证迭代查询
• dig命令,更专业的DNS测试工具
– 由软件包 bind-utils 提供
– 格式: dig @DNS服务器 目标地址
[root@svr7 ~]# dig www.bj.qq.com 192.168.4.7



###################################################
缓存DNS,提高解析效率

     虚拟机C
        1.为eth0配置IP地址:192.168.4.10/24
        2.配置主机名:C.tedu.cn
        3.使用真机FTP构建Yum仓库

#####################################################
虚拟机A:真DNS服务器
虚拟机B上操作,搭建缓存DNS服务器
虚拟机C:客户端
#####################################################
虚拟机B上操作
[root@pc207 /]# vim /etc/named.conf 
options {
        directory       "/var/named";
        forwarders  { 192.168.4.7; };  #转发给192.168.4.7
};
[root@pc207 /]# systemctl restart named

虚拟机C:做测试:
[root@C ~]# nslookup ftp.tedu.cn 192.168.4.207
Server:		192.168.4.207
Address:	    192.168.4.207#53

Non-authoritative answer:
Name:	ftp.tedu.cn
Address: 192.168.4.2

########################################################
















三44444444444444









虚拟机A负责sina.com域名解析
1.修改主配置文件/etc/named.conf 
......
 zone "sina.com" IN {
        type master;
        file "sina.com.zone";
 };
2.建立地址库文件
[root@svr7 /]# cd /var/named/
[root@svr7 named]# cp -p  tedu.cn.zone   sina.com.zone
[root@svr7 named]# vim  sina.com.zone
  sina.com.        NS  svr7
  svr7	          A   192.168.4.7
  www              A   1.1.1.1

[root@svr7 /]# !sys
systemctl restart named
##########################################################           
Split分离解析(视图解析)                                演讲者：赵天式

分离解析概述

什么是分离解析
• 当收到客户机的DNS查询请求的时候
– 能够区分客户机的来源地址
– 为不同类别的客户机提供不同的解析结果(IP地址)

– 为客户端提供最近服务器IP地址


BIND的view视图
• 根据源地址集合将客户机分类
– 不同客户机获得不同结果(待遇有差别)

	view "联通" {
	match-clients {  来源地址1;   .. ..;  };
	zone "12306.cn" IN {
	...... 地址库1;
	}; };
	view "铁通" {
	match-clients {  来源地址2;   .. .. ;  };
	zone "12306.cn" IN {
	...... 地址库2;
	}; };

###########################################################
注意事项:
1.由上到下进行,匹配及停止
2.分类要合理,每一个客户端都要找到自己的分类
3.所有的zone必须都在view中
	view "nsd" {
	match-clients {  192.168.4.1;   };  #匹配客户端来源地址
	zone "tedu.cn" IN {
	......tedu.cn.zone;
	 }; 
        };

	view "haha" {
	match-clients {  any;  };  #匹配客户端来源地址
	zone "tedu.cn" IN {
	...... tedu.cn.haha;
	  };
        };

                                                  主配置文件------------> 分离
 案例需求及要点                                  地址库文件------------> 解析
• 环境及需求
– 权威DNS:svr7.tedu.cn 192.168.4.7
– 负责区域:tedu.cn
– A记录分离解析 —— 以 www.tedu.cn 为例
客户机来自 解析结果
	192.168.4.207------------> 192.168.4.100
	其他地址------------> 1.2.3.4                                   

虚拟机A操作:
[root@svr7 /]# vim /etc/named.conf 
    options {
        directory       "/var/named";
        };
	view "nsd" {
	 match-clients {  192.168.4.207;   };  #匹配客户端来源地址
	 zone "tedu.cn" IN {
        type master;
        file "tedu.cn.zone";  ---->解析结果为 192.168.4.100
	 }; 
        };
	view "other" {
	 match-clients {  any;  };  #匹配客户端来源地址
	 zone "tedu.cn" IN {
        type master;
        file "tedu.cn.other";  ---->解析结果为 1.2.3.4
	  };
        };


##########################################################
 案例需求及要点
• 环境及需求
– 权威DNS:192.168.4.7
– 负责区域: tedu.cn  sina.com 
– A记录分离解析 —— 以  www.tedu.cn  www.sina.com 为例
客户机来自 解析结果
	192.168.4.207-----www.tedu.cn-------> 192.168.4.100
	其他地址-----www.tedu.cn------->1.2.3.4 
                                  
	192.168.4.207-----www.sina.com-------> 192.168.4.200
	其他地址-----www.sina.com------->10.20.30.40 

注意事项:每一个view中zone的个数保持一致
view "nsd" {
  match-clients { 192.168.4.207; };
  zone "tedu.cn" IN {
        type master;
        file "tedu.cn.zone";---->解析结果为 192.168.4.100
  };
  zone "sina.com" IN {
        type master;
        file "sina.com.zone";---->解析结果为 192.168.4.200
  };
};
view "other" {
  match-clients { any; };
  zone "tedu.cn" IN {
        type master;
        file "tedu.cn.other"; ---->解析结果为 1.2.3.4
  };
  zone "sina.com" IN {
        type master;
        file "sina.com.other";---->解析结果为 10.20.30.40
  };
};
   
####################################################
补充分离解析  acl test  { ; ; };

acl test { 192.168.4.207; 192.168.4.1; 192.168.4.2; };

view "nsd" {
  match-clients { test; };
..........

##################################################
RAID阵列概述
• 廉价冗余磁盘阵列
– Redundant Arrays of Inexpensive Disks
– 通过硬件/软件技术,将多个较小/低速的磁盘整合成一个大磁盘

– 阵列的价值:提升I/O效率、硬件级别的数据冗余
– 不同RAID级别的功能、特性各不相同

• RAID 0,条带模式
– 同一个文档分散存放在不同磁盘
– 并行写入以提高效率
– 至少需要两块磁盘组成

• RAID 1,镜像模式
– 一个文档复制成多份,分别写入不同磁盘
– 多份拷贝提高可靠性,效率无提升
– 至少需要两块磁盘组成

• RAID5,高性价比模式
– 相当于RAID0和RAID1的折中方案
– 需要至少一块磁盘的容量来存放校验数据
– 至少需要三块磁盘组成

• RAID6,高性价比/可靠模式
– 相当于扩展的RAID5阵列,提供2份独立校验方案
– 需要至少两块磁盘的容量来存放校验数据
– 至少需要四块磁盘组成

• RAID 0+1/RAID 1+0
– 整合RAID 0、RAID 1的优势
– 并行存取提高效率、镜像写入提高可靠性
– 至少需要四块磁盘组成
###################################################
进程管理

   程序: 静态的代码   占用磁盘空间

   进程: 动态的代码   占用  CPU  内存

   进程整体也是树型结果
   父进程与子进程          特殊进程:僵尸进程   孤儿进程

   进程唯一编号: PID

###################################################
查看进程树
• pstree — Processes Tree
– 格式:pstree [选项] [PID或用户名]

• 常用命令选项
– -a:显示完整的命令行
– -p:列出对应PID编号

   systemd:所有进程的父进程,上帝进程

[root@svr7 ~]# useradd lisi
[root@svr7 ~]# pstree           #查看整个进程树信息
[root@svr7 ~]# pstree lisi
bash───vim
[root@svr7 ~]# pstree -p lisi    #-p:列出对应PID编号
bash(31421)───vim(31454)
[root@svr7 ~]# pstree -ap lisi   #-a:显示完整的命令行
bash,31421
  └─vim,31454 a.txt
[root@svr7 ~]#


查看进程快照
• ps — Processes Snapshot
– 格式:ps [选项]...
• 常用命令选项
– aux:显示当前终端所有进程(a)、当前用户在所有
终端下的进程(x), 以用户格式输出(u)

– -elf:显示系统内所有进程(-e)、以长格式输出(-l)
信息、包括最完整的进程信息(-f)

• ps aux 操作
– 列出正在运行的所有进程

• ps -elf 操作
– 列出正在运行的所有进程,PPID:父进程的PID号


统计命令: wc -l  文件    #统计文件内容有多少行
[root@svr7 ~]#  wc -l /etc/passwd
统计正在运行的进程有多少个?
[root@svr7 ~]# ps aux  | wc -l

[root@svr7 ~]# ps -elf | wc -l

[root@svr7 ~]# ps aux                  

[root@svr7 ~]# ps -elf

请统计/etc目录下有多少个以".conf"结尾的文档?
[root@svr7 ~]# find /etc/ -name '*.conf' | wc -l
153
[root@svr7 ~]# 

[root@svr7 ~]# find /etc/ -name '*tab' | wc -l
9
[root@svr7 ~]# 

################################################
进程动态排名
• top 交互式工具
– 格式:top [-d 刷新秒数] [-U 用户名]

[root@svr7 ~]# top -d 1
  按键盘  P(大写)  按CPU占用排序
  按键盘  M(大写)  按内存占用排序


检索进程
• pgrep — Process Grep
– 用途:pgrep [选项]... 查询条件

• 常用命令选项
– -l:输出进程名,而不仅仅是 PID
– -U:检索指定用户的进程
– -x:精确匹配完整的进程名

[root@svr7 ~]# pgrep -l a
[root@svr7 ~]# pgrep -l crond

[root@svr7 ~]# pgrep -U  lisi
[root@svr7 ~]# pgrep -lU  lisi

[root@svr7 ~]# pgrep -x  named
[root@svr7 ~]# pgrep -xl  named

#################################################
控制进程

进程的前后台调度
• 正在运行放入后台:
  在命令行末尾添加“&”符号,不占用当前终端
• Ctrl + z 组合键
– 挂起当前进程(暂停并转入后台)
• jobs 命令
– 查看后台任务列表
• fg 命令
– 将后台任务恢复到前台运行
• bg 命令
– 激活后台被挂起的任务


[root@svr7 ~]# sleep 800 &    　#正在运行放入后台
[root@svr7 ~]# jobs        　　＃查看后台进程信息
[root@svr7 ~]# sleep 900 
^Z      　　#按键盘上Ctrl+z暂停放入后台
[2]+  已停止               sleep 900
[root@svr7 ~]# jobs 
[root@svr7 ~]# bg 2　　　＃让后台编号为２的进程　继续运行
[root@svr7 ~]# jobs 

[root@svr7 ~]# fg 1　　　＃让后台编号为１的进程　恢复到前台　　
sleep 800
^C　　　　#按键盘上Ctrl+ｃ暂停放入后台
[root@svr7 ~]# jobs
[root@svr7 ~]# fg 2　　　＃让后台编号为２的进程　恢复到前台
sleep 900
^C
[root@svr7 ~]# jobs
 
################################################
杀死进程
• 干掉进程的不同方法
– Ctrl+c 组合键,中断当前命令程序
– kill [-9] PID... 、kill [-9] %后台任务编号
– killall [-9] 进程名...
– pkill 查找条件

[root@svr7 ~]# sleep 1000 & 
[root@svr7 ~]# sleep 2000 & 
[root@svr7 ~]# sleep 3000 & 
[root@svr7 ~]# sleep 4000 & 

[root@svr7 ~]# jobs 
[root@svr7 ~]# jobs -l                 

[root@svr7 ~]# kill 3083
[root@svr7 ~]# jobs -l
[root@svr7 ~]# kill -9 3086
[root@svr7 ~]# jobs -l

[root@svr7 ~]# killall sleep
[root@svr7 ~]# jobs -l

################################################
杀死一个用户开启的所有进程（强制踢出一个用户）
[root@svr7 ~]# killall -9 -u lisi

################################################
日志管理
日志的功能
• 系统和程序的“日记本”
– 记录系统、程序运行中发生的各种事件
– 通过查看日志,了解及排除故障
– 信息安全控制的“依据”

• 由系统服务rsyslog统一记录/管理
　时间、地点、人物、发生何事


常见的日志文件
日志文件

　/var/log/messages 	记录内核消息、各种服务的公共消息
　/var/log/dmesg 		记录系统启动过程的各种消息
　/var/log/cron 		记录与cron计划任务相关的消息
　/var/log/maillog 	记录邮件收发相关的消息
　/var/log/secure 	      记录与访问限制相关的安全消息
	
日志分析

• 通用分析工具
– tail、tailf、less、grep等文本浏览/检索命令

　tailf：跟踪日志消息

[root@svr7 ~]# echo 　123 　> 　/opt/1.txt
[root@svr7 ~]# cat 　/opt/1.txt
123
[root@svr7 ~]# tailf　 /opt/1.txt
123

#################################################s
用户登录分析
• users、who、w 命令
– 查看已登录的用户信息,详细度不同

• last、lastb 命令
– 查看最近登录成功/失败的用户信息

[root@svr7 ~]# users
[root@svr7 ~]# who
[root@svr7 ~]# w

[root@svr7 ~]# last   -2   #最近登录成功
[root@svr7 ~]# lastb   -2　　#最近登录失败

###############################################

日志消息的优先级
• Linux内核定义的事件紧急程度
– 分为 0~7 共8种优先级别
– 其数值越小,表示对应事件越紧急/重要

  0  EMERG（紧急）          会导致主机系统不可用的情况
  1  ALERT（警告）          必须马上采取措施解决的问题
  2  CRIT（严重）	        比较严重的情况
  3  ERR（错误）	       运行出现错误
  4  WARNING（提醒）      可能会影响系统功能的事件
  5  NOTICE（注意）        不会影响系统但值得注意
  6  INFO（信息）	       一般信息
  7  DEBUG（调试）          程序或系统调试信息等

####################################################

使用journalctl工具
• 提取由 systemd-journal 服务搜集的日志
– 主要包括内核/系统日志、服务日志
• 常见用法
– journalctl | grep 关键词
– journalctl -u 服务名       [-p 优先级]
– journalctl -n 消息条数
– journalctl --since="yyyy-mm-dd HH:MM:SS" --
until="yyyy-mm-dd HH:MM:SS"


[root@svr7 ~]# journalctl -u httpd
[root@svr7 ~]# journalctl -xe  #显示服务最近的报错信息
#####################################################
systemd介绍
• Linux系统和服务管理器
– 是内核引导之后加载的第一个初始化进程(PID=1)
– 负责掌控整个Linux的运行/服务资源组合

• 一个更高效的系统&服务管理器
– 开机服务并行启动,各系统服务间的精确依赖
– 配置目录:/etc/systemd/system/
– 服务目录:/lib/systemd/system/
– 主要管理工具:systemctl







对于服务的管理
 systemctl restart  服务名    #重起服务
 systemctl start    服务名    #开启服务
 systemctl stop     服务名    #停止服务
 systemctl status   服务名    #查看服务当前的状态
 
 systemctl enable   服务名      #设置服务开机自启动
 systemctl disable  服务名      #设置服务不开机自启动



RHEL6 运行级别    
  
         0：关机    
         1：单用户模式（基本功能的实现，破解Linux密码）
	 2：多用户字符界面（不支持网络）    
	 3：多用户字符界面（支持网络）服务器默认的运行级别   
	 4：未定义
	 5：图形界面   
	 6：重起 
   
    切换运行级别：init  5   


RHEL7 运行模式 

   字符模式：multi-user.target
   图形模式：graphical.target
[root@svr7 /]# ls -l /lib/systemd/system/

当前直接切换到字符模式
[root@svr7 /]# systemctl isolate multi-user.target
当前直接切换到图形模式
[root@svr7 /]# systemctl isolate graphical.target

查看每次开机默认进入模式
[root@svr7 /]# systemctl get-default
graphical.target

设置永久策略，每次开机自动进入graphical.target
# systemctl set-default multi-user.target
# reboot 

#################################################












三5555555555555555555555










部署DHCP服务器

DHCP概述及原理
• Dynamic Host Configuration Protocol
– 动态主机配置协议,由 IETF(Internet 网络工程师任
务小组)组织制定,用来简化主机地址分配管理

• 主要分配以下入网参数
– IP地址/子网掩码/广播地址
– 默认网关地址、DNS服务器地址

DHCP原理：　广播进行，先到先得，一个网络里只能有一个DHCP服务器

• DHCP地址分配的四次会话
– DISCOVERY --> OFFER --> REQUEST -->ACK



开机启动项:匹配即停止
 1.本机硬盘    2.光驱设备    3.U盘    4.网络

虚拟机Ａ：
1.装软件包 dhcp
[root@svr7 /]# yum -y install dhcp
2.配置文件 /etc/dhcp/dhcpd.conf
vim末行模式  :r  /usr/share/doc/dhcp*/dhcpd.conf.example

subnet 192.168.4.0 netmask 255.255.255.0 {  #分配的网段
  range 192.168.4.100  192.168.4.200;      #分配的IP范围
  option domain-name-servers  192.168.4.7; #分配DNS服务器
  option routers 192.168.4.254;            #分配网关地址
  default-lease-time 600;
  max-lease-time 7200;
} 

[root@svr7 /]# systemctl restart dhcpd

####################################################
网络装机概述

• 规模化:同时装配多台主机
• 自动化:装系统、配置各种服务
• 远程实现:不需要光盘、U盘等物理安装介质

什么是PXE网络
• PXE,Pre-boot eXecution Environment
– 预启动执行环境,在操作系统之前运行
– 可用于远程安装


PXE组件及过程分析
• 需要哪些服务组件
– DHCP服务,分配IP地址、定位引导程序
– TFTP服务,提供引导程序下载
– HTTP服务,提供yum安装源

• 客户机应具备的条件
– 网卡芯片必须支持PXE协议
– 主板支持从网卡启动

##################################################
一  部署DHCP服务,指定下一个服务器地址

[root@svr7 /]# vim /etc/dhcp/dhcpd.conf 
 ......

  next-server  192.168.4.7;   #指定下一个服务器地址
  filename  "pxelinux.0";     #指定引导文件名称
} 

[root@svr7 /]# systemctl restart dhcpd

 pxelinux.0:网卡引导文件(安装说明书) 二进制文件
                      安装一个软件,默认产生的网卡引导文件名为pxelinux.0

##################################################
二 搭建tftp服务
    tftp:简单的文件传输协议  默认端口为69
       默认共享位置:/var/lib/tftpboot

1.安装软件包tftp-server
[root@svr7 /]# yum -y install tftp-server

2.重启tftp服务
[root@svr7 /]# systemctl  restart  tftp

3.部署pxelinux.0文件
]# yum  provides  */pxelinux.0     #查询那个包产生,该文件
]# yum -y install syslinux         
]# rpm -ql syslinux | grep pxelinux.0  #查询软件包安装清单

]# cp /usr/share/syslinux/pxelinux.0   /var/lib/tftpboot/
]# ls /var/lib/tftpboot/

pxelinux.0文件--->/var/lib/tftpboot/pxelinux.cfg/default

4.部署菜单文件
[root@svr7 /]# poweroff 
Connection to 192.168.4.7 closed by remote host.
Connection to 192.168.4.7 closed.
[student@room9pc01 ~]$ 
图形为虚拟机A,添加一个光驱设备,放入光盘内容
[student@room9pc01 ~]$ goa
Last login: Thu Apr 25 08:55:41 2019 from 192.168.4.254
[root@svr7 ~]# mount /dev/cdrom  /mnt/
mount: /dev/sr0 写保护，将以只读方式挂载
[root@svr7 ~]# ls /mnt/

[root@svr7 ~]# mkdir /var/lib/tftpboot/pxelinux.cfg

[root@svr7 ~]# cp /mnt/isolinux/isolinux.cfg /var/lib/tftpboot/pxelinux.cfg/default

[root@svr7 ~]# ls /var/lib/tftpboot/pxelinux.cfg/

[root@svr7 ~]# ls -l /var/lib/tftpboot/pxelinux.cfg/


###################################################











三666666666666666666



































rsync同步操作


rsync同步操作
• 命令用法
– rsync [选项...]  源目录     目标目录

• 同步与复制的差异
– 复制:完全拷贝源到目标
– 同步:增量拷贝,只传输变化过的数据

同步控制
• rsync操作选项
– -n:测试同步过程,不做实际修改
– --delete:删除目标文件夹内多余的文档
– -a:归档模式,相当于-rlptgoD
– -v:显示详细操作信息
– -z:传输过程中启用压缩/解压

[root@svr7 ~]# mkdir /nsd1903    /nsd04
[root@svr7 ~]# cp /etc/passwd /etc/fstab  /nsd1903/
[root@svr7 ~]# ls /nsd1903/

[root@svr7 ~]# rsync -av /nsd1903    /nsd04   #同步本身
[root@svr7 ~]# ls /nsd04
[root@svr7 ~]# rsync -av /nsd1903/    /nsd04  #同步内容
[root@svr7 ~]# ls /nsd04

[root@svr7 ~]# touch /nsd1903/1.txt
[root@svr7 ~]# ls /nsd1903/
[root@svr7 ~]# ls /nsd04

[root@svr7 ~]# rsync -av /nsd1903/    /nsd04
[root@svr7 ~]# ls /nsd04


[root@svr7 ~]# rsync -av --delete /nsd1903/  /nsd04/
[root@svr7 ~]#  ls /nsd1903
[root@svr7 ~]#  ls /nsd04

[root@svr7 ~]# touch /nsd04/xixi.txt
[root@svr7 ~]#  ls /nsd1903
[root@svr7 ~]#  ls /nsd04
[root@svr7 ~]# rsync -av --delete /nsd1903/  /nsd04/
[root@svr7 ~]#  ls /nsd1903
[root@svr7 ~]#  ls /nsd04

####################################################
远程同步                  
虚拟机A目录/nsd1903与虚拟机B目录/opt进行同步

rsync+SSH同步= rsync + scp

• 与远程的 SSH目录保持同步
– 下行:rsync [...] user@host:远程目录    本地目录
– 上行:rsync [...] 本地目录   user@host:远程目录

虚拟机A:
]# rsync -av --delete /nsd1903/ root@192.168.4.207:/opt/
虚拟机B
]# ls  /opt
]# touch /opt/haxi.txt
]# ls  /opt
虚拟机A:
]# rsync -av --delete /nsd1903/ root@192.168.4.207:/opt/
虚拟机B
]# ls  /opt
###################################################
完成实时同步准备:安装inotify-tools工具
源码包编译安装

源码编译安装的优势
• 主要优点
– 获得软件的最新版,及时修复bug
– 软件功能可按需选择/定制,有更多软件可供选择
– 源码包适用各种平台


rpm包:  rpm -ivh    yum install

源码包:----gcc make开发工具---->可以执行的程序--->运行安装

1.真机上传tools.tar.gz包,到虚拟机A的/root
[student@room9pc01 ~]$ scp /home/student/桌面/tools.tar.gz root@192.168.4.7:/root/

2.验证是否上传成功
[root@svr7 ~]# ls /root/
[root@svr7 ~]# tar -xf /root/tools.tar.gz  -C  /opt
[root@svr7 ~]# ls /opt/tools/
inotify-tools-3.13.tar.gz  other

步骤1:安装gcc make开发工具(安装依赖关系的软件)
[root@svr7 ~]# yum -y install gcc  make
[root@svr7 ~]# rpm -q gcc
[root@svr7 ~]# rpm -q make
步骤2:tar解包,释放源代码至指定目录
]# tar -xf /opt/tools/inotify-tools-3.13.tar.gz -C /
]# ls /inotify-tools-3.13/

步骤3: ./configure 配置,指定安装目录/功能模块等选项
                            
       --prefix=指定安装的位置   

]# cd /inotify-tools-3.13/
]# ./configure  
       
  #检测系统是否安装gcc,检测系统是否可以支持编译安装     
常见提示:gcc没有安装
checking for gcc... no
checking for cc... no
checking for cl.exe... no
configure: error: no acceptable C compiler found in $PATH
See `config.log' for more details.

步骤4:make 编译,生成可执行的二进制程序文件
]# cd /inotify-tools-3.13/
]# make 

步骤5:make install 安装,将编译好的文件复制到安装目录
]# cd /inotify-tools-3.13/
]# make install
]# ls /usr/local/bin/inotifywait 

###################################################
实时同步:虚拟机A目录/nsd1903与虚拟机B目录/opt进行同步

一 实现ssh的无密码验证,生成公钥 私钥

1.虚拟机A生成公钥 私钥
[root@svr7 ~]# ssh-keygen       #一路回车
[root@svr7 ~]# ls /root/.ssh/
authorized_keys  id_rsa  id_rsa.pub  known_hosts

known_hosts:记录曾经远程管理过的主机

2.虚拟机A传递公钥到虚拟机B上
]# ssh-copy-id  root@192.168.4.207

]# rsync -av --delete /nsd1903/ root@192.168.4.207:/opt/

虚拟机B
[root@pc207 ~]# ls /root/.ssh/
authorized_keys
[root@pc207 ~]# 

####################################################

二  监控目录内容的变化

inotifywait监控
• 基本用法
– inotifywait [选项] 目标文件夹

• 常用命令选项
– -m,持续监控(捕获一个事件后不退出)
– -r,递归监控、包括子目录及文件
– -q,减少屏幕输出信息
– -e,指定监视的 modify、move、create、delete、attrib等事件类别



 inotifywait -mrq /nsd1903

 rsync -a --delete /nsd1903/ root@192.168.4.207:/opt/

三  书写shell脚本完成,实时同步操作
       循环解决重复性操作
       for循环:适合写有次数的循环

          for  i  in  值
           do
                        重复性操作
           done

        死循环:无限次的循环
       while循环:适合写无限次的循环

         while [ 1 -eq 1 ]
          do
		      重复执行的操作
          done

[root@svr7 ~]# vim /root/rsync.sh
#!/bin/bash
while  inotifywait -rqq /nsd1903 
 do
 rsync -a --delete /nsd1903/ root@192.168.4.207:/opt/
 done
[root@svr7 ~]# /root/rsync.sh

####################################################






Cobbler装机平台,不同版本的多系统的安装

一  具备一个CentOS虚拟机  
[root@svr7 ~]# cat /etc/redhat-release 
CentOS Linux release 7.5.1804 (Core) 

                                          


二、虚拟机设置  
   1.设置防火墙为trusted
  ]# firewall-cmd  --set-default-zone=trusted 

   2.当前及永久设置SELinux状态为permissive
  ]# setenforce 0     #当前临时关闭
  ]# getenforce 
  ]# vim /etc/selinux/config 
  SELINUX=	

三、利用scp真机传递cobbler.zip包到虚拟机192.168.4.7中
 # scp /home/student/桌面/cobbler.zip   root@192.168.4.7:/root/
 
##################################################

四、搭建Cobbler装机平台

  Cobbler概述软件，管理dhcp、tftp、Web服务
    自由的导入镜像与ks应答文件

1.解压cobbler.zip包
[root@svr7 ~]# yum -y install unzip 

[root@svr7 ~]# unzip /root/cobbler.zip -d /
[root@svr7 ~]# ls /cobbler/
cobbler_boot.tar.gz  cobbler_web.png
cobbler_rpm.zip
[root@svr7 ~]# 

[root@svr7 ~]# unzip /cobbler/cobbler_rpm.zip -d /opt/
[root@svr7 ~]# ls /opt/cobbler/


#####################################################
五、安装cobbler主程序、工具包等
]# yum -y install /opt/cobbler/*.rpm  httpd  dhcp mod_ssl


[root@svr7 ~]# rpm -q cobbler
cobbler-2.8.2-1.el7.x86_64
[root@svr7 ~]# 


################################################################
cobbler网络装机部署

1.安装软件 cobbler cobbler-web dhcp tftp-server pykickstart httpd  tftp-server 

 cobbler         #cobbler程序包
 cobbler-web     #cobbler的web服务包
 pykickstart     #cobbler检查kickstart语法错误
 httpd           #Apache web服务
 dhcp            #dhcp服务
 tftp-server     #tftp服务


2.配置cobbler
[root@svr7 /]# vim  /etc/cobbler/settings

 next_server:   192.168.4.7    #设置下一个服务器还为本机
 server:   192.168.4.7         #设置本机为cobbler服务器
 manage_dhcp:   1              #设置cobbler管理dhcp服务
 pxe_just_once:   1            #防止客户端重复安装操作系统

 开机启动项： 匹配及停止  
     1.硬盘启动    2.光驱设备     3.U盘     4.网络引导  

3.配置cobbler的dhcp
[root@Cobbler /]# vim  /etc/cobbler/dhcp.template 

  :%s  /旧/新/g      #全文替换
  :%s  /192.168.1/192.168.4/g    #全文替换

    5 次替换，共 4 行   


4.绝对路径解压cobbler_boot.tar.gz    #众多的引导文件
# tar -tf  /cobbler/cobbler_boot.tar.gz   #查看包里面内容
# tar -xPf  /cobbler/cobbler_boot.tar.gz  #绝对路径释放
# ls  /var/lib/cobbler/loaders/
5.启动相关服务
  ]# systemctl restart cobblerd     
  ]# systemctl enable cobblerd

  ]# systemctl restart httpd
  ]# systemctl enable httpd

  ]# systemctl restart tftp
  ]# systemctl enable tftp

  ]# systemctl restart rsyncd   #同步服务
  ]# systemctl enable rsyncd


6.同步刷新cobbler配置
[root@cobbler /]# cobbler sync    #检测所有配置是否正确
......
*** TASK COMPLETE ***


]# firefox https://192.168.4.7/cobbler_web

   用户名：cobbler
   密码：cobbler


##########################################################################################################
cobbler应用

  cobbler import  --path=挂载点   --name=导入系统命名（随意起）
导入安装镜像数据

# mount /dev/cdrom  /dvd

# ls /dvd/

# cobbler import --path=/dvd  --name=CentOS7

cobbler导入的镜像放在：/var/www/cobbler/ks_mirror




[root@cobbler /]# cobbler list    #查看有哪些系统
distros:
   CentOS7-x86_64        #安装客户端至少2G内存

profiles:
   CentOS7-x86_64

##############################################
删除
# cobbler list 
# cobbler profile remove --name=CentOS7-x86_64  #删除菜单信息
# cobbler distro remove --name=CentOS7-x86_64  #删除镜像信息


###########################################

# umount /dvd/
# mount /dev/cdrom  /dvd   将光盘换成RHEL7
# ls /dvd/

  安装完成机器 默认root  密码  cobbler

############################################################################################################
自定义应答文件：开头注释行删除

[root@cobbler ~]# system-config-kickstart  #生成ks文件

必须默认kickstart文件存放位置：/var/lib/cobbler/kickstarts/

[root@cobbler ~]# cobbler list

修改kickstart文件：
[root@cobbler ~]# cobbler profile edit --name=CentOS7  --kickstart=/var/lib/cobbler/kickstarts/自定义.cfg

[root@cobbler ~]# cobbler profile report
[root@cobbler ~]# cobbler sync  #同步配置

############################################################################################################




























网络111111111111111111










网络功能:
信息传递
资源共享    
提高可靠性  
增加系统处理能力    集群

60年代
分组交换 : 提高数据传输效率,减少服务器负担
70~80年代
TCP/ip : 统一网络环境   
90年代
web

华为
路由器   交换机
点对点    WAN
星形       LAN
优点:易于实现,易于扩展,易于故障排查
网状	      LAN
优点:高可靠,高可用

osi七层参考模型   (理论框架)
tcp/ip五层参考模型   (实际应用)
物理层,数据链路层,网络层,传输层,应用层

bit   比特      标识网络速度,设备接口时使用
byte  字节      标识存储单位时使用
8比特 = 1字节 

172.40.50.115
获取kvm.sh文件后
1,   关闭所有虚拟机
2,   以管理员身份运行
3, chmod +x kvm.sh
4, ./kvm.sh
看到ok则成功

密码: tedu

熟悉网络设备视图:
system-view             //进入系统视图
interface Ethernet0/0/1    //进入接口视图
quit    //返回上一视图
interface Ethernet0/0/1    //再次进入接口视图
return     //返回用户视图

return命令和快捷键ctrl+z效果一样

<Huawei>system-view 
[Huawei]sysname SW1			//修改设备名称
 
[Huawei]display version    //查看设备系统版本与硬件型号

[Huawei]display current-configuration   //查看设备当前配置

aaa   三a模式, 账户,认证,统计
使用账户和密码登录终端
<Huawei>system-view 
[Huawei]aaa                    //进入aaa认证
[Huawei-aaa]local-user admin01 password cipher 123    //创建账户叫admin01,密码123       
[Huawei-aaa]quit
[Huawei]user-interface console 0        
[Huawei-ui-console0]authentication-mode aaa     //激活配置

密码配置完毕后,退出系统,测试效果    或者 使用 display current-configuration  查看配置

快捷键   ctrl+]   退出账户

<Huawei>save     //保存配置,如果保存时有被问到是否覆盖,则也回答Y
<Huawei>reboot	 //重启设备
<Huawei>reset saved-configuration     //删除配置文件(恢复出厂设置)
注意:删除配置文件之后,如果重启,系统会先询问是否保存,回答N,然后在回答Y重启

VRP(通用路由平台)  华为路由器交换机的操作系统的称呼


二进制       0  1  
十进制       0123456789   10

十六进制   0123456789ABCEDF

mac地址长度48位(bit)  6字节
全球唯一
前24位供应商标识 ,后24位,供应商给设备的唯一编号
单播  1对1
组播  1对多
广播  1对所有

mtu 最大传输单元

交换机工作原理
1,学习源MAC地址
2,广播,除了数据来源的接口之外的接口发送广播寻找目的主机
3,转发数据
4,更新   超过300秒没有任何数据通讯,或者关机拔网线











网络2222222222222222







信息传递,资源共享,提高可靠性,提高系统处理能力
TCP/IP
WAN   LAN
点对点   
星形
网状  高可靠
osi七层参考模型   iso颁布
tcp/ip五层参考模型
    数据链路层,网络层,传输层

数据段
数据包
数据帧
比特流

计算机
防火墙
路由器
交换机
网卡

数据的发送是打封装的过程
数据的接收时拆(解)封装的过程

用户视图
系统视图
接口视图
协议视图

交换机是组建局域网的重要设备之一,交换可以智能的根据目标MAC地址转发数据帧,交换机工作在数据链路层

学习,广播,转发,更新

广播域  可以理解是同一范围,或者同一网段
干扰,降低网速,
vlan   最大 4096个    范围  0~4095
通常可以划分1000+
vlan 1,不需创建,默认存在

创建vlan,将接口加入vlan,进行广播域隔离
<Huawei>system-view
[Huawei]vlan batch 2 3            //创建VLAN2、3
[Huawei]port-group 1         //创建1号接口组
[Huawei-port-group-1]group-member Ethernet0/0/3 Ethernet0/0/4     //将3口4口加入1号组
[Huawei-port-group-1]port link-type access    //将1号组里所有的接口设置为access,表示将此接口定义为即将为某一个vlan服务
[Huawei-port-group-1]port default vlan 2   //定义此接口为vlan 2 服务


S1配置
[Huawei]interface Ethernet0/0/7
[Huawei-Ethernet0/0/7] port link-type access
[Huawei-Ethernet0/0/7] port default vlan 3

S2配置
[Huawei]vlan 3            //创建VLAN3
[Huawei]port-group 1
[Huawei-port-group-1]group-member Ethernet0/0/5 to Ethernet0/0/7      //将5,6,7口加入接口组
[Huawei-port-group-1]port link-type access 
[Huawei-port-group-1]port default vlan 3    

access 接入链路  ,可以承载1个vlan的数据
trunk  中继链路 ,可以承载多个vlan的数据

一个接口如果被修改配置,再配置中继链路时会要求恢复默认配置
[Huawei]clear configurations interface e0/0/1    //恢复1接口默认配置

[Huawei-Ethernet0/0/7]port link-type trunk    //将7口设置为中继链路
[Huawei-Ethernet0/0/1]port trunk allow-pass vlan all    //允许此接口传递任意vlan的数据

配置链路聚合,增加网络带宽与可靠     
关闭接口  shutdown    打开接口 undo shutdown
方法一:
[Huawei]interface eth-trunk 1     //开启链路聚合接口1
[Huawei-eth-trunk 1]port link-type trunk
[Huawei-eth-trunk 1]port trunk allow-pass vlan all
[Huawei-eth-trunk 1]quit
[Huawei]interface Ethernet0/0/1		//进入接口1
[Huawei-Ethernet0/0/1]eth-trunk 1   //将接口1加入链路聚合接口1
[Huawei]interface Ethernet0/0/2
[Huawei-Ethernet0/0/2]eth-trunk 1    //将接口2加入链路聚合接口1
方法二:
[Huawei]interface eth-trunk 1     //开启链路聚合接口1
[Huawei-eth-trunk 1]trunkport Ethernet 	0/0/1 0/0/2
[Huawei-eth-trunk 1]port link-type trunk
[Huawei-eth-trunk 1]port trunk allow-pass vlan all

在配置中继链路和链路聚合时,接口要保持默认状态,如果有配置需要清除

路由器
1,使用前需要配置ip地址
2,能够连接不同广播域(网段)的设备,并隔离广播

C  192.168.0.1 /24
静态路由  通过管理员手工配置目的网段来使网络互通的一种方式
直连路由   路由器接口配置ip后自动生成,结果需要是up状态

[Huawei]ip route-static 192.168.3.0 24 192.168.2.2   //配置静态路由,目标网段192.168.3.0,掩码24位,下一跳192.168.2.2
[Huawei]display ip routing-table     //查看路由表,只需关注24位掩码的网段即可














网络33333333333333333333

vlan
广播控制
增加安全
带宽利用提高
降低数据传递延迟


vlan  网段     部门   广播域

配置三层交换机的SVI(交换机虚拟接口)地址
[Huawei]vlan batch 2 3     //创建vlan2和3
[Huawei]interface Vlanif 1		//进入vlan1的虚拟接口
[Huawei-Vlanif1]ip address 192.168.1.254 24    //为虚拟接口配置ip,此ip可以作为终端设备的网关
[Huawei]interface Vlanif 2
[Huawei-Vlanif1]ip address 192.168.2.254 24
[Huawei]interface Vlanif 3
[Huawei-Vlanif1]ip address 192.168.3.254 24

ICMP  Internet 控制报文协议,检测和反馈网络状态信息
ping -t 持续检测网络
ping -l 100  修改ping包大小为100字节

拓扑组建思路

三层交换机配置:
创建vlan2 vlan3  g0/0/1口配置trunk   配置SVI的ip地址
二层交换机配置:
创建vlan2 vlan3   e0/0/2加入vlan2  e0/0/3加入vlan3
e0/0/4配置trunk

三层交换机g0/0/2口配置ip思路:
首先创建vlan4,然后进入vlanif4口配置ip 192.168.4.1 24
最后将g0/0/2加入vlan4

静态路由  手工
动态路由  可以自动学习路由条目,通过某种动态路由协议实现

OSPF  开放式最短路径优先协议

宣告
骨干区域  area 0

255.255.255.0
11111111.11111111.11111111.00000000
反掩码
0.0.0.255


ospf配置过程
1,开启进程   ospf 1
2,进入骨干区域  area 0   
3,对本设备所在网段进行宣告, 并使用反掩码

直连路由
静态路由
动态路由
默认路由  是特殊的静态路由,可以匹配任意网段,当路由表中找不到明细路由时使用,一般用在企业出口网关

ospf配置
三层交换机
宣告  192.168.1.0  192.168.2.0  192.168.3.0  192.168.4.0 
路由器
宣告 network 192.168.4.0 0.0.0.255

三层交换机需要添加默认路由
ip route-static 0.0.0.0 0.0.0.0 192.168.4.2


0~65535        65536个
0保留
1~1023之间  知名端口号
使用1024之后的

syn 打算与对方主机进行连接
ack 确认对方信息
fin 打算与对方主机断开连接

TCP
三次握手
syn----ack,syn----ack

四次断开
fin----ack----fin----ack

访问控制列表:
ACL,过滤网络数据,可以对源ip,目标ip,端口,协议进行限制,达到更加合理的使用网络的目的

0 严格匹配
1 不做匹配

192.168.2.10

192.168.1.0   0.0.0.255

192.168.2.1  0.0.0.0

deny   拒绝
permit 允许

[Huawei]acl 2000     //使用基本acl,号码是2000
[Huawei-acl-basic-2000]rule deny source 192.168.2.1 0  //拒绝源地址是192.168.2.1的主机
[Huawei]interface GigabitEthernet 0/0/1    //进入0/0/1接口中
[Huawei-GigabitEthernet0/0/1]traffic-filter inbound acl 2000     //使用刚刚创建的acl规则过滤进入这个接口的数据

练习2:  只允许192.168.2.1通过,拒绝其他所有人
[Huawei]acl 2001     //创建新的acl规则列表
[Huawei-acl-basic-2001]rule permit source 192.168.2.1 0   //允许192.168.2.1通过
[Huawei-acl-basic-2001]rule deny source any    //拒绝所有人通过
[Huawei]interface GigabitEthernet 0/0/1
[Huawei-GigabitEthernet0/0/1]undo traffic-filter inbound   //删除原有规则
[Huawei-GigabitEthernet0/0/1] traffic-filter inbound acl 2001   //附加新规则

高级acl配置:
[Huawei]acl 3000
[Huawei-acl-adv-3000]rule deny tcp source 192.168.2.1 0 destination 192.168.1.1 0 destination-port eq 21    //创建规则,拒绝192.168.2.1访问192.168.1.1的21号端口(ftp服务)
[Huawei-acl-adv-3000]rule deny tcp source 192.168.2.2 0 destination 192.168.1.1 0 destination-port eq 80    //创建规则,拒绝192.168.2.2访问192.168.1.1的80号端口(www服务)
[Huawei]interface g0/0/1
[Huawei-GigabitEthernet0/0/1]traffic-filter inbound acl 3000      //在接口附加规则












网络444444444444444




A 1~127
B 128~191
C 192~223

127  本机回环
169.254   内部保留地址

内部私有地址
A 10.0.0.0~10.255.255.255   /8   255.0.0.0
B 172.16.0.0~172.31.255.255   /16   255.255.0.0
C 192.168.0.0~192.168.255.255   /24   255.255.255.0


NAT  网络地址转换, 可以将内部私有ip地址转换为公网ip地址,从而实现全球互联

ipv4  32位 
ipv6  128位

静态nat,1对1转换,通常配置在服务器环境

进入g0/0/0接口,注意此接口是外网口
[Huawei-GigabitEthernet0/0/0]nat static global 100.0.0.2 inside 192.168.2.1    //使用静态nat将公网地址100.0.0.2与内部192.168.2.1进行转换
[Huawei-GigabitEthernet0/0/0]nat static global 100.0.0.3 inside 192.168.2.2
[Huawei-GigabitEthernet0/0/0]display this   //查看当前视图配置

easy ip ,多对1转换,通常在仅需访问公网的环境使用
[Huawei]acl 2000    //使用acl确定范围
[Huawei-acl-basic-2000]rule permit source any     //使用acl定义允许任何内部地址
[Huawei]interface g0/0/0    //进入外网接口
[Huawei-GigabitEthernet0/0/0]nat outbound 2000    //让所有人可以利用g0/0/0的ip访问外网

广播风暴   由于环形网络引起的广播泛滥现象,会导致网络崩溃
STP  生成树协议,可以在环形网络中临时断开一个接口,避免广播风暴,在网络不通时,又可以打开这个接口,起到备份链路的作用

display  stp  brief   //查看生成树摘要信息
forwarding  转发状态
discarding  阻塞状态(临时断开的接口)

undo stp enable    //关闭生成树(通常不能这样做)

VRRP  虚拟路由冗余协议 , 可以对多网关设备的网络提供备份网关的效果,从而避免单一网关失效影响全网通讯的问题

为三层交换机配置vlan地址
[Huawei]interface Vlanif 1      //进入vlan1接口
[Huawei-Vlanif1]ip address 192.168.1.252 24    //配置ip
[Huawei]vlan 2    //创建vlan2
[Huawei]interface Vlanif 2      //进入vlan2接口
[Huawei-Vlanif2]ip address 192.168.2.2 24    //配置ip
[Huawei-Vlanif2]quit
[Huawei]interface GigabitEthernet 0/0/2   //进入g0/0/2接口
[Huawei-GigabitEthernet0/0/2]port link-type access    //将g0/0/2配置为接入链路,即将只为vlan2传递数据
[Huawei-GigabitEthernet0/0/2]port default vlan 2  //将接口加入vlan2

ospf
宣告,对外告知自身连接了哪些网段
配置动态路由,实现网络互通
第1台S5700
[Huawei]ospf 1   //开启ospf进程,进程号1
[Huawei-ospf-1]area 0    //进入区域0,ospf的首个区域
[Huawei-ospf-1-area-0.0.0.0]network 192.168.1.0 0.0.0.255   //宣告自身所在网段
[Huawei-ospf-1-area-0.0.0.0]network 192.168.2.0 0.0.0.255
第2台S5700
[Huawei]ospf 1
[Huawei-ospf-1]area 0
[Huawei-ospf-1-area-0.0.0.0]network 192.168.1.0 0.0.0.255
[Huawei-ospf-1-area-0.0.0.0]network 192.168.3.0 0.0.0.255
路由器
[Huawei]ospf 1
[Huawei-ospf-1]area 0
[Huawei-ospf-1-area-0.0.0.0]network 192.168.2.0 0.0.0.255
[Huawei-ospf-1-area-0.0.0.0]network 192.168.3.0 0.0.0.255
[Huawei-ospf-1-area-0.0.0.0]network 192.168.4.0 0.0.0.255

排错:
1,查接口的ip,终端设备的网关
2,查ospf宣告的网段  

查看设备ip
display ip interface brief

两台网关设备(S5700)配置:
[Huawei]interface Vlanif 1     //进入vlan接口
[Huawei-Vlanif1]vrrp vrid 1 virtual-ip 192.168.1.254   //开启vrrp功能,相同vlan内组号要一致,此处用1,虚拟路由器的ip是192.168.1.254

在多vlan中配置vrrp实现负载均衡


sw1  
1,创建vlan2
2,与其他交换机所连接的接口配置为trunk
sw2
1,创建vlan2
2,与其他交换机所连接的接口配置为trunk
3,连接pc的接口加入vlan2
ms1
1,创建vlan2
2,与其他交换机所连接的接口配置为trunk
3,给vlan1配置ip  192.168.1.252
   给vlan2配置ip  192.168.2.252
4,进入vlan1,开启vrrp,虚拟ip是192.168.1.254
 vlan1的vrrp优先级设置为110
5,进入vlan2,开启vrrp,虚拟ip是192.168.2.254
ms2
1,创建vlan2
2,与其他交换机所连接的接口配置为trunk
3,给vlan1配置ip  192.168.1.253
   给vlan2配置ip  192.168.2.253
4,进入vlan1,开启vrrp,虚拟ip是192.168.1.254
5,进入vlan2,开启vrrp,虚拟ip是192.168.2.254
  vlan2的vrrp优先级设置为110







网络555555555555555555





综合拓扑 :搭建企业网络
1,规划ip,vlan
2,链接终端设备线缆到接入层交换机(S3700)
3,在所有接入层交换机创建vlan10,vlan20,vlan30,vlan40
   vlan  batch  10 20 30 40
4,将接入终端设备所在的接口加入相应vlan
	in e0/0/5
	port link-type access
	port default vlan 10		//注意第一台加vlan10,第二台加vlan20,以此类推,最后使用 display vlan检查
5,在vlan40的接入层交换机中配置链路聚合
	interface eth-trunk 1
	trunkport ethernet 0/0/1 0/0/2
	interface eth-trunk 2
	trunkport ethernet 0/0/3 0/0/4
	然后使用查询所有配置检查结果 dis current-configuration
6,添加S5700两台,作为网关设备,并将链接vlan40的设备接口进行链路聚合的配置
	第一台S5700
	interface eth-trunk 1
	trunkport gigabitethernet 0/0/4 0/0/5
	第二台S5700
	interface eth-trunk 2
	trunkport gigabitethernet 0/0/4 0/0/5
7,在两台S5700上分别创建vlan10,vlan20,vlan30,vlan40
8,将两台S5700用线缆链接
9,将所有交换机之间的链路都配置为trunk
	注意:链路聚合的接口要进入聚合口中配置
	interface eth-trunk 1
	port link-type trunk
	port trunk allow-pass vlan all
	普通接口配置:
	interface ethernet 0/0/1      //注意,百兆口和千兆口区分
	port link-type trunk
	port trunk allow-pass vlan all
	当接口数量较多时可以用接口组
	S5700交换机:	
	port-group 1
	group-member g0/0/1 to g0/0/3 g0/0/6
	port link-type trunk
	port trunk allow-pass vlan all
10,给第一台S5700配置ip
	vlan10  192.168.10.252
	vlan20  192.168.20.252
	vlan30  192.168.30.252
	vlan40  192.168.40.252
     给第二台S5700配置ip
	vlan10  192.168.10.253
	vlan20  192.168.20.253
	vlan30  192.168.30.253
	vlan40  192.168.40.253
然后使用每个vlan的pc主机测试与本vlan网关的链接状况
比如用192.168.10.1  去 ping  192.168.10.252 和 192.168.10.253

11,配置网关设备开启vrrp,实现虚拟网关功能,并达到负载均衡
	第一台S5700负责担任vlan10,vlan20的主
		            负责担任vlan30,vlan40的备份
	interface vlanif10
	vrrp vrid 10 virtual-ip 192.168.10.254
	vrrp vrid 10 priority 110
	interface vlanif20
	vrrp vrid 20 virtual-ip 192.168.20.254
	vrrp vrid 20 priority 110
	interface vlanif30
	vrrp vrid 30 virtual-ip 192.168.30.254
	interface vlanif40
	vrrp vrid 40 virtual-ip 192.168.40.254
	然后使用 dis vrrp brief检查
	第二台S5700负责担任vlan10,vlan20的备份
		            负责担任vlan30,vlan40的主
	interface vlanif10
	vrrp vrid 10 virtual-ip 192.168.10.254
	interface vlanif20
	vrrp vrid 20 virtual-ip 192.168.20.254
	interface vlanif30
	vrrp vrid 30 virtual-ip 192.168.30.254
	vrrp vrid 30 priority 110
	interface vlanif40
	vrrp vrid 40 virtual-ip 192.168.40.254
	vrrp vrid 40 priority 110
12,添加两台连接公网的路由器,并配置ip地址,另外两台S5700也配置连接路由器的地址
13,在路由器与S5700配置动态路由
	路由器1
	ospf 1
	area 0
	network 192.168.50.0 0.0.0.255
	network 192.168.70.0 0.0.0.255
	路由器2
	ospf 1
	area 0
	network 192.168.60.0 0.0.0.255
	network 192.168.80.0 0.0.0.255
	第一台S5700
	ospf 1
	area 0
	network 192.168.10.0 0.0.0.255
	network 192.168.20.0 0.0.0.255
	network 192.168.30.0 0.0.0.255
	network 192.168.40.0 0.0.0.255
	network 192.168.50.0 0.0.0.255
	network 192.168.60.0 0.0.0.255
	第二台S5700
	ospf 1
	area 0
	network 192.168.10.0 0.0.0.255
	network 192.168.20.0 0.0.0.255
	network 192.168.30.0 0.0.0.255
	network 192.168.40.0 0.0.0.255
	network 192.168.70.0 0.0.0.255
	network 192.168.80.0 0.0.0.255
14,配置外网ip
15,在所有路由器配置默认路由,在ospf中宣告默认路由
[Huawei]ip route-static 0.0.0.0 0.0.0.0 100.0.0.10
[Huawei]ospf
[Huawei-ospf-1]default-route-advertise always    //宣告默认路由
16,在所有路由器中配置nat使内外网互联
	使用acl定义范围
	acl 2000
	rule permit source any
	再使用easy ip连接外网
	interface g0/0/2
	nat outbound 2000
最终使用任何pc主机可以ping通外网的100.0.0.10则成功






















shellshellshell


	


6天  
复杂的操作变得简单化,简单的操作变得自动化
200行

恢复环境
rht-vmctl reset classroom
rht-vmctl reset server
yum repolist
yum -y install ksh		//安装新解释器
cat /etc/shells			//查看所拥有的解释器

>    >>      收集正确信息
2>   2>>   收集错误信息
&>   &>>   收集所有信息
<  输入重定向

bash优势
支持tab,快捷键,历史命令,别名,重定向,管道

shell脚本编写的三个步骤
1,声明所用解释器
2,写脚本功能描述,变量含义,使用位置,作者等信息
3,编写执行指令

abc.sh

#!/bin/bash
# 脚本功能
echo "abc"
echo "xyz"

脚本执行方法
1,添加x权限
2,使用解释器直接执行脚本,新开启解释器
   bash  test1.sh     //执行完毕后退出新开启的解释器
3,使用source直接执行脚本,使用当前解释器
   source  test1.sh   //执行完毕后退出当前解释器

#!/bin/bash
echo 'abc'
sleep 1000

编写搭建yum仓库脚本
#!/bin/bash
rm -rf /etc/yum.repos.d/*.repo
echo '[abc]
name=aabbcc
baseurl=http://classroom/content/rhel7.0/x86_64/dvd
enable=1
gpgcheck=0' > /etc/yum.repos.d/abcdef.repo

脚本写完后执行,并使用yum repolist检查结果
如果失败可以考虑更换yum源
http://classroom/content/rhel7.0/x86_64/dvd

利用已有的yum环境,安装ftp服务并运行,然后设置为开机自启
#!/bin/bash
yum -y install vsftpd  &> /dev/null   //安装过程不显示
systemctl restart vsftpd
systemctl enable vsftpd

脚本运行完毕后检查服务状态,脚本运行时可用  bash -x test3.sh来查看脚本运行过程,便于排错
systemctl status vsftpd

变量   使用固定的名称存储可能变化的量,增加脚本灵活,可以在脚本中反复使用

自定义变量 ,需要管理员定义变量的值,变量的名称使用大小写字母,不能以数字开头,不能使用特殊符号
定义变量        变量名称=变量的值
查看变量内容 echo $变量名称
取消变量        unset 变量名称

系统变量: 包括
环境变量  UID   HOME  USER   PWD  SHELL  HOSTNAME  PS1 一级提示符   PS2 二级提示符
预定义变量 
$0  显示脚本名
$$  显示脚本进程号
$?  显示上一条指令是否成功  ,0是成功,非0是失败
$#  统计位置变量的个数
$*  显示所有位置变量的内容

位置变量
$1  脚本名后面跟的第1个参数
$2  脚本名后面跟的第2个参数
$3  脚本名后面跟的第3个参数
.
.
#!/bin/bash
echo $1
echo $2
echo $3
echo $0
echo $$
echo $?
echo $#
echo $*

编写创建用户并配置密码的脚本
#!/bin/bash
useradd abcd
echo 123 | passwd --stdin abcd

脚本运行后检查结果
id abcd

升级版
#!/bin/bash
useradd $1
echo $2 | passwd --stdin $1

脚本运行 bash test5.sh xyz 321     //脚本名后追加用户名和密码,xyz相当于$1, 321是$2

env  查看所有环境变量
set  查看所有变量

''   界定范围,屏蔽$符号的作用
""  界定范围
`` 反撇号或  $(),可以获取指令的输出结果

使用read功能与脚本使用者交互获取变量的值,使脚本目的更明确
#!/bin/bash
read -p "请输入用户名"   u
useradd $u
read -p "请输入密码"   p
echo $p | passwd --stdin $u

stty  -echo   //关闭回显
stty  echo    //开启回显

局部变量  仅当前解释器可以使用的变量,范围小
全局变量  解释器开启子进程(bash)后依然可以识别,范围大
a=10
export  a     //对已有局部变量修改为全局变量
export  b=20   //新定义全局变量
然后运行bash开启新解释器检查 echo $a或$b

shell中的整数运算
方法一:
expr 值1  +  值2            //加法,值可以用常量,也可以用变量
expr 值1  -  值2            //减法
expr 值1  \*  值2  		//乘号需要用\转义
expr 值1  /  值2            //除法
expr 值1  %  值2            //求模,值1除以值2,然后取余数
方法二:
echo $[值1+值2]
echo $[值1-值2]
echo $[值1*值2]
echo $[值1/值2]
echo $[值1%值2]
方法三: 通常对变量进行计算,并且可以改变变量的值,不显示结果,尽量使用主流用法
变量a的自增减
let a++    //a=a+1
let a--    //a=a-1
let a*=10   //a=a*10

定义新变量b
let b=a+10

echo $a

小数运算
使用bc工具
echo "1+1"  | bc     //非交互式利用bc工具
echo "1+1.1"  | bc     //利用bc计算小数
echo "scale=3;10/3"  | bc     //定义小数点后面位数








shell22222222222



1,解释器声明
2,脚本功能,变量含义,使用位置
3,执行的指令

自定义变量
环境变量 HOME  USER  PWD  UID  HOSTNAME  SHELL PS1 PS2,预定义变量 $0  $$  $#  $?  $*
位置变量$1 $2 $3 ...

''
""
``  $()
read -p   
stty -echo
stty  echo
export a=10

1, expr 1 + 1
	expr 2 \* 2
2,echo $[1+1]
echo $[a+b]
3,let a++
	let a--
	let a+=10
4,bc
	echo "1+1" | bc
	echo "scale=3;10/3" | bc



条件测试,对某些环境进行预判断,增加脚本灵活与成功率
使用方法有两种,  test 表达式   或   [ 表达式 ]

一,字符串
test abc == abc      //对比==两边的字符串是否相同,相同返回0
[ abc == 123 ]    //使用常量测试结果
echo $?      //测试结果成功返回0, 失败返回非0

test abc != abc  	//对比!=两边的字符串是否不相同,不相同才返回0
[ abc != 123 ]    //使用第二种方法

&&    前面命令成功后才执行后面命令    和
||      前面命令失败后才执行后面命令     或
;	前面命令执行后再执行后面命令,无逻辑关系

#!/bin/bash
read -p "请输入用户名"  u
[ -z $u ] && exit		//当用户没有输入用户名直接回车后,变量u是空值, 则 [ -z $u ] 测试成功, 然后执行&&后面的exit退出脚本 ,如果用户输入用户名,则不执行exit
useradd $u

改良版
#!/bin/bash
read -p "请输入用户名"  u
[ -z $u ] && echo "你没输入名字!" && exit
useradd $u

二 数字

-eq  等于
-ne  不等于
-gt  大于
-ge  大于等于
-lt  小于
-le  小于等于

X=20    //定义一个测试变量
[ $X -eq 20 ] && echo "相等" || echo "不相等"
相等
[ $X -ne 30 ] && echo "不等于" || echo "等于"
不等于
[ $X -gt 10 ] && echo "大于" || echo "否"
大于
[ $X -ge 10 ] && echo "大于或等于" || echo "否"
大于或等于
[ $X -lt 10 ] && echo "小于" || echo "否"
否
[ $X -le 10 ] && echo "小于或等于" || echo "否"
否
编写增加系统安全的脚本:
要求每2分钟检查服务器登录人数,如果超过3个人登录,就给管理员发报警邮件

#!/bin/bash
n=`who | wc -l`
[ $n -ge 3 ] &&  echo "有$n人登录服务器啦"  | mail -s test root

-ge 大于等于
-gt 大于

crontab -e
*/2 * * * *  /opt/test2.sh         //使用计划任务每2分钟执行一次脚本,脚本不要忘记加x权限     

三  ,文件 
[ -e abc ]    //测试abc文件是否存在,存在则返回0, 不在乎文件类型  
[ -d abc ]    //测试abc是否存在且是目录,成功则返回0
[ -f abc ]    //测试abc是否存在且是文件,成功则返回0

[ -r abc ]    //测试文件是否对当前用户有读权限,有则返回0
[ -w abc ]    //测试文件是否对当前用户有写权限,有则返回0
[ -x abc ]    //测试文件是否对当前用户有执行权限,有则返回0

==   !=   -z   ! -z   -eq  -ne  -gt  -ge  -lt  -le

&&     ||   

if判断

单分支
if 条件测试   ;then
	命令序列
fi

编写脚本,判断当前目录下是否有文件abc,如果没有则创建,如果有则不做任何动作
#!/bin/bash
if [ ! -e abc ] ;then      //条件测试文件abc不存在的话是成功
	touch abc			//条件测试成功则执行touch任务
fi

 

双分支
if 条件测试  ;then
	命令序列1
else
	命令序列2
fi

编写脚本,测试与某个ip的网络状况, ping通则返回"通了",否则返回"不通"
#!/bin/bash
ping -c 3  -i 0.2  -W 1   $1  &> /dev/null
if [ $? -eq 0 ]  ;then
	echo "通了"
else
	echo "不通"
fi


ping  -c 限定次数   -i 限定ping间隔时间  -W 等待反馈时间
ping -c 3  -i 0.2  -W 1   172.25.0.100



多分支
if 条件测试  ;then
	命令序列1
elif 条件测试 ;then
	命令序列2
else
	命令序列3
fi

使用多分支,编写猜数脚本
#!/bin/bash
a=$[RANDOM%11]   //使用随机数定义变量a,a的范围是0~10
read -p "请输入一个数字(0~10)"  s
if [ $a -eq $s ]  ;then   //随机数与用户提供的数相等则猜对
	echo "猜对了!"
elif [ $s -gt $a ] ;then
	echo "猜大了"
else
	echo "猜小了"
fi

for循环,主要关注循环次数和循环的变量


for i in 值1  值2
do
	echo $i
done

使用for循环编写测试某范围主机的脚本,最后统计情况
#!/bin/bash
a=0
b=0
for i in {1..12}
do
    ping -c 3 -i 0.2 -W 1 172.25.0.$i &> /dev/null
    if [ $? -eq 0 ];then
        echo "172.25.0.${i}ok"
        let a++
    else
        echo "172.25.0.${i}no"
        let b++
    fi
done
echo " ${a}台ok,${b}台no"



while  条件测试
do
    命令序列
#!/bin/bash

while  [ 1 -eq 1 ]
do
    echo  abc
	sleep 0.1
done

while不小心就会写成死循环,并耗尽cpu资源,使用sleep可以避免

使用while编写脚本,猜0~100之间的数,直到猜对为止,猜对后统计猜的次数
#!/bin/bash
a=$[RANDOM%101]
b=0
while :
do
	let b++			//每猜一次,b就+1
	read -p "请输入数字(0~100)"  s
	if [ $a -eq $s ]  ;then
		echo "猜对了,猜了${b}次"
		exit		
	elif [ $s -gt $a ]   ;then
		echo "猜大了"
	else
		echo "猜小了"
	fi	
done












shell333333333333333333333333


字符串
test    [   ]
==    !=     -z    ! -z
数字
-eq  -ne  -gt  -ge  -lt  -le
文件
-e  -d  -f   -r  -w  -x

单分支       &&     ||
双分支
多分支
if 条件测试  ;then
	命令序列1
elif 条件测试 ;then
	命令序列2
else
	命令序列3
fi

for i in 值1 值2
do
done

while :
do
done


case分支,简化版本的if,某些情况比if简洁,但功能不如if强大
基本语法格式:
使用case分支编写使用nginx服务的工具
#!/bin/bash
case  $1  in
start|sta)
     /usr/local/nginx/sbin/nginx ;;
stop|o)
     /usr/local/nginx/sbin/nginx -s stop ;;
restart|re)
	 /usr/local/nginx/sbin/nginx -s stop
	 /usr/local/nginx/sbin/nginx ;;
status|u)
	 netstat -ntulp | grep -q nginx
	  [  $? -eq 0  ]&& echo "启动了" || echo "没启动" ;;
*)
	echo "start|stop|restart|status";;
esac



思考题:
两个文本里面各写了用户名和密码
要求写个脚本,可以自动创建这些账户并配置密码
提示:
1,可以用for循环
2,提取第2行可以用head -2 /etc/passwd | tail -1

文本 a里面有100个账户名
zhangsan
lisi
wangwu
...
文本 b里面有100个密码
123
345
789
...
#!/bin/bash
n=0
for i in `cat /opt/a`
do
	useradd $i
	let n++
	p=`head -$n /opt/b | tail -1`
	echo $p | passwd --stdin $i 
done	

===================================


编写一键安装nginx的脚本:
#!/bin/bash
yum -y install gcc openssl-devel pcre-devel    //安装依赖包
tar -xf nginx-1.12.2.tar.gz    //释放tar包
cd nginx-1.12.2     //进入目录
./configure      //进行源代码安装
make
make install
写完脚本后运行, 系统自动执行nginx的安装
安装完毕后输入 /usr/local/nginx/sbin/nginx  即可开启web服务
然后使用  netstat  -ntulp  | grep  nginx  查看结果,看到80端口开启监听则成功

shell函数
将多组指令定义为一个函数名,脚本中可以反复使用函数名调用这些指令,达到精简脚本的目的

格式1：
function  函数名 {
        命令序列
        .. ..
    }

格式2：
 函数名() {
        命令序列
        .. ..
    }

cecho(){
echo -e "\033[$1m$2\033[0m"
}

cecho 31 ABCDEFG
cecho 32 ABCDEFG
cecho 33 ABCDEFG
cecho 34 ABCDEFG


中断和退出

exit      //退出整个脚本
break     //退出脚本中的循环,执行循环后的任务
continue   //退出当前循环,进行下一次循环

编写整数求和脚本,让用户输入的数字得出总和,用户输入0为结束

#!/bin/bash
x=0
while :
do
	read -p "输入一个整数(0是结束)"   n
	[ $n -eq 0 ] && break
	let x+=n
done
echo "总和是$x"


编写脚本文件，找出1-20内6的倍数，并打印她的平方值
#!/bin/bash
for i in {1..20}
do
n=$[i%6]      //n是余数,余数是0说明是6的倍数
[ $n -ne 0 ] && continue   //如果余数是0,则不运行continue
echo $[i*i]		//将所有6的倍数求平方
done
子串截取的用法：
${变量名:起始位置:长度}
编写获取8位随机字符脚本
#!/bin/bash
pass1=       //定义最终结果,目前是空
x=abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789
for i in {1..8}
do
s=$[RANDOM%62]
pass=${x:s:1}		//得出一个随机字符
pass1=$pass1$pass    //累加到pass1上面,每次循环都把随机到的字符累加,最终得到8位
done
echo $pass1    //显示最终结果

字符串替换

${x/old/new}    //替换一个
${x//old/new}    //替换所有

字符串的删除
1, 从左往右删    掐头
echo ${a#root}     //从左往右删除第一个root
echo ${a#*:}	 //从左往右删除第一个冒号,以及冒号左边所有
echo ${a##*:}    //从左往右删除最后一个冒号,以及冒号左边所有

2, 从右往左删    去尾
echo ${a%bash}     //从右往左删除第一个bash
echo ${a%:*}	 //从右往左删除第一个冒号,以及冒号右边所有
echo ${a%%:*}    //从右往左删除最后一个冒号,以及冒号右边所有


编写批量修改扩展名的脚本 ,将所有.txt文件改为.doc
#!/bin/bash
for i in `ls *.txt`   //找到所有.txt的文件,传递给for循环的变量
do
	m=${i%.*}      //第1次循环,将第1个文件的扩展名去掉,得到纯文件名
	mv $i $m.doc   //使用mv命令将文件修改为.doc结尾
done

改良版
#!/bin/bash
for i in `ls *.$1`   //找到所有扩展名是$1的文件,传递给for循环的变量
do
	m=${i%.*}      //第1次循环,将第1个文件的扩展名去掉,得到纯文件名
	mv $i $m.$2   //使用mv命令将文件修改为$2结尾
done








shell 55555555555

[student@room12pc59 ~]$ echo -e "hello\tworld"
hello	world
[student@room12pc59 ~]$ echo -e "hello\nworld"
hello
world



[root@server0 ~]# sed -n '2,4p'  /etc/passwd          #查第2到第4的行
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin



[root@server0 ~]# sed -n '2,/^adm/p'  /etc/passwd       #查第2到adm开头的行（数字与字符混合使用）
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin


[root@server0 ~]# sed -n 'p'  /etc/passwd
[root@server0 ~]# sed -n   '.*p'  /etc/passwd            ＃这3种方法一样都是显示所有
[root@server0 ~]# sed  ''  /etc/passwd

[root@server0 ~]# sed  '＝‘ /etc/passwd                  ＃加行号显示
[root@server0 ~]# sed  '$＝‘ /etc/passwd                 #显示最后一行
[root@server0 ~]# sed -n   '='  /etc/passwd            ＃只显示行号，不显示内容



[root@server0 ~]# sed -n '${=;p}'  /etc/passwd         ＃打印最后一行的编号与内容
51
jj:x:1012:1012::/home/jj:/bin/bash



[root@server0 ~]# echo 123456 | rev                   ＃左右倒过来显示
654321

[root@server0 ~]# tac /etc/passwd                     ＃行的排列上下倒过来显示






＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃
[root@server0 ~]# seq 9 >  p.txt                       ＃1到9竖着列出来
[root@server0 ~]# cat p.txt
1
2
3
4
5
6
7
8
9

＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃




[root@server0 ~]# sed -n  '/bash$/p'  /etc/passwd     ＃提取以bash结尾的行
[root@server0 ~]# sed 's/:.*//' /etc/passwd           ＃提取用户名
[root@server0 ~]# sed   -n  '/bash$/s/:.*//p' /etc/passwd     ＃以上两种的结合
[root@server0 ~]# sed -n '/bash/p'  /etc/passwd    |  sed  's/:.*//'   ＃用管道小王子的方式实现

[root@server0 ~]# sed -rn 's/([^:]+:)([^:]+).*/\1\2/p' /etc/shadow     ＃提取/etc/shadow中的密码段

 
[root@server0 ~]# cat /etc/shadow | while read abc;do echo ${abc}; done
[root@server0 ~]# sed -rn 's/([^:]+):([^:]+).*/\1-->\2/p' /etc/shadow






















6666666666666666shell

     
[root@server0 ~]# awk -F: 'BEGIN{print "User","UID","Home"}{print $1,$3,$6}'  /etc/passwd | column -t       ＃column -t 这个命令使输出对齐


awk的格式写法
awk  	‘[条件]{表达式}’
awk    

[root@server0 ~]# awk -F: '$4~/0/{print $4}'  /etc/passwd     ＃在第4列的只要有匹配0的行中，输出第4列的内容
[root@server0 ~]# awk -F: '$4！~/0/{print $4}'  /etc/passwd     取反＃在第4列的只要没有匹配0的行中，输出第4列的内容




 awk -F: '{if($3>1000){i++}}END{print i}' /etc/passwd












6666666666666666shell

     
]# awk -F: 'BEGIN{print "User","UID","Home"}{print $1,$3,$6}'  /etc/passwd | column -t       
＃column -t 这个命令使输出对齐


awk的格式写法
awk  	‘[条件]{表达式}’
awk    

]# awk -F: '$4~/0/{print $4}'  /etc/passwd     ＃在第4列的只要有匹配0的行中，输出第4列的内容
]# awk -F: '$4！~/0/{print $4}'  /etc/passwd     ＃取反＃在第4列的只要没有匹配0的行中，输出第4列的内容
]# awk '{A[$1]++}END{for (i in  A) print A[i],i}'  /var/log/httpd/access_log  | sort -n
                                                                                  ＃统计httpd受访问的数量与ip排列
查进程     只看（o＝only）    内存，cpu，命令名   
ps       -eo              %mem,%cpu,ucmd
统计占用内存最多的程序 （工作环境很多时候能用得上这个命令）    （sort -n 这个命令使输出的前面数字由小到大向下排，sort -rn相反）
]# ps -eo %mem,%cpu,ucmd |  awk '{A[$3]+=$1}END{for (i in A)print A[i],i}' |sort -n

统计占用cpu最多的程序  （工作环境很多时候能用得上这个命令）
]# ps -eo %mem,%cpu,ucmd |  awk '{A[$2]+=$2}END{for (i in A)print A[i],i}' |sort -n





＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃
编写监控脚本
[root@server0 ~]# uptime                      1分钟   5分钟  15分钟  的CPU负载
 16:55:06 up  7:48,  3 users,  load average: 0.00, 0.01, 0.05
[1]+  完成                  firefox 172.25.0.11

cpu负载    uptime
网卡流量   ifconfig （RX p）
内存剩余容量   free
磁盘剩余容量   df
计算机帐户数量 /etc/passwd
当前登录户数量 who
计算机当前开启的进程数量 ps axu
本机已安装的软件包数量   rpm －qa



#!/bin/bash
uptime | awk '{print "cpu负载的1，5，15分钟的数据分别是:",$(NF-2),$(NF-1),$(NF)}'
ifconfig eth0 | awk '/RX p/{print "网卡流量为："  $(NF-2),$(NF-1),$(NF)}'
free | awk '/M/{print "内存剩余容量为：",$4}'
df | awk '/\/$/{print "磁盘剩余容量为：",$4}'
awk -F: '{if($3>=0){i++}}END{print "计算机帐户数量为：",i}' /etc/passwd
who | awk '{if(NF=5){i++}}END{print "当前登录帐户数量为：",(i-1)}'
ps axu | awk '{if($2>1){i++}}END{print "计算机当前开启的进程数量为：",i}'
rpm -qa | awk '{if($1!=1){i++}}END{print "本机已安装的软件包数量为：",i}'


＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃


扩展补充0.5秒的计时器

#!/bin/bash
for i in {0..99}
do
	echo -ne "id: ${i}\r"
	sleep 0.5
done
＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃
进度条
#!/bib/bash
astr="|-->"
for i in {0..60};do
        echo -ne "\033[65G${i}%"
        echo -ne "\033[${i}G${astr}"
        sleep 0.2
done 


####################################################################################################
awk处理条件

步骤一：认识awk处理条件的设置


1）使用正则设置条件
]# awk -F: '/bash$/{print}' /etc/passwd                    输出其中以bash结尾的完整记录      
]# awk -F: '/root/' /etc/passwd                            输出包含root的行数据
]# awk -F: '/^(root|adm)/{print $1,$3}' /etc/passwd        输出root或adm账户的用户名和UID信息
]# awk -F: '$1~/root/' /etc/passwd                         输出账户名称包含root的基本信息（第1列包含root）
]# awk -F: '$7!~/nologin$/{print $1,$7}' /etc/passwd       输出其中登录Shell不以nologin结尾（对第7个字段做!~反向匹配）的用户名、登录Shell信息

2）使用数值/字符串比较设置条件
比较符号：==(等于) !=（不等于） >（大于）
>=（大于等于） <（小于） <=（小于等于）
                                                                                           
]# awk -F: 'NR==3{print}' /etc/passwd                输出第3行（行号NR等于3）的用户记录                      
]# awk -F: '$3>=1000{print $1,$3}' /etc/passwd       输出账户UID大于等于1000的账户名称和UID信息
]# awk -F: '$3<10{print $1,$3}' /etc/passwd          输出账户UID小于10的账户名称和UID信息

3）逻辑测试条件
]# awk -F: '$3>10 && $3<20' /etc/passwd             输出账户UID大于10并且小于20的账户信息
]# awk -F: '$3>1000 || $3<10' /etc/passwd           输出账户UID大于1000或者账户UID小于10的账户信息

4）数学运算
]# awk 'BEGIN{x++;print x}'       默认x为0，自增1后的输出为1
]# awk 'BEGIN{x=8;print x+=2}'    定义x为8，自增2后的输出为10
]# awk 'BEGIN{x=8;x--;print x}'   定义x为8，自减1后的输出为7
]# awk 'BEGIN{print 2+3}'         直接打印2+3，输出为5
]# awk 'BEGIN{print 2*3}'         直接打印2*3，输出为6
]# awk 'BEGIN{ print 23%8}'       直接打印23％8，输出为7

































克隆机：clone-vm7



为明天的课程4台虚拟机（克隆新的虚拟机）
主机名		IP地址
client	etho：192.168.4.10/24   
 ＃hostnamectl set-hostname client
 ＃nmcli connection modify eth0 ipv4.method  manual ipv4.addresses  192.168.4.10/24 connection.autoconnect yes
 ＃nmcli connection up eth0

proxy		eth0：192.168.4.5/24
             eth1：192.168.2.5/24

 ＃hostnamectl set-hostname proxy
 ＃nmcli connection modify eth0 ipv4.method  manual ipv4.addresses  192.168.4.5/24 connection.autoconnect yes
 ＃nmcli connection up eth0
 ＃nmcli connection modify eth1 ipv4.method  manual ipv4.addresses  192.168.2.5/24 connection.autoconnect yes
 ＃nmcli connection up eth1



web1		eth1：192.168.2.100/24
 ＃hostnamectl set-hostname web1
 ＃nmcli connection modify eth1 ipv4.method  manual ipv4.addresses  192.168.2.100/24 connection.autoconnect yes
 ＃nmcli connection up eth1


web2		eth1：192.168.2.200/24 
 ＃hostnamectl set-hostname web2
 ＃nmcli connection modify eth1 ipv4.method  manual ipv4.addresses  192.168.2.200/24 connection.autoconnect yes
 ＃nmcli connection up eth1


            
alias gocl='ssh -X root@192.168.4.10'
alias gopr='ssh -X root@192.168.4.5'
alias gow='ssh -X root@192.168.2.100'
alias gowe='ssh -X root@192.168.2.200'






                                    





172.40.50.118:8


[root@proxy ~]# md5sum lnmp_soft.tar.gz 
87f559d57dc20ae9f6cd4391804b09e1  lnmp_soft.tar.gz
[root@proxy ~]# tar -xf lnmp_soft.tar.gz


官方网站『文档』安装
nginx软件是模块化设计的软件
现代化的软件都是模块的
100功能
./configure 


安全：策略都是针寻用户和组
QQ程序－－－－》读文件「c：\       /etc/」
QQ程序－－－－》写文件「c：\       /etc/」
谁启动的QQ  超级管理员－－》启动QQ（继承权限）
 root-->httpd(nginx)----客访问
useradd  nginx
root执行
     

＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃


nginx 配置
修改/usr/local/nginx/conf/nginx.conf
server {
        listen       80;
        server_name  localhost;                域名
        auth_basic "Input Password:";                        //认证提示符信息
        auth_basic_user_file "/usr/local/nginx/pass";        //认证的密码文件  "/usr/local/nginx/pass"加双引号就是要绝对路，不加就是相对的。
        location / {
            root   html;                      网站路径
            index  index.html index.htm;      默认首页
        }
  }

＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃
 conf 
html 
logs
sbin



http 协议是明文协议
http+ssl＝https

＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃
1版本老旧，需要升级
2.
/usr/local/nginx/xbin/nginx(1.10)
/root/lnmp_soft/nginx-1.12/

安装nginx-1.10.3版本时，需要使用如下参数：
--with-http_ssl_module：提供SSL加密功能
--user：指定账户
--group：指定组
步骤一：构建Nginx服务器















Top
NSD Operation DAY01

案例1：搭建Nginx服务器
案例2：用户认证
案例3：基于域名的虚拟主机
案例4：SSL虚拟主机
1 案例1：搭建Nginx服务器
1.1 问题

在IP地址为192.168.4.5的主机上安装部署Nginx服务，并可以将Nginx服务器，要求编译时启用如下功能：
支持SSL加密功能
设置Nginx账户及组名称均为nginx
Nginx服务器升级到更高版本。
然后客户端访问页面验证Nginx Web服务器：
使用火狐浏览器访问
使用curl访问
1.2 方案

提前准备运维课程所需的所有虚拟机，为后续所有实验做准备，克隆4台RHEL7虚拟机，实验环境所需要的主机及对应的IP设置列表如表-1所示，正确配置IP地址、主机名称，并且为每台主机配置YUM源。不需要配置网关与DNS。
表－1 主机列表

第一天课程需要使用2台RHEL7虚拟机，其中一台作为Nginx服务器（192.168.4.5）、另外一台作为测试用的Linux客户机（192.168.4.10），如图-1所示。

图-1
安装nginx-1.10.3版本时，需要使用如下参数：
--with-http_ssl_module：提供SSL加密功能
--user：指定账户
--group：指定组
1.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：构建Nginx服务器

1）使用源码包安装nginx软件包
[root@proxy ~]# yum -y install gcc pcre-devel openssl-devel        //安装依赖包
[root@proxy ~]# useradd -s /sbin/nologin nginx
[root@proxy ~]# tar  -xf   nginx-1.10.3.tar.gz
[root@proxy ~]# cd  nginx-1.10.3
[root@proxy nginx-1.10.3]# ./configure   \
> --prefix=/usr/local/nginx   \                //指定安装路径
> --user=nginx   \                            //指定用户
> --group=nginx  \                            //指定组
> --with-http_ssl_module                        //开启SSL加密功能
[root@proxy nginx-1.10.3]# make && make install    //编译并安装
2）nginx命令的用法
[root@proxy ~]# /usr/local/nginx/sbin/nginx                    //启动服务
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s stop            //关闭服务
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload        //重新加载配置文件
[root@proxy ~]# /usr/local/nginx/sbin/nginx -V                //查看软件信息
[root@proxy ~]# ln -s /usr/local/nginx/sbin/nginx /sbin/        //方便后期使用
netstat命令可以查看系统中启动的端口信息，该命令常用选项如下：
-a显示所有端口的信息
-n以数字格式显示端口号
-t显示TCP连接的端口
-u显示UDP连接的端口
-l显示服务正在监听的端口信息，如httpd启动后，会一直监听80端口
-p显示监听端口的服务名称是什么（也就是程序名称）
nginx服务默认通过TCP 80端口监听客户端请求：
root@proxy ~]# netstat  -anptu  |  grep nginx
tcp        0        0 0.0.0.0:80        0.0.0.0:*        LISTEN        10441/nginx
3）设置防火墙与SELinux（非必须的操作，如果有则关闭）
[root@proxy ~]# systemctl stop firewalld
[root@proxy ~]# setenforce 0
4）测试首页文件
Nginx Web服务默认首页文档存储目录为/usr/local/nginx/html/，在此目录下默认有一个名为index.html的文件，使用客户端访问测试页面：
[root@client ~]# curl http://192.168.4.5
<html>
<head>
<title>Welcome to nginx!</title>
</head>
<body bgcolor="white" text="black">
<center><h1>Welcome to nginx!</h1></center>
</body>
</html>
步骤二：升级Nginx服务器

1）编译新版本nginx软件
[root@proxy ~]# tar  -zxvf   nginx-1.12.2.tar.gz
[root@proxy ~]# cd nginx-1.12.2
[root@proxy nginx-1.12.2]# ./configure   \
> --prefix=/usr/local/nginx   \ 
> --user=nginx   \ 
> --group=nginx  \ 
> --with-http_ssl_module
[root@proxy nginx-1.12.2]# make            
2) 备份老的nginx主程序，并使用编译好的新版本nginx替换老版本
[root@proxy nginx-1.12.2]# mv /usr/local/nginx/sbin/nginx  \
>/usr/local/nginx/sbin/nginxold
[root@proxy nginx-1.12.2]# cp objs/nginx  /usr/local/nginx/sbin/         //拷贝新版本
[root@proxy nginx-1.12.2]# make upgrade                            //升级
#或者使用killall nginx杀死进程后再启动nginx。
/usr/local/nginx/sbin/nginx -t
nginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok
nginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful
kill -USR2 `cat /usr/local/nginx/logs/nginx.pid`
sleep 1
test -f /usr/local/nginx/logs/nginx.pid.oldbin
kill -QUIT `cat /usr/local/nginx/logs/nginx.pid.oldbin`
[root@proxy ~]# /usr/local/nginx/sbin/nginx –v                //查看版本
步骤三：客户端访问测试

1）分别使用浏览器和命令行工具curl测试服务器页面
如果使用firefox火狐浏览器，注意在ssh远程的时候一定要加-X选项。
[root@client ~]# firefox http://192.168.4.5
[root@client ~]# curl http://192.168.4.5
2 案例2：用户认证
2.1 问题

沿用练习一，通过调整Nginx服务端配置，实现以下目标：
访问Web页面需要进行用户认证
用户名为：tom，密码为：123456
2.2 方案

通过Nginx实现Web页面的认证，需要修改Nginx配置文件，在配置文件中添加auth语句实现用户认证。最后使用htpasswd命令创建用户及密码即可。
2.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：修改Nginx配置文件

1）修改/usr/local/nginx/conf/nginx.conf
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
.. ..
server {
        listen       80;
        server_name  localhost;
        auth_basic "Input Password:";                        //认证提示符信息
        auth_basic_user_file "/usr/local/nginx/pass";        //认证的密码文件
        location / {
            root   html;
            index  index.html index.htm;
        }
  }
2）生成密码文件，创建用户及密码
使用htpasswd命令创建账户文件，需要确保系统中已经安装了httpd-tools。
[root@proxy ~]# yum -y install  httpd-tools
[root@proxy ~]# htpasswd -c /usr/local/nginx/pass   tom        //创建密码文件
New password: 
Re-type new password: 
Adding password for user tom
[root@proxy ~]# htpasswd  /usr/local/nginx/pass   jerry      //追加用户，不使用-c选项
New password: 
Re-type new password: 
Adding password for user jerry
[root@proxy ~]# cat /usr/local/nginx/pass
3）重启Nginx服务
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload    //重新加载配置文件    
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
#[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)
步骤二：客户端测试

1）登录192.168.4.10客户端主机进行测试
如果使用firefox火狐浏览器，注意在ssh远程的时候一定要加-X选项。
或者直接使用真实主机的火狐也可以。
[root@client ~]# firefox http://192.168.4.5                    //输入密码后可以访问
3 案例3：基于域名的虚拟主机
3.1 问题

沿用练习二，配置基于域名的虚拟主机，实现以下目标：
实现两个基于域名的虚拟主机，域名分别为www.a.com和www.b.com
对域名为www.a.com的站点进行用户认证，用户名称为tom，密码为123456
3.2 方案

修改Nginx配置文件，添加server容器实现虚拟主机功能；对于需要进行用户认证的虚拟主机添加auth认证语句。
虚拟主机一般可用分为：基于域名、基于IP和基于端口的虚拟主机。
3.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：修改配置文件

1）修改Nginx服务配置，添加相关虚拟主机配置如下
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
.. ..
server {
        listen       80;                                      //端口
        server_name  www.a.com;                                //域名
auth_basic "Input Password:";                        //认证提示符
        auth_basic_user_file "/usr/local/nginx/pass";        //认证密码文件
location / {
            root   html;                                    //指定网站根路径
            index  index.html index.htm;
       }
       
}
… …
    server {
        listen  80;                                        //端口
        server_name  www.b.com;                                //域名
location / { 
root   www;                                 //指定网站根路径
index  index.html index.htm;
}
}
2）创建网站根目录及对应首页文件
[root@proxy ~]# mkdir /usr/local/nginx/www
[root@proxy ~]# echo "www" > /usr/local/nginx/www/index.html
3）重启nginx服务
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
#[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)
步骤二：客户端测试

1）修改客户端主机192.168.4.10的/etc/hosts文件，进行域名解析
 [root@client ~]# vim /etc/hosts
192.168.4.5    www.a.com  www.b.com
2）登录192.168.4.10客户端主机进行测试
注意：请先关闭真实机的firefox，再SSH -X远程连接调用虚拟机的firefox。
[root@client ~]# firefox http://www.a.com            //输入密码后可以访问
[root@client ~]# firefox http://www.b.com            //直接访问
提示：或者直接使用真实主机做客户端主机验证，修改真实主机的/etc/hosts文件，直接使用真实主机的火狐浏览器访问也可以。
步骤三：扩展课外实验：其他类型的虚拟主机

1.基于端口的虚拟主机（参考模板）
server {
        listen       8080;                        //端口
        server_name  web1.example.com;          //域名
        ......
}
    server {
        listen       8000;                         //端口
        server_name  web1.example.com;           //域名
      .......
}
2.基于IP的虚拟主机（参考模板）
server {
        listen       192.168.0.1:80;              //IP地址与端口
        server_name  web1.example.com;          //域名
  ... ...
}
    server {
        listen       192.168.0.2:80;             //IP地址与端口
        server_name  web1.example.com;
... ...
}
4 案例4：SSL虚拟主机
4.1 问题

沿用练习三，配置基于加密网站的虚拟主机，实现以下目标：
域名为www.c.com
该站点通过https访问
通过私钥、证书对该站点所有数据加密
4.2 方案

源码安装Nginx时必须使用--with-http_ssl_module参数，启用加密模块，对于需要进行SSL加密处理的站点添加ssl相关指令（设置网站需要的私钥和证书）。
加密算法一般分为对称算法、非对称算法、信息摘要。
对称算法有：AES、DES，主要应用在单机数据加密。    「算法安全，工作原理不太安全」（暴力，枚举）
非对称算法有：RSA、DSA，主要应用在网络数据加密。   特点：私钥，公钥
信息摘要：MD5、sha256，主要应用在数据完整性校验。 MD5＝md5sum （md5sum a。txt）   校验码只与文件内容有关，用来验被黑后的文件内容有没有改变。
＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃
for in  'ls /etc/*conf'
do
	md5sum $i > /a.txt
done









4.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：配置SSL虚拟主机
1）生成私钥与证书
[root@proxy ~]# cd /usr/local/nginx/conf
[root@proxy ~]# openssl genrsa > cert.key                            //生成私钥
[root@proxy ~]# openssl req -new -x509 -key cert.key > cert.pem      //生成证书
2）修改Nginx配置文件，设置加密网站的虚拟主机
[root@proxy ~]# vim  /usr/local/nginx/conf/nginx.conf
… …    
server {
        listen       443 ssl;
        server_name            www.c.com;
        ssl_certificate      cert.pem;         #这里是证书文件
        ssl_certificate_key  cert.key;         #这里是私钥文件
        ssl_session_cache    shared:SSL:1m;
        ssl_session_timeout  5m;
        ssl_ciphers  HIGH:!aNULL:!MD5;
        ssl_prefer_server_ciphers  on;
        location / {
            root   html;
            index  index.html index.htm;
        }
    }
3）重启nginx服务
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
#[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)
步骤二：客户端验证
1）修改客户端主机192.168.4.10的/etc/hosts文件，进行域名解析
[root@client ~]# vim /etc/hosts
192.168.4.5    www.c.com  www.a.com   www.b.com
2）登录192.168.4.10客户端主机进行测试
[root@client ~]# firefox https://www.c.com            //信任证书后可以访问










＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃




什么是动态页面
静态，动态
   静态（jpg，doc，mp3，mp4，pdf，ppt，gif。。。。）

   动态（java，php，py，sh。。。。）代码要在网页运行一次的










Top
NSD OPERATION DAY02

案例1：部署LNMP环境
案例2：构建LNMP平台
案例3：地址重写
1 案例1：部署LNMP环境
1.1 问题

安装部署Nginx、MariaDB、PHP环境
安装部署Nginx、MariaDB、PHP、PHP-FPM；
启动Nginx、MariaDB、FPM服务；
并测试LNMP是否工作正常。
1.2 方案

LNMP（Linux、Nginx、MySQL、PHP）
在RHEL7系统中，源码安装Nginx，使用RPM包安装MariaDB、PHP、PHP-FPM软件。
操作过程中需要安装的软件列表如下：
nginx
mariadb、mariadb-server、mariadb-devel
php、php-fpm、php-mysql
备注：mariadb（数据库客户端软件）、mariadb-server（数据库服务器软件）、mariadb-devel（其他客户端软件的依赖包）、php（解释器）、php-fpm（进程管理器服务）、php-mysql（PHP的数据库扩展包）。
1.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：安装软件

1）使用yum安装基础依赖包
[root@proxy ~]# yum -y install gcc openssl-devel pcre-devel
2）源码安装Nginx（如果前面课程中已经安装Nginx，则忽略这一步）
[root@proxy ~]# useradd -s /sbin/nologin  nginx
[root@proxy ~]# tar -xvf nginx-1.12.2.tar.gz
[root@proxy ~]# cd nginx-1.12.2
[root@proxy nginx-1.12.2]# ./configure   \
> --user=nginx   --group=nginx \
> --with-http_ssl_module
[root@proxy ~]# make && make install
.. ..
3）安装MariaDB
Mariadb在新版RHEL7光盘中包含有该软件，配置yum源后可以直接使用yum安装：
[root@proxy ~]# yum -y install   mariadb   mariadb-server   mariadb-devel
4）php和php-fpm
[root@proxy ~]# yum -y  install  php   php-mysql
[root@proxy ~]# yum -y  install php-fpm
步骤二：启动服务

1）启动Nginx服务（如果已经启动nginx，则可以忽略这一步）
这里需要注意的是，如果服务器上已经启动了其他监听80端口的服务软件（如httpd），则需要先关闭该服务，否则会出现冲突。
[root@proxy ~]# systemctl stop httpd                //如果该服务存在则关闭该服务
[root@proxy ~]# /usr/local/nginx/sbin/nginx             //启动Nginx服务
[root@proxy ~]# netstat -utnlp | grep :80
tcp    0    0 0.0.0.0:80        0.0.0.0:*        LISTEN        32428/nginx         
2）启动MySQL服务
[root@proxy ~]# systemctl start  mariadb           //启动服务器
[root@proxy ~]# systemctl status mariadb           //查看服务状态
[root@proxy ~]# systemctl enable mariadb           //设置开机启动
3）启动PHP-FPM服务
[root@proxy ~]# systemctl start php-fpm           //启动服务
[root@proxy ~]# systemctl status php-fpm          //查看服务状态
[root@proxy ~]# systemctl enable php-fpm          //设置开机启动
2 案例2：构建LNMP平台
2.1 问题

沿用练习一，通过调整Nginx服务端配置，实现以下目标：
配置Fast-CGI支持PHP网页
创建PHP测试页面，测试使用PHP连接数据库的效果
2.2 方案

使用2台RHEL7虚拟机，其中一台作为LNMP服务器（192.168.4.5）、另外一台作为测试用的Linux客户机（192.168.4.10），如图-1所示。

图-1
Nginx结合FastCGI技术即可支持PHP页面架构，如图-2所示。

图-2
因此本案例，需要延续练习一的实验内容，通过修改Nginx及php-fpm配置文件实现对PHP页面的支持。
注意，FastCGI的内存消耗问题，一个PHP-FPM解释器将消耗约25M的内存。
2.3 步骤

实现此案例需要按照如下步骤进行。
步骤一： php-fpm配置文件

1）查看php-fpm配置文件（实验中不需要修改该文件）
[root@proxy etc]# vim /etc/php-fpm.d/www.conf
[www]
listen = 127.0.0.1:9000            //PHP端口号
pm.max_children = 32                //最大进程数量
pm.start_servers = 15                //最小进程数量
pm.min_spare_servers = 5            //最少需要几个空闲着的进程
pm.max_spare_servers = 32            //最多允许几个进程处于空闲状态
步骤二：修改Nginx配置文件并启动服务

[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
location / {
            root   html;
            index  index.php  index.html   index.htm;
#设置默认首页为index.php，当用户在浏览器地址栏中只写域名或IP，不说访问什么页面时，服务器会把默认首页index.php返回给用户
        }
 location  ~  \.php$  {
            root           html;
            fastcgi_pass   127.0.0.1:9000;    #将请求转发给本机9000端口，PHP解释器
            fastcgi_index  index.php;
            #fastcgi_param   SCRIPT_FILENAME  $document_root$fastcgi_script_name;
            include        fastcgi.conf;       #加载其他配置文件
        }
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
#[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)
步骤三：创建PHP页面，测试LNMP架构能否解析PHP页面

1）创建PHP测试页面1，可以参考lnmp_soft/php_scripts/test.php：
[root@proxy ~]# vim /usr/local/nginx/html/test.php
<?php
$i="This is a test Page";
echo $i;
?>
2）创建PHP测试页面,连接并查询MariaDB数据库。
可以参考lnmp_soft/php_scripts/mysql.php:
[root@proxy ~]# vim /usr/local/nginx/html/mysql.php
<?php
$mysqli = new mysqli('localhost','root','密码','mysql');
//注意：root为mysql数据库的账户名称，密码需要修改为实际mysql密码，无密码则留空即可
//localhost是数据库的域名或IP，mysql是数据库的名称
if (mysqli_connect_errno()){
    die('Unable to connect!'). mysqli_connect_error();
}
$sql = "select * from user";
$result = $mysqli->query($sql);
while($row = $result->fetch_array()){
    printf("Host:%s",$row[0]);
    printf("</br>");
    printf("Name:%s",$row[1]);
    printf("</br>");
}
?>
3）客户端使用浏览器访问服务器PHP首页文档，检验是否成功：
[root@client ~]# firefox http://192.168.4.5/test.php
[root@client ~]# firefox http://192.168.4.5/mysql.php
4）LNMP常见问题
Nginx的默认访问日志文件为/usr/local/nginx/logs/access.log
Nginx的默认错误日志文件为/usr/local/nginx/logs/error.log
PHP默认错误日志文件为/var/log/php-fpm/www-error.log
如果动态网站访问失败，可用参考错误日志，查找错误信息。
3 案例3：地址重写
3.1 问题

沿用练习二，通过调整Nginx服务端配置，实现以下目标：
所有访问a.html的请求，重定向到b.html;
所有访问192.168.4.5的请求重定向至www.tmooc.cn；
所有访问192.168.4.5/下面子页面，重定向至www.tmooc.cn/下相同的页面；
实现firefox与curl访问相同页面文件，返回不同的内容。
3.2 方案

关于Nginx服务器的地址重写，主要用到的配置参数是rewrite：
rewrite regex replacement flag
rewrite 旧地址 新地址 [选项]
3.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：修改配置文件(访问a.html重定向到b.html)

1）修改Nginx服务配置：
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
.. ..
server {
        listen       80;
        server_name  localhost;
rewrite /a.html  /b.html;         ＃地址栏重写的格式                     
location / {
    root   html;
index  index.html index.htm;
}
}
[root@proxy ~]# echo "BB" > /usr/local/nginx/html/b.html
2）重新加载配置文件
[root@proxy ~]# /usr/local/nginx/sbin/nginx  -s  reload
3）客户端测试
[root@client ~]# firefox  http://192.168.4.5/a.html
步骤二：访问a.html重定向到b.html（跳转地址栏）

1）修改Nginx服务配置：
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
.. ..
server {
        listen       80;
        server_name  localhost;
rewrite /a.html  /b.html  redirect;         ＃加了这个地址名也跳了redirect;           
location / {  
    root   html;
index  index.html index.htm;
}
}
2）重新加载配置文件
[root@proxy ~]# /usr/local/nginx/sbin/nginx  -s  reload
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
#[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)
3）客户端测试（仔细观察浏览器地址栏的变化）
[root@client ~]# firefox  http://192.168.4.5/a.html
步骤三：修改配置文件(访问192.168.4.5的请求重定向至www.tmooc.cn)

1) 修改Nginx服务配置
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
.. ..
server {
        listen       80;
        server_name  localhost;
rewrite ^/  http://www.tmooc.cn/;
location / {
    root   html;
index  index.html index.htm;
# rewrite /a.html  /b.html  redirect;                         ＃charset utf-8（万国编码utf－8）
}
}
2）重新加载配置文件
[root@proxy ~]# /usr/local/nginx/sbin/nginx  -s  reload
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
#[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)
3）客户端测试（真实机测试，真实机才可以连接tmooc）
[root@room9pc01 ~]# firefox  http://192.168.4.5
步骤四：修改配置文件(访问192.168.4.5/下面子页面，重定向至www.tmooc.cn/下相同的页面)

1) 修改Nginx服务配置
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
.. ..
server {
        listen       80;
        server_name  localhost;
rewrite ^/(.*)$  http://www.tmooc.cn/$1;
location / {
    root   html;
index  index.html index.htm;
}
}
2）重新加载配置文件
[root@proxy ~]# /usr/local/nginx/sbin/nginx  -s  reload
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
#[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)
3）客户端测试（真实机测试，真实机才可以连接tmooc）
[root@room9pc01 ~]# firefox  http://192.168.4.5
[root@room9pc01 ~]# firefox  http://192.168.4.5/test
步骤五：修改配置文件(实现curl和火狐访问相同链接返回的页面不同)
1) 创建网页目录以及对应的页面文件：
[root@proxy ~]# echo "I am Normal page" > /usr/local/nginx/html/test.html
[root@proxy ~]# mkdir  -p  /usr/local/nginx/html/firefox/
[root@proxy ~]# echo "firefox page" > /usr/local/nginx/html/firefox/test.html
2) 修改Nginx服务配置
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
.. ..
server {
        listen       80;
        server_name  localhost;
location / {
    root   html;
index  index.html index.htm;
}
#这里，~符号代表正则匹配，*符号代表不区分大小写                                             ~*  模糊匹配
if ($http_user_agent ~* firefox) {            //识别客户端firefox浏览器   $http_user_agent变量模糊匹配
rewrite ^(.*)$  /firefox/$1;
}
}
3）重新加载配置文件
[root@proxy ~]# /usr/local/nginx/sbin/nginx  -s  reload
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
#[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)
4）客户端测试
[root@client ~]# firefox  http://192.168.4.5/test.html
[root@client ~]# curl     http://192.168.4.5/test.html
5）地址重写格式【总结】
rewrite 旧地址 新地址 [选项];
last 不再读其他rewrite
break 不再读其他语句，结束请求
redirect 临时重定向
permament 永久重定向




















Top
NSD Operation DAY03

代理：帮你干活的那个人或物就是你的代理
代理：有两个功能：调度（负载均衡），健康检查。
案例1：Nginx反向代理
案例2：Nginx的TCP/UDP调度器
案例3：Nginx常见问题处理
1 案例1：Nginx反向代理
1.1 问题

使用Nginx实现Web反向代理功能，实现如下功能：
后端Web服务器两台，可以使用httpd实现
Nginx采用轮询的方式调用后端Web服务器
两台Web服务器的权重要求设置为不同的值
最大失败次数为1，失败超时时间为30秒
1.2 方案

使用4台RHEL7虚拟机，其中一台作为Nginx代理服务器，该服务器需要配置两块网卡，IP地址分别为192.168.4.5和192.168.2.5，两台Web服务器IP地址分别为192.168.2.100和192.168.2.200。客户端测试主机IP地址为192.168.4.10。如图-1所示。

图-1
1.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：部署实施后端Web服务器

1）部署后端Web1服务器
后端Web服务器可以简单使用yum方式安装httpd实现Web服务，为了可以看出后端服务器的不同，可以将两台后端服务器的首页文档内容设置为不同的内容。
[root@web1 ~]# yum  -y  install  httpd
[root@web1 ~]# echo "192.168.2.100" > /var/www/html/index.html
[root@web1 ~]# systemctl restart httpd
[root@web1 ~]# firewall-cmd --set-default-zone=trusted
[root@web1 ~]# setenforce 0
2）部署后端Web2服务器
[root@web2 ~]# yum  -y  install  httpd
[root@web2 ~]# echo "192.168.2.200" > /var/www/html/index.html
[root@web2 ~]# systemctl restart httpd
[root@web2 ~]# firewall-cmd --set-default-zone=trusted
[root@web2 ~]# setenforce 0
步骤二：配置Nginx服务器，添加服务器池，实现反向代理功能

1）修改/usr/local/nginx/conf/nginx.conf配置文件
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
.. ..
http {
.. ..
#使用upstream定义后端服务器集群，集群名称任意(如webserver)
#使用server定义集群中的具体服务器和端口
upstream webserver {
                server 192.168.2.100:80;                        调度（调度算法）：
                server 192.168.2.200:80;                        轮询（roundrobin，RR）
        }                                                      加 ip_hash; 相同的客户端访问相同的web服务器 
.. ..                                                          原理：echo ip ｜ md5sum％2
server {
        listen        80;
        server_name  localhost;
            location / {
#通过proxy_pass将用户的请求转发给webserver集群                             ＃root html可有可无，代理的优先级比root高
            proxy_pass http://webserver;
        }
}
2）重启nginx服务
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
#[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)
3）客户端使用浏览器访问代理服务器测试轮询效果
[root@client ~]# curl http://192.168.4.5            //使用该命令多次访问查看效果
[root@client ~]# curl http://192.168.4.5            //使用该命令多次访问查看效果
步骤二：配置upstream服务器集群池属性

1）设置失败次数，超时时间，权重
weight可以设置后台服务器的权重，max_fails可以设置后台服务器的失败次数，fail_timeout可以设置后台服务器的失败超时时间。
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
.. ..
http {
.. ..
upstream webserver {
                server 192.168.2.100 weight=1 max_fails=1 fail_timeout=30;
                server 192.168.2.200 weight=2 max_fails=2 fail_timeout=30;
                server 192.168.2.101 down;
        }
#weight设置服务器权重值，默认值为1
#max_fails设置最大失败次数
#fail_timeout设置失败超时时间，单位为秒
#down标记服务器已关机，不参与集群调度
.. ..
server {
        listen        80;
        server_name  localhost;
            location / {
            proxy_pass http://webserver;
        }
}
2）重启nginx服务
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
#[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)
3）关闭一台后端服务器（如web1）
[root@web1 ~]# systemctl stop httpd
4）客户端使用浏览器访问代理服务器测试轮询效果
[root@client ~]# curl http://192.168.4.5            //使用该命令多次访问查看效果
5）再次启动后端服务器的httpd（如web1）
[root@web1 ~]# systemctl start httpd
6）客户端再次使用浏览器访问代理服务器测试轮询效果
[root@client ~]# curl http://192.168.4.5            //使用该命令多次访问查看效果
步骤三：配置upstream服务器集群的调度算法

1）设置相同客户端访问相同Web服务器
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
.. ..
http {
.. ..
upstream webserver {
#通过ip_hash设置调度规则为：相同客户端访问相同服务器
                 ip_hash;
                server 192.168.2.100 weight=1 max_fails=2 fail_timeout=10;
                server 192.168.2.200 weight=2 max_fails=2 fail_timeout=10;
        }
.. ..
server {
        listen        80;
        server_name  www.tarena.com;
            location / {
            proxy_pass http://webserver;
        }
}
2）重启nginx服务
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
#[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)
3）客户端使用浏览器访问代理服务器测试轮询效果
[root@client ~]# curl http://192.168.4.5            //使用该命令多次访问查看效果
2 案例2：Nginx的TCP/UDP调度器
2.1 问题

使用Nginx实现TCP/UDP调度器功能，实现如下功能：                        （4层代理，至少在nginx－1.9的版本以上）
后端SSH服务器两台
Nginx编译安装时需要使用--with-stream，开启ngx_stream_core_module模块
Nginx采用轮询的方式调用后端SSH服务器
2.2 方案

使用4台RHEL7虚拟机，其中一台作为Nginx代理服务器，该服务器需要配置两块网卡，IP地址分别为192.168.4.5和192.168.2.5，两台SSH服务器IP地址分别为192.168.2.100和192.168.2.200。客户端测试主机IP地址为192.168.4.10。如图-2所示。

图-2
2.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：部署支持4层TCP/UDP代理的Nginx服务器

1）部署nginx服务器
编译安装必须要使用--with-stream参数开启4层代理模块。
[root@proxy ~]# yum -y install gcc pcre-devel openssl-devel        //安装依赖包
[root@proxy ~]# tar  -xf   nginx-1.12.2.tar.gz
[root@proxy ~]# cd  nginx-1.12.2
[root@proxy nginx-1.12.2]# ./configure   \
> --with-http_ssl_module                                //开启SSL加密功能
> --with-stream                                       //开启4层反向代理功能
[root@proxy nginx-1.12.2]# make && make install           //编译并安装
步骤二：配置Nginx服务器，添加服务器池，实现TCP/UDP反向代理功能

1）修改/usr/local/nginx/conf/nginx.conf配置文件
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
stream {
            upstream backend {
               server 192.168.2.100:22;            //后端SSH服务器的IP和端口
               server 192.168.2.200:22;
}
            server {
                listen 12345;                    //Nginx监听的端口
                proxy_connect_timeout 1s;         //连接的超时时间，可选配置
                proxy_timeout 3s;
                 proxy_pass backend;
             }
}
http {
.. ..
}
2）重启nginx服务
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
#[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)
3）客户端使用访问代理服务器测试轮询效果
[root@client ~]# ssh 192.168.4.5 -p 12345            //使用该命令多次访问查看效果
3 案例3：Nginx常见问题处理
3.1 问题

本案例要求对Nginx服务器进行适当优化，解决如下问题，以提升服务器的处理性能：
如何自定义返回给客户端的404错误页面
如何查看服务器状态信息
如果客户端访问服务器提示“Too many open files”如何解决
如何解决客户端访问头部信息过长的问题
如何让客户端浏览器缓存数据
日志切割
开启gzip压缩功能，提高数据传输效率
开启文件缓存功能
然后客户机访问此Web服务器验证效果：
使用ab压力测试软件测试并发量
编写测试脚本生成长头部信息的访问请求
客户端访问不存在的页面，测试404错误页面是否重定向
3.2 步骤

实现此案例需要按照如下步骤进行。
步骤一：自定义报错页面

1）优化前，客户端使用浏览器访问不存在的页面，会提示404文件未找到
[root@client ~]# firefox http://192.168.4.5/xxxxx        //访问一个不存在的页面
2）修改Nginx配置文件，自定义报错页面
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
.. ..
        charset utf-8;                    //仅需要中文时需要改选项，可选项
error_page   404  /404.html;    //自定义错误页面
.. ..
[root@proxy ~]# vim /usr/local/nginx/html/404.html        //生成错误页面
Oops,No NO no page …
[root@proxy ~]# nginx -s reload
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
#[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)
3）优化后，客户端使用浏览器访问不存在的页面，会提示自己定义的40x.html页面
[root@client ~]# firefox http://192.168.4.5/xxxxx        //访问一个不存在的页面
4）常见http状态码
常见http状态码可用参考表-1所示。
表－1 主机列表

步骤二：如何查看服务器状态信息（非常重要的功能）                                       查看服务器状态信息
                                                                                          1，实时并发量是多少    
1）编译安装时使用--with-http_stub_status_module开启状态页面模块                 2，等待的数量？
[root@proxy ~]# tar  -zxvf   nginx-1.12.2.tar.gz                     3.总连接数量是多少？
[root@proxy ~]# cd  nginx-1.12.2                                     4.pv量和uv量是多少？ page view 
[root@proxy nginx-1.12.2]# ./configure   \                                             user  view   
> --with-http_ssl_module                        //开启SSL加密功能
> --with-stream                                //开启TCP/UDP代理模块
> --with-http_stub_status_module                //开启status状态页面
[root@proxy nginx-1.12.2]# make && make install    //编译并安装
2）启用Nginx服务并查看监听端口状态
ss命令可以查看系统中启动的端口信息，该命令常用选项如下：
-a显示所有端口的信息
-n以数字格式显示端口号
-t显示TCP连接的端口
-u显示UDP连接的端口
-l显示服务正在监听的端口信息，如httpd启动后，会一直监听80端口
-p显示监听端口的服务名称是什么（也就是程序名称）
注意：在RHEL7系统中可以使用ss命令替代netstat命令，功能一样，选项一样。
[root@proxy ~]# /usr/local/nginx/sbin/nginx
[root@proxy ~]# netstat  -anptu  |  grep nginx
tcp        0        0 0.0.0.0:80        0.0.0.0:*        LISTEN        10441/nginx
[root@proxy ~]# ss  -anptu  |  grep nginx
3）修改Nginx配置文件，定义状态页面
[root@proxy ~]# cat /usr/local/nginx/conf/nginx.conf
… …
location /status {
                stub_status on;
                 #allow IP地址;                 允许哪个查看
                 #deny IP地址;                  不允许哪个查看
        }
… …
[root@proxy ~]# nginx
4）优化后，查看状态页面信息
[root@proxy ~]# curl  http://192.168.4.5/status
Active connections: 1 
server accepts handled requests
 10 10 3 
Reading: 0 Writing: 1 Waiting: 0
Active connections：当前活动的连接数量。
Accepts：已经接受客户端的连接总数量。
Handled：已经处理客户端的连接总数量。
（一般与accepts一致，除非服务器限制了连接数量）。
Requests：客户端发送的请求数量。
Reading：当前服务器正在读取客户端请求头的数量。
Writing：当前服务器正在写响应信息的数量。
Waiting：当前多少客户端在等待服务器的响应。
步骤三：优化Nginx并发量

1）优化前使用ab高并发测试
[root@proxy ~]# ab -n 2000 -c 2000 http://192.168.4.5/
Benchmarking 192.168.4.5 (be patient)
socket: Too many open files (24)                //提示打开文件数量过多
2）修改Nginx配置文件，增加并发量
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
.. ..
worker_processes  2;                    //与CPU核心数量一致
events {
worker_connections 65535;        //每个worker最大并发连接数
}
.. ..
[root@proxy ~]# nginx -s reload
3）优化Linux内核参数（最大文件数量）
[root@proxy ~]# ulimit -a                        //查看所有属性值
[root@proxy ~]# ulimit -Hn 100000                //设置硬限制（临时规则）
[root@proxy ~]# ulimit -Sn 100000                //设置软限制（临时规则）
[root@proxy ~]# vim /etc/security/limits.conf
    .. ..
*               soft    nofile            100000
*               hard    nofile            100000
#该配置文件分4列，分别如下：
#用户或组    硬限制或软限制    需要限制的项目   限制的值
4）优化后测试服务器并发量（因为客户端没调内核参数，所以在proxy测试）
[root@proxy ~]# ab -n 2000 -c 2000 http://192.168.4.5/
步骤四：优化Nginx数据包头缓存

1）优化前，使用脚本测试长头部请求是否能获得响应
[root@proxy ~]# cat lnmp_soft/buffer.sh 
#!/bin/bash
URL=http://192.168.4.5/index.html?
for i in {1..5000}
do
    URL=${URL}v$i=$i
done
curl $URL                                //经过5000次循环后，生成一个长的URL地址栏
[root@proxy ~]# ./buffer.sh
.. ..
<center><h1>414 Request-URI Too Large</h1></center>        //提示头部信息过大
2）修改Nginx配置文件，增加数据包头部缓存大小
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
.. ..
http {
client_header_buffer_size    1k;        //默认请求包头信息的缓存    
large_client_header_buffers  4 4k;        //大请求包头部信息的缓存个数与容量
.. ..
}
[root@proxy ~]# nginx -s reload
3）优化后，使用脚本测试长头部请求是否能获得响应
[root@proxy ~]#cat cat buffer.sh 
#!/bin/bash
URL=http://192.168.4.5/index.html?
for i in {1..5000}
do
    URL=${URL}v$i=$i
done
curl $URL
[root@proxy ~]# ./buffer.sh
步骤五：浏览器本地缓存静态数据

1）使用Firefox浏览器查看缓存
以Firefox浏览器为例，在Firefox地址栏内输入about:cache将显示Firefox浏览器的缓存信息，如图-3所示，点击List Cache Entries可以查看详细信息。

图-3
2）清空firefox本地缓存数据，如图-4所示。


图-4
3）修改Nginx配置文件，定义对静态页面的缓存时间
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
server {
        listen       80;
        server_name  localhost;
        location / {
            root   html;
            index  index.html index.htm;
        }
location ~* \.(jpg|jpeg|gif|png|css|js|ico|xml)$ {
expires        30d;            //定义客户端缓存时间为30天
}
}
[root@proxy ~]# cp /usr/share/backgrounds/day.jpg /usr/local/nginx/html
[root@proxy ~]# nginx -s reload
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
#[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)
4）优化后，使用Firefox浏览器访问图片，再次查看缓存信息
[root@client ~]# firefox http://192.168.4.5/day.jpg
在firefox地址栏内输入about:cache，查看本地缓存数据，查看是否有图片以及过期时间是否正确。
步骤六：日志切割

日志文件越来越大怎么办？单个文件10G? 如何切割？（非常常见的面试题）
步骤：1. 把旧的日志重命名
2. kill USR1 PID(nginx的进程PID号)
1）手动执行
备注：/usr/local/nginx/logs/nginx.pid文件中存放的是nginx的进程PID号。
[root@proxy ~]#  mv access.log access2.log
[root@proxy ~]# kill -USR1 $(cat /usr/local/nginx/logs/nginx.pid)
2）自动完成
每周5的03点03分自动执行脚本完成日志切割工作。
[root@proxy ~]# vim /usr/local/nginx/logbak.sh                  ＃kill是给程序发送一个信号，不加选项默认是－15杀死匀     
#!/bin/bash
date=`date +%Y%m%d`
logpath=/usr/local/nginx/logs
mv $logpath/access.log $logpath/access-$date.log
mv $logpath/error.log $logpath/error-$date.log
kill -USR1 $(cat $logpath/nginx.pid)
[root@proxy ~]# crontab -e
03 03 * * 5  /usr/local/nginx/logbak.sh
步骤七：对页面进行压缩处理

1）修改Nginx配置文件
[root@proxy ~]# cat /usr/local/nginx/conf/nginx.conf
http {
.. ..
gzip on;                            //开启压缩
gzip_min_length 1000;                //小文件不压缩
gzip_comp_level 4;                //压缩比率      1-9  1：压得快但压缩不明显  9：压得好但时间久
gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript;
                                    //对特定文件压缩，类型参考mime.types
.. ..
}
步骤八：服务器内存缓存

1）如果需要处理大量静态文件，可以将文件缓存在内存，下次访问会更快。
http { 
open_file_cache          max=2000  inactive=20s;
        open_file_cache_valid    60s;
        open_file_cache_min_uses 5;
        open_file_cache_errors   off;
//设置服务器最大缓存2000个文件句柄，关闭20秒内无请求的文件句柄
//文件句柄的有效时间是60秒，60秒后过期
//只有访问次数超过5次会被缓存
} 







Top
NSD OPERATION DAY04

案例1：PHP的本地Session信息
案例2：构建memcached服务
案例3：LNMP+memcached
案例4：PHP实现session共享
1 案例1：PHP的本地Session信息
1.1 问题

通过Nginx调度器负载后端两台Web服务器，实现以下目标：
部署Nginx为前台调度服务器
调度算法设置为轮询
后端为两台LNMP服务器
部署测试页面，查看PHP本地的Session信息
1.2 方案

概念：
Session：存储在服务器端，保存用户名、登陆状态等信息。
Cookies：由服务器下发给客户端，保存在客户端的一个文件里。         #没有这两个东西，每次印新都要重新登陆
保存的内容主要包括：SessionID。
实验拓扑环境：
使用4台RHEL7虚拟机，其中一台作为Nginx前端调度器服务器（eth0:192.168.4.5,eth1:192.168.2.5）、两台虚拟机部署为LNMP服务器，分别为Web1服务器（192.168.2.100）和Web2服务器（192.168.2.200），另外一台作为测试用的Linux客户机（192.168.4.10），拓扑如图-2所示。

图-2
1.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：部署后端LNMP服务器相关软件

注意:以下部署LNMP服务器的操作，需要在两台后端服务器做相同的操作，下面我们以一台Web2服务器（192.168.2.200）为例，对Web1服务器执行相同操作即可。
1）使用yum安装基础依赖包
[root@web2 ~]# yum -y install gcc openssl-devel pcre-devel
.. ..
2）源码安装Nginx
[root@web2 ~]# tar -xf nginx-1.12.2.tar.gz
[root@web2 ~]# cd nginx-1.12.2
[root@web2 nginx-1.12.2]#  ./configure   \
> --with-http_ssl_module 
[root@web2 nginx-1.12.2]# make && make install
3）安装MariaDB数据库
[root@web2 ~]# yum -y install  mariadb  mariadb-server  mariadb-devel
4）安装PHP
[root@web2 ~]# yum -y install  php  php-mysql
[root@web2 ~]# yum -y install  php-fpm
5）修改Nginx配置文件（修改默认首页与动静分离）
[root@web2 ~]# vim /usr/local/nginx/conf/nginx.conf
location / {
            root   html;
            index  index.php  index.html   index.htm;
        }
 location  ~  \.php$  {
            root           html;
            fastcgi_pass   127.0.0.1:9000;
            fastcgi_index  index.php;
           # fastcgi_param   SCRIPT_FILENAME  $document_root$fastcgi_script_name;
            include        fastcgi.conf;
        }
步骤二：启动LNMP服务器相关的服务

1）启动Nginx服务
这里需要注意的是，如果服务器上已经启动了其他监听80端口的服务软件（如httpd），则需要先关闭该服务，否则会出现冲突。
[root@web2 ~]# systemctl stop  httpd                //如果该服务存在，则关闭该服务
[root@web2 ~]# /usr/local/nginx/sbin/nginx
[root@web2 ~]# netstat -utnlp | grep :80
tcp    0    0 0.0.0.0:80        0.0.0.0:*        LISTEN        32428/nginx         
2）启动MySQL服务
[root@web2 ~]# systemctl start mariadb
[root@web2 ~]# systemctl status mariadb
3）启动PHP-FPM服务
[root@web2 ~]# systemctl start  php-fpm
[root@web2 ~]# systemctl status php-fpm
步骤三：部署前端Nginx调度服务器

1）使用源码安装nginx软件（如果Nginx软件包已安装可以忽略此步骤）
[root@proxy ~]# yum  -y  install   gcc pcre-devel openssl-devel
[root@proxy ~]# tar -xf nginx-1.12.2.tar.gz
[root@proxy ~]# cd nginx-1.12.2
[root@proxy nginx-1.12.2]# ./configure
[root@proxy nginx-1.12.2]# make && make install
2）修改Nginx配置文件，实现代理服务器
Nginx配置文件中，通过upstream定义后端服务器地址池，默认调度策略为轮询，使用proxy_pass调用upstream定义的服务器地址池：
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
.. ..
upstream webs  {
        server 192.168.2.100:80;
        server 192.168.2.200:80;
  }
 server  {
          listen       80;
          server_name  localhost;
          location  /  {
              proxy_pass http://webs;
            root   html;
            index  index.php index.html index.htm;
          }
}
3）重新加载配置文件

[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)
步骤四：测试环境是否配置成功

1）浏览器访问测试页面验证。
[root@client ~]# curl  http://192.168.4.5/index.html        //查看是否有数据
步骤五：部署测试页面

1）部署测试页面(Web1服务器）。
测试页面可以参考lnmp_soft/php_scripts/php-memcached-demo.tar.gz。
[root@web1 ~]# cd lnmp_soft/php_scripts/
[root@web1 php_scripts]# tar -xf php-memcached-demo.tar.gz
[root@web1 php_scripts]# cd php-memcached-demo
[root@web1 php-memcached-demo]# cp -r  *  /usr/local/nginx/html/
2）浏览器直接访问后端服务器的测试页面（Web1服务器）。
[root@web1 ~]# firefox http://192.168.2.100            //填写账户信息
[root@web1 ~]# cd /var/lib/php/session/            //查看服务器本地的Session信息
[root@web1 ~]# ls
sess_ahilcq9bguot0vqsjtd84k7244                        //注意这里的ID是随机的
[root@web1 ~]# cat sess_ahilcq9bguot0vqsjtd84k7244
注意：可用修改index.php和home.php两个文件的内容，添加页面颜色属性，以区别后端两台不同的服务器:<body bgcolor=blue>。
3）部署测试页面(Web2服务器）。
测试页面可以参考lnmp_soft/php_scripts/php-memcached-demo.tar.gz。
[root@web2 ~]# cd lnmp_soft/php_scripts/
[root@web2 php_scripts]# tar -xf php-memcached-demo.tar.gz
[root@web2 php_scripts]# cd php-memcached-demo
[root@web2 php-memcached-demo]# cp -a  *  /usr/local/nginx/html/
4）浏览器直接访问后端服务器的测试页面（Web2服务器）。
[root@web2 ~]# firefox http://192.168.2.100             //填写账户信息
[root@web2 ~]# cd /var/lib/php/session/            //查看服务器本地的Session信息
[root@web2 ~]# ls
sess_qqek1tmel07br8f63d6v9ch401                        //注意这里的ID是随机的
[root@web2 ~]# cat sess_qqek1tmel07br8f63d6v9ch401    
注意：可用修改index.php和home.php两个文件的内容，添加页面颜色属性，以区别后端两台不同的服务器:<body bgcolor=green>。
5）浏览器访问前端调度器测试（不同后端服务器Session不一致）。
推荐使用google浏览器测试。
[root@client ~]# google-chrome http://192.168.4.5
//填写注册信息后，刷新，还需要再次注册，说明两台计算机使用的是本地Session
//第二台主机并不知道你再第一台主机已经登录，第一台主机的登录信息也没有传递给第二台主机
2 案例2：构建memcached服务
2.1 问题

本案例要求先快速搭建好一台memcached服务器，并对memcached进行简单的增、删、改、查操作：
安装memcached软件，并启动服务
使用telnet测试memcached服务
对memcached进行增、删、改、查等操作
2.2 方案

使用1台RHEL7虚拟机作为memcached服务器（192.168.4.5）。
在RHEL7系统光盘中包含有memcached，因此需要提前配置yum源，即可直接使用yum安装，客户端测试时需要提前安装telnet远程工具。
验证时需要客户端主机安装telnet，远程memcached来验证服务器的功能：
add name 0 180 10	//变量不存在则添加
set name 0 180 10	//添加或替换变量
replace name 0 180 10	//替换
get name	//读取变量
append name 0 180 10	//向变量中追加数据
delete name	//删除变量
flush_all	//清空所有
提示：0表示不压缩，180为数据缓存时间，10为需要存储的数据字节数量。
2.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：构建memcached服务

1）使用yum安装软件包memcached
[root@proxy ~]# yum -y  install   memcached
[root@proxy ~]# rpm -qa memcached
memcached-1.4.15-10.el7_3.1.x86_64
2) memcached配置文件（查看即可，不需要修改）
[root@proxy ~]# vim /usr/lib/systemd/system/memcached.service
ExecStart=/usr/bin/memcached -u $USER -p $PORT -m $CACHESIZE -c $MAXCONN $OPTIONS
[root@proxy ~]# vim /etc/sysconfig/memcached
PORT="11211"
USER="memcached"
MAXCONN="1024"
CACHESIZE="64"
OPTIONS=""
3）启动服务并查看网络连接状态验证是否开启成功：
netstat命令可以查看系统中启动的端口信息，该命令常用选项如下：
-a显示所有端口的信息
-n以数字格式显示端口号
-t显示TCP连接的端口
-u显示UDP连接的端口
-l显示服务正在监听的端口信息，如httpd启动后，会一直监听80端口
-p显示监听端口的服务名称是什么（也就是程序名称）
注意：在RHEL7系统中，使用ss命令可以替代netstat，功能与选项一样。
[root@proxy ~]# systemctl  start  memcached
[root@proxy ~]# systemctl  status  memcached
[root@proxy ~]# netstat  -anptu  |  grep memcached
tcp    0    0 0.0.0.0:11211        0.0.0.0:*        LISTEN        2839/memcached      
tcp    0    0 :::11211            :::*                LISTEN        2839/memcached      
udp    0    0 0.0.0.0:11211        0.0.0.0:*                    2839/memcached      
udp    0    0 :::11211            :::*                            2839/memcached
[root@proxy ~]# setenforce 0
[root@proxy ~]# firewall-cmd --set-default-zone=trusted
步骤二：使用telnet访问memcached服务器

1）使用yum安装telnet
[root@proxy ~]# yum -y install telnet
2)使用telnet连接服务器测试memcached服务器功能，包括增、删、改、查等操作。
[root@proxy ~]# telnet  192.168.4.5  11211
Trying 192.168.4.5...
……
##提示：0表示不压缩，180为数据缓存时间，3为需要存储的数据字节数量。
set name 0 180 3                //定义变量，变量名称为name
plj                            //输入变量的值，值为plj                
STORED
get name                        //获取变量的值
VALUE name 0 3                 //输出结果
plj
END
##提示：0表示不压缩，180为数据缓存时间，3为需要存储的数据字节数量。
add myname 0 180 10            //新建，myname不存在则添加，存在则报错
set myname 0 180 10            //添加或替换变量
replace myname 0 180 10        //替换，如果myname不存在则报错
get myname                    //读取变量
append myname 0 180 10        //向变量中追加数据
delete myname                    //删除变量
flush_all                        //清空所有
quit                            //退出登录                                  
3 案例3：LNMP+memcached
3.1 问题

沿用练习一和练习二，部署LNMP+memcached网站平台,通过PHP页面实现对memcached服务器的数据操作，实现以下目标：
为PHP安装memcache扩展
创建PHP页面，并编写PHP代码，实现对memcached的数据操作
3.2 方案

如果希望使用PHP来操作memcached，注意必须要为PHP安装memcache扩展（php-pecl-memcache），否则PHP无法解析连接memcached的指令。客户端测试时需要提前安装telnet远程工具。
3.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：创建PHP页面，使用PHP语言测试memcached服务

1）部署测试页面
创建PHP首页文档/usr/local/nginx/html/index.php，测试页面可以参考lnmp_soft/php_scripts/mem.php。
注意：192.168.2.5是memcached数据库。
 [root@web1 ~]# vim /usr/local/nginx/html/mem.php
<?php
$memcache=new Memcache;                //创建memcache对象
$memcache->connect('192.168.2.5',11211) or die ('could not connect!!');
$memcache->set('key','test');             //定义变量
$get_values=$memcache->get('key');        //获取变量值
echo $get_values;
?>
2）客户端测试（结果会失败）
客户端使用浏览器访问服务器PHP首页文档，检验对memcached的操作是否成功：
[root@web1 ~]# firefox http://192.168.2.100/test.php
注意：这里因为没有给PHP安装扩展包，默认PHP无法连接memcached数据库，需要给PHP安装扩展模块才可以连接memcached数据库。
3）为PHP添加memcache扩展
[root@web1 ~]# yum -y install  php-pecl-memcache
[root@web1 ~]# systemctl restart php-fpm
4）客户端再次测试（结果会成功显示数据结果）
[root@web1 ~]# firefox http://192.168.2.100/test.php
4 案例4：PHP实现session共享
4.1 问题

沿用练习三，通过修改PHP-FPM配置文件，实现session会话共享：
配置PHP使用memcached服务器共享Session信息
客户端访问两台不同的后端Web服务器时，Session 信息一致
4.2 方案

在练习三拓扑的基础上，Nginx服务器除了承担调度器外，还需要担任memcached数据库的角色，并在两台后端LNMP服务器上实现PHP的session会话共享。拓扑结构如图-4所示。

图-4
4.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：在后端LNMP服务器上部署Session共享

注意：这些操作在两台后端Web服务器上均需要执行，以下操作以Web1（192.168.2.100）服务器为例。
1）为PHP添加memcache扩展
注意，因为后端两台web服务器(web1,web2)都需要连接memcached数据库，所以两台主机都需要安装PHP扩展模块(下面也web1为例)。
[root@web1 ~]# yum -y install  php-pecl-memcache
2）修改PHP-FPM配置文件，并重启服务
注意，因为后端两台web服务器(web1,web2)都需要修改配置文件(下面也web1为例)。
[root@web1 ~]# vim  /etc/php-fpm.d/www.conf            //修改该配置文件的两个参数
//文件的最后2行
修改前效果如下:
php_value[session.save_handler] = files
php_value[session.save_path] = /var/lib/php/session
//原始文件，默认定义Sessoin会话信息本地计算机（默认在/var/lib/php/session）
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
修改后效果如下:
php_value[session.save_handler] = memcache
php_value[session.save_path] = "tcp://192.168.2.5:11211"
//定义Session信息存储在公共的memcached服务器上，主机参数中为memcache（没有d）
//通过path参数定义公共的memcached服务器在哪（服务器的IP和端口）
[root@web1 ~]# systemctl  restart  php-fpm
步骤三：客户端测试

客户端使用浏览器访问两台不同的Web服务器。
操作步骤参考练习一，最终可以获得相关的Session ID信息。










Top
NSD OPERATION DAY05

案例1：安装部署Tomcat服务器
案例2：使用Tomcat部署虚拟主机
案例3：使用Varnish加速Web
1 案例1：安装部署Tomcat服务器
1.1 问题

本案例要求部署Tomcat服务器，具体要求如下：
安装部署JDK基础环境
安装部署Tomcat服务器
创建JSP测试页面，文件名为test.jsp，显示服务器当前时间
然后客户机访问此Web服务器验证效果：
使用火狐浏览器访问Tomcat服务器的8080端口，浏览默认首页
使用火狐浏览器访问Tomcat服务器的8080端口，浏览默认测试页面
1.2 方案

使用2台RHEL7虚拟机，其中一台作为Tomcat服务器（192.168.2.100）、另外一台作为测试用的Linux客户机（192.168.2.5），如图-1所示。

图-1
使用RPM安装JDK基础环境
使用源码安装部署Tomcat服务器
1.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：部署Tomcat服务器软件(192.168.2.100/24)

1）使用RPM安装JDK环境
[root@web1 ~]# yum -y install  java-1.8.0-openjdk                //安装JDK
[root@web1 ~]# yum -y install java-1.8.0-openjdk-headless        //安装JDK
[root@web1 ~]# java -version                                    //查看JAVA版本
2）安装Tomcat（apache-tomcat-8.0.30.tar.gz软件包，在lnmp_soft中有提供）
[root@web1 ~]# tar -xf  apache-tomcat-8.0.30.tar.gz
[root@web1 ~]# mv apache-tomcat-8.0.30  /usr/local/tomcat
[root@web1 ~]# ls /usr/local/tomcat
bin/                                            //主程序目录
lib/                                            //库文件目录
logs/                                          //日志目录  
temp/                                         //临时目录
work/                                        //自动编译目录jsp代码转换servlet
conf/                                        //配置文件目录
webapps/                                        //页面目录
3）启动服务          tomcat每次启动都要读取足够多的随机数据（/dev/random)在这个地方读的，不够随机数就起不来服务
[root@web1 ~]# /usr/local/tomcat/bin/startup.sh            
4）服务器验证端口信息
[root@web1 ~]# netstat -nutlp |grep java        //查看java监听的端口
tcp        0      0 :::8080              :::*                LISTEN      2778/java           
tcp        0      0 ::ffff:127.0.0.1:8005     :::*         LISTEN       2778/java  
提示：如果检查端口时，8005端口启动非常慢，可用使用下面的命令用urandom替换random（非必须操作）。
[root@web1 ~]# mv /dev/random  /dev/random.bak
[root@web1 ~]# ln -s /dev/urandom  /dev/random
5）客户端浏览测试页面(proxy作为客户端)
[root@proxy ~]# firefox http://192.168.2.100:8080
步骤二：修改Tomcat配置文件

1）创建测试JSP页面
[root@web1 ~]# vim  /usr/local/tomcat/webapps/ROOT/test.jsp
<html>
<body>
<center>
Now time is: <%=new java.util.Date()%>            //显示服务器当前时间
</center>
</body>
</html>
2）重启服务
[root@web1 ~]# /usr/local/tomcat/bin/shutdown.sh
[root@web1 ~]# /usr/local/tomcat/bin/startup.sh
步骤三：验证测试

1）服务器验证端口信息
[root@web1 ~]# netstat -nutlp |grep java        //查看java监听的端口
tcp        0      0 :::8080              :::*                LISTEN      2778/java           
tcp        0      0 ::ffff:127.0.0.1:8005     :::*         LISTEN       2778/java  
提示：如果检查端口时，8005端口启动非常慢，可用使用下面的命令用urandom替换random（非必须操作）。
[root@web1 ~]# mv /dev/random  /dev/random.bak
[root@web1 ~]# ln -s /dev/urandom  /dev/random
2）客户端浏览测试页面(proxy充当客户端角色)
[root@proxy ~]# firefox http://192.168.2.100:8080
[root@proxy ~]# firefox http://192.168.2.100:8080/test.jsp
2 案例2：使用Tomcat部署虚拟主机
2.1 问题

沿用练习二，使用Tomcat部署加密虚拟主机，实现以下要求：
实现两个基于域名的虚拟主机，域名分别为：www.a.com和 www.b.com
使用www.a.com域名访问的页面根路径为/usr/local/tomcat/a/ROOT
使用www.b.com域名访问的页面根路径为/usr/local/tomcat/b/base
访问www.a.com/test时，页面自动跳转到/var/www/html目录下的页面
访问页面时支持SSL加密通讯
私钥、证书存储路径为/usr/local/tomcat/conf/cert
每个虚拟主机都拥有独立的访问日志文件
配置tomcat集群环境
2.2 方案

修改server.xml配置文件，创建两个域名的虚拟主机，修改如下两个参数块：
# cat /usr/local/tomcat/conf/server.xml
<Server>
   <Service>
     <Connector port=8080 />
     <Connector port=8009 />
     <Engine name="Catalina" defaultHost="localhost">
<Host name="www.a.com" appBase="a" unpackWARS="true" autoDeploy="true">
</Host>
<Host name="www.b.com" appBase="b" unpackWARS="true" autoDeploy="true">
</Host>
… …
2.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：配置服务器虚拟主机

1）修改server.xml配置文件，创建虚拟主机
[root@web1 ~]# vim /usr/local/tomcat/conf/server.xml
… …
<Host name="www.a.com" appBase="a" unpackWARS="true" autoDeploy="true">
</Host>
<Host name="www.b.com" appBase="b" unpackWARS="true" autoDeploy="true">
</Host>
2）创建虚拟主机对应的页面根路径
[root@web1 ~]# mkdir -p  /usr/local/tomcat/{a,b}/ROOT
[root@web1 ~]# echo "AAA"   > /usr/local/tomcat/a/ROOT/index.html
[root@web1 ~]# echo "BBB" > /usr/local/tomcat/b/ROOT/index.html
3）重启Tomcat服务器
[root@web1 ~]# /usr/local/tomcat/bin/shutdown.sh
[root@web1 ~]# /usr/local/tomcat/bin/startup.sh
4）客户端设置host文件，并浏览测试页面进行测试(proxy充当客户端角色)
注意：ssh远程连接时使用使用-X参数才可以！！！
[root@proxy ~]# vim /etc/hosts
… …
192.168.2.100      www.a.com  www.b.com
[root@proxy ~]# firefox http://www.a.com:8080/        //注意访问的端口为8080
[root@proxy ~]# firefox http://www.b.com:8080/
步骤二：修改www.b.com网站的首页目录为base

1）使用docBase参数可以修改默认网站首页路径
[root@web1 ~]# vim /usr/local/tomcat/conf/server.xml
… …
<Host name="www.a.com" appBase="a" unpackWARS="true" autoDeploy="true">
</Host>
<Host name="www.b.com" appBase="b" unpackWARS="true" autoDeploy="true">
<Context path="" docBase="base"/>
</Host>
… …
[root@web1 ~]# mkdir  /usr/local/tomcat/b/base
[root@web1 ~]# echo "BASE" > /usr/local/tomcat/b/base/index.html
[root@web1 ~]# /usr/local/tomcat/bin/shutdown.sh
[root@web1 ~]# /usr/local/tomcat/bin/startup.sh
2）测试查看页面是否正确(proxy充当客户端角色)
[root@proxy ~]# firefox http://www.b.com:8080/        //结果为base目录下的页面内容
步骤三：跳转

1）当用户访问http://www.a.com/test打开/var/www/html目录下的页面
[root@web1 ~]# vim /usr/local/tomcat/conf/server.xml
… …
<Host name="www.a.com" appBase="a" unpackWARS="true" autoDeploy="true">
<Context path="/test" docBase="/var/www/html/" />
</Host>
<Host name="www.b.com" appBase="b" unpackWARS="true" autoDeploy="true">
<Context path="" docBase="base" />
</Host>
… …
[root@web1 ~]# echo "Test" > /var/www/html/index.html
[root@web1 ~]# /usr/local/tomcat/bin/shutdown.sh
[root@web1 ~]# /usr/local/tomcat/bin/startup.sh
2）测试查看页面是否正确(proxy充当客户端角色)
[root@proxy ~]# firefox http://www.a.com:8080/test    
//返回/var/www/html/index.html的内容
//注意，访问的端口为8080
步骤四：配置Tomcat支持SSL加密网站

1）创建加密用的私钥和证书文件
[root@web1 ~]# keytool -genkeypair -alias tomcat -keyalg RSA -keystore /usr/local/tomcat/keystore                //提示输入密码为:123456
//-genkeypair     生成密钥对
//-alias tomcat     密钥别名
//-keyalg RSA     定义密钥算法为RSA算法
//-keystore         定义密钥文件存储在:/usr/local/tomcat/keystore
2)再次修改server.xml配置文件，创建支持加密连接的Connector
[root@web1 ~]# vim /usr/local/tomcat/conf/server.xml
… …
<Connector port="8443" protocol="org.apache.coyote.http11.Http11NioProtocol"
maxThreads="150" SSLEnabled="true" scheme="https" secure="true"
keystoreFile="/usr/local/tomcat/keystore" keystorePass="123456" clientAuth="false" sslProtocol="TLS" />
//备注，默认这段Connector被注释掉了，打开注释，添加密钥信息即可
3）重启Tomcat服务器
[root@web1 ~]# /usr/local/tomcat/bin/shutdown.sh
[root@web1 ~]# /usr/local/tomcat/bin/startup.sh
4）客户端设置host文件，并浏览测试页面进行测试(proxy充当客户端角色)
[root@proxy ~]# vim /etc/hosts
… …
192.168.2.100      www.a.com  www.b.com
[root@proxy ~]# firefox https://www.a.com:8443/
[root@proxy ~]# firefox https://www.b.com:8443/
[root@proxy ~]# firefox https://192.168.2.100:8443/
步骤五：配置Tomcat日志

1)为每个虚拟主机设置不同的日志文件
[root@web1 ~]# vim /usr/local/tomcat/conf/server.xml
.. ..
<Host name="www.a.com" appBase="a" unpackWARS="true" autoDeploy="true">
<Context path="/test" docBase="/var/www/html/" />
#从默认localhost虚拟主机中把Valve这段复制过来，适当修改下即可
<Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs"
               prefix=" a_access" suffix=".txt"
               pattern="%h %l %u %t &quot;%r&quot; %s %b" />
</Host>
<Host name="www.b.com" appBase="b" unpackWARS="true" autoDeploy="true">
<Context path="" docBase="base" />
<Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs"
               prefix=" b_access" suffix=".txt"
               pattern="%h %l %u %t &quot;%r&quot; %s %b" />
</Host>
.. ..
2）重启Tomcat服务器
[root@web1 ~]# /usr/local/tomcat/bin/shutdown.sh
[root@web1 ~]# /usr/local/tomcat/bin/startup.sh
3）查看服务器日志文件
[root@web1 ~]# ls /usr/local/tomcat/logs/
步骤六：扩展实验(配置Tomcat集群)

1) 在192.168.4.5主机上配置Nginx调度器（具体安装步骤参考前面的章节）
[root@proxy ~]# vim  /usr/local/nginx/conf/nginx.conf
http{
    upstream toms {
        server 192.168.2.100:8080;
        server 192.168.2.200:8080;
    }
    server  {
        listen 80;
        server_name localhost;
        location / {
            proxy_pass  http://toms;
        }
    }
}  
2) 在192.168.2.100和192.168.2.200主机上配置Tomcat调度器
以下以Web1为例：
[root@web1 ~]# yum -y install  java-1.8.0-openjdk                //安装JDK
[root@web1 ~]# yum -y install java-1.8.0-openjdk-headless        //安装JDK
[root@web1 ~]# tar -xzf  apache-tomcat-8.0.30.tar.gz
[root@web1 ~]# mv apache-tomcat-8.0.30  /usr/local/tomcat
3）启动服务
[root@web1 ~]# /usr/local/tomcat/bin/startup.sh
4) 客户端验证
为了防止有数据缓存，可以使用真实主机的google-chrome访问代理服务器，输入Ctrl+F5刷新页面。
3 案例3：使用Varnish加速Web
3.1 问题

通过配置Varnish缓存服务器，实现如下目标：
使用Varnish加速后端Web服务
代理服务器可以将远程的Web服务器页面缓存在本地
远程Web服务器对客户端用户是透明的
利用缓存机制提高网站的响应速度
使用varnishadm命令管理缓存页面
使用varnishstat命令查看Varnish状态
3.2 方案

通过源码编译安装Varnish缓存服务器
编译安装Varnish软件
修改配置文件，缓存代理源Web服务器，实现Web加速功能
使用3台RHEL7虚拟机，其中一台作为Web服务器（192.168.2.100）、一台作为Varnish代理服务器（192.168.4.5,192.168.2.5)，另外一台作为测试用的Linux客户机（192.168.4.10），如图-2所示。

图-2
对于Web服务器的部署，此实验中仅需要安装nginx或者httpd软件、启动服务，并生成测试首页文件即可，默认httpd网站根路径为/var/www/html，首页文档名称为index.html，默认nginx网站根路径为/usr/local/nginx/html，默认首页为index.html。下面的实验我们以httpd为例作为Web服务器。
3.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：构建Web服务器

1）使用yum安装web软件包
[root@web1 ~]# yum  -y  install  httpd
2）启用httpd服务（注意需要关闭nginx，否则端口冲突）
[root@web1 ~]# systemctl start httpd
httpd服务默认通过TCP 80端口监听客户端请求：
[root@web1 ~]# netstat  -anptu  |  grep httpd
tcp        0        0        :::80        :::*        LISTEN        2813/httpd
3）为Web访问建立测试文件
在网站根目录/var/www/html下创建一个名为index.html的首页文件：
[root@web1 ~]# cat /var/www/html/index.html 
192.168.2.100
4）测试页面是否正常（代理服务器测试后台web）
[root@proxy ~]# firefox http://192.168.2.100
步骤二：部署Varnish缓存服务器(192.168.4.5)

1）编译安装软件
[root@proxy ~]# yum -y install gcc readline-devel    //安装软件依赖包
[root@proxy ~]# yum -y install ncurses-devel         //安装软件依赖包
[root@proxy ~]# yum -y install pcre-devel            //安装软件依赖包
[root@proxy ~]# yum -y install python-docutils         //安装软件依赖包
 [root@proxy ~]# useradd -s /sbin/nologin varnish                //创建账户
[root@proxy ~]# tar -xf varnish-5.2.1.tar.gz
[root@proxy ~]# cd varnish-5.2.1
[root@proxy varnish-5.2.1]# ./configure
[root@proxy varnish-5.2.1]# make && make install
2）复制启动脚本及配置文件
[root@proxy varnish-5.2.1]# cp  etc/example.vcl   /usr/local/etc/default.vcl
3）修改代理配置文件
[root@proxy ~]# vim  /usr/local/etc/default.vcl
backend default {
     .host = "192.168.2.100";
     .port = "80";
 }
4）启动服务
 [root@proxy ~]# varnishd  -f /usr/local/etc/default.vcl
//varnishd命令的其他选项说明如下：
//varnishd -s malloc,128M        定义varnish使用内存作为缓存，空间为128M
//varnishd -s file,/var/lib/varnish_storage.bin,1G 定义varnish使用文件作为缓存
步骤三：客户端测试

1）客户端开启浏览器访问
[root@client ~]# curl http://192.168.4.5
步骤四：其他操作

1）查看varnish日志
[root@proxy ~]# varnishlog                        //varnish日志
[root@proxy ~]# varnishncsa                    //访问日志
2）更新缓存数据，在后台web服务器更新页面内容后，用户访问代理服务器看到的还是之前的数据，说明缓存中的数据过期了需要更新（默认也会自动更新，但非实时更新）。
[root@proxy ~]# varnishadm  
varnish> ban req.url ~ .*
//清空缓存数据，支持正则表达式







Top
NSD OPERATION DAY06

案例1：Git基本操作
案例2： HEAD指针操作
案例3：Git分支操作
案例4：Git服务器
案例5：制作nginx的RPM包
1 案例1：Git基本操作
1.1 问题

本案例要求先快速搭建好一台Git服务器，并测试该版本控制软件，要求如下：
安装Git软件
创建版本库
客户端克隆版本仓库到本地
本地工作目录修改数据
提交本地修改到服务器
1.2 方案

实验拓扑如图-1所示，Git工作流如图-2所示。

图-1

图-2
1.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：部署Git服务器（192.168.2.100作为远程git服务器）

1）YUM安装Git软件。
[root@web1 ~]# yum -y install git
[root@web1 ~]# git --version
2)初始化一个空仓库。
[root@web1 ~]# mkdir /var/git
[root@web1 ~]# git init /var/git/project --bare 
[root@web1 ~]# ls /var/git/
config  description  HEAD  hooks  info  objects  refs   
步骤二：客户端测试(192.168.2.200作为客户端主机)

使用git常用指令列表如表-1所示。
表－1 git常用指令列表

1) clone克隆服务器仓库到本地。
[root@web2 ~]# yum -y install git
[root@web2 ~]# git clone root@192.168.2.100:/var/git/project 
[root@web2 ~]# cd project
[root@web2 ~]# ls 
2) 修改git配置。
[root@web2 project]# git config --global user.email "you@example.com"
[root@web2 project]# git config --global user.name "Your Name"
[root@web2 project]# cat ~/.gitconfig 
[user]
    email = you@example.com
    name = Your Name
3） 本地工作区对数据进行增删改查(必须要先进入仓库再操作数据)。
[root@web2 project]# echo "init date" > init.txt
[root@web2 project]# mkdir demo
[root@web2 project]# cp /etc/hosts demo
4） 查看仓库中数据的状态。
[root@web2 project]# git status
5） 将工作区的修改提交到暂存区。
[root@web2 project]# git add .
6) 将暂存区修改提交到本地仓库。
[root@web2 project]# git commit  -m  "注释，可以为任意字符"
[root@web2 project]# git status
7） 将本地仓库中的数据推送到远程服务器(web2将数据推送到web1)。
[root@web2 project]# git config --global push.default simple
[root@web2 project]# git push
root@192.168.2.100's password:  输入服务器root密码
[root@web2 project]# git status
8) 将服务器上的数据更新到本地（web1的数据更新到web2）。
备注：可能其他人也在修改数据并提交服务器，就会导致自己的本地数据为旧数据，使用pull就可以将服务器上新的数据更新到本地。
[root@web2 project]# git pull
9) 查看版本日志。
[root@web2 project]# git log
[root@web2 project]# git log --pretty=oneline
[root@web2 project]# git log --oneline
[root@web2 project]# git reflog
备注：客户端也可以使用图形程序访问服务器。
Windows需要安装git和tortoiseGit。如图-3所示。

图-3
2 案例2： HEAD指针操作
2.1 问题

沿用练习一，学习操作HEAD指针，具体要求如下：
查看Git版本信息
移动指针
通过移动HEAD指针恢复数据
合并版本
2.2 方案

HEAD指针是一个可以在任何分支和版本移动的指针，通过移动指针我们可以将数据还原至任何版本。没做一次提交操作都会导致git更新一个版本，HEAD指针也跟着自动移动。
2.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：HEAD指针基本操作

1）准备工作（多对数据仓库进行修改、提交操作，以产生多个版本）。
[root@web2 project]# echo "new file" > new.txt
[root@web2 project]# git add .
[root@web2 project]# git commit -m "add new.txt"
[root@web2 project]# echo "first" >> new.txt
[root@web2 project]# git add .
[root@web2 project]# git commit -m "new.txt:first line"
[root@web2 project]# echo "second" >> new.txt
[root@web2 project]# git add .
[root@web2 project]# git commit -m "new.txt:second"
[root@web2 project]# echo "third" >> new.txt
[root@web2 project]# git add .
[root@web2 project]# git commit -m "new.txt:third"
[root@web2 project]# git push
[root@web2 project]# echo "123" > num.txt
[root@web2 project]# git add .
[root@web2 project]# git commit -m "num.txt:123"
[root@web2 project]# echo "456" > num.txt
[root@web2 project]# git add .
[root@web2 project]# git commit -m "num.txt:456"
[root@web2 project]# echo "789" > num.txt
[root@web2 project]# git add .
[root@web2 project]# git commit -m "num.txt:789"
[root@web2 project]# git push
2) 查看Git版本信息。
[root@web2 project]# git reflog
[root@web2 project]# git log --oneline
04ddc0f num.txt:789
7bba57b num.txt:456
301c090 num.txt:123
b427164 new.txt:third
0584949 new.txt:second
ece2dfd new.txt:first line
e1112ac add new.txt
1a0d908 初始化
3）移动HEAD指针，将数据还原到任意版本。
提示：当前HEAD指针为HEAD@{0}。
[root@web2 project]# git reset --hard 301c0
[root@web2 project]# git reflog
301c090 HEAD@{0}: reset: moving to 301c0
04ddc0f HEAD@{1}: commit: num.txt:789
7bba57b HEAD@{2}: commit: num.txt:456
301c090 HEAD@{3}: commit: num.txt:123
b427164 HEAD@{5}: commit: new.txt:third
0584949 HEAD@{6}: commit: new.txt:second
ece2dfd HEAD@{7}: commit: new.txt:first line
e1112ac HEAD@{8}: commit: add new.txt
1a0d908 HEAD@{9}: commit (initial): 初始化
[root@web2 project]# cat num.txt                #查看文件是否为123
123
[root@web2 project]# git reset --hard 7bba57b
[root@web2 project]# cat num.txt                #查看文件是否为123，456
123
456
[root@web2 project]# git reflog                #查看指针移动历史
7bba57b HEAD@{0}: reset: moving to 7bba57b
301c090 HEAD@{1}: reset: moving to 301c0
… …
[root@web2 project]# git reset --hard 04ddc0f    #恢复num.txt的所有数据
4)模拟误删后的数据还原操作。
[root@web2 project]# git rm init.txt                    #删除文件
rm 'init.txt'
[root@web2 project]# git commit -m "delete init.txt"    #提交本地仓库
[root@web2 project]# git reflog                        #查看版本历史
0dc2b76 HEAD@{0}: commit: delete init.txt
7bba57b HEAD@{0}: reset: moving to 7bba57b
301c090 HEAD@{1}: reset: moving to 301c0
… …
[root@web2 project]# git reset --hard 04ddc0f            #恢复数据
[root@web2 project]# ls
demo  init.txt  new.txt  num.txt
3 案例3：Git分支操作
3.1 问题

沿用练习二，学习操作Git分支，具体要求如下：
查看分支
创建分支
切换分支
合并分支
解决分支的冲突
3.2 方案

Git支持按功能模块、时间、版本等标准创建分支，分支可以让开发分多条主线同时进行，每条主线互不影响，分支效果如图-4所示。

图-4
常见的分支规范如下：
MASTER分支（MASTER是主分支，是代码的核心）。
DEVELOP分支（DEVELOP最新开发成果的分支）。
RELEASE分支（为发布新产品设置的分支）。
HOTFIX分支（为了修复软件BUG缺陷的分支）。
FEATURE分支（为开发新功能设置的分支）。
步骤一：查看并创建分支

1）查看当前分支。
[root@web2 project]# git status
# On branch master
nothing to commit, working directory clean
[root@web2 project]# git branch -v
* master 0dc2b76 delete init.txt
2）创建分支。
[root@web2 project]# git branch hotfix
[root@web2 project]# git branch feature
[root@web2 project]# git branch -v
  feature 0dc2b76 delete init.txt
  hotfix  0dc2b76 delete init.txt
* master  0dc2b76 delete init.txt
步骤二：切换与合并分支

1）切换分支。
[root@web2 project]# git checkout hotfix
[root@web2 project]# git branch -v
  feature 0dc2b76 delete init.txt
* hotfix  0dc2b76 delete init.txt
master  0dc2b76 delete init.txt
2）在新的分支上可以继续进行数据操作（增、删、改、查）。
[root@web2 project]# echo "fix a bug" >> new.txt
[root@web2 project]# git add .
[root@web2 project]# git commit -m "fix a bug"
3）将hotfix修改的数据合并到master分支。
注意，合并前必须要先切换到master分支，然后再执行merge命令。
[root@web2 project]# git checkout master
[root@web2 project]# cat new.txt        #默认master分支中没有hotfix分支中的数据
[root@web2 project]# git merge hotfix
Updating 0dc2b76..5b4a755
Fast-forward
 new.txt | 1 ++
 1 file changed, 1 insertions(+)
4）将所有本地修改提交远程服务器。
[root@web2 project]# git push
步骤二：解决版本分支的冲突问题

1）在不同分支中修改相同文件的相同行数据，模拟数据冲突。
[root@web2 project]# git checkout hotfix
[root@web2 project]# echo "AAA" > a.txt
[root@web2 project]# git add .
[root@web2 project]# git commit -m "add a.txt by hotfix"
[root@web2 project]# echo "BBB" > a.txt
[root@web2 project]# git add .
[root@web2 project]# git commit -m "add a.txt by master"
自动合并 a.txt
冲突（添加/添加）：合并冲突于 a.txt
自动合并失败，修正冲突然后提交修正的结果。
2）查看有冲突的文件内容，修改文件为最终版本的数据，解决冲突。
[root@web2 project]# cat a.txt                #该文件中包含有冲突的内容
<<<<<<< HEAD
BBB
=======
AAA
>>>>>>> hotfix
[root@web2 project]# vim a.txt              #修改该文件，为最终需要的数据，解决冲突
BBB
[root@web2 project]# git add .
[root@web2 project]# git commit -m "resolved"
总结：分支指针与HEAD指针的关系。
创建分支的本质是在当前提交上创建一个可以移动的指针
如何判断当前分支呢？答案是根据HEAD这个特殊指针
分支操作流程如图-5，图-6，图-7，图-8，图-9所示。

图-5 HEAD指针指向master分支

图-6 切换分支，HEAD指针指向testing分支

图-7 在testing分支中修改并提交代码

图-8 将分支切换回master分支

图-9 在master分支中修改数据，更新版本
4 案例4：Git服务器
4.1 问题

沿用练习三，学习Git不同的服务器形式，具体要求如下：
创建SSH协议服务器
创建Git协议服务器
创建HTTP协议服务器
4.2 方案

Git支持很多服务器协议形式，不同协议的Git服务器，客户端就可以使用不同的形式访问服务器。创建的服务器协议有SSH协议、Git协议、HTTP协议。
步骤一：SSH协议服务器（支持读写操作）

1）创建基于密码验证的SSH协议服务器（web1主机操作）。
[root@web1 ~]# git init --bare /var/git/base_ssh
Initialized empty Git repository in /var/git/base_ssh/
2)客户端访问的方式（web2主机操作）。
[root@web2 ~]# git clone root@192.168.2.100:/var/git/base_ssh
[root@web2 ~]# rm -rf base_ssh
3）客户端生成SSH密钥，实现免密码登陆git服务器（web2主机操作）。
[root@web2 ~]# ssh-keygen -f /root/.ssh/id_rsa -N ''
[root@web2 ~]# ssh-copy-id  192.168.2.100
[root@web2 ~]# git clone root@192.168.2.100:/var/git
[root@web2 ~]# git push
步骤二：Git协议服务器（只读操作的服务器）

1）安装git-daemon软件包（web1主机操作）。
[root@web1 ~]# yum -y install git-daemon
2）创建版本库（web1主机操作）。
[root@web1 ~]# git init --bare /var/git/base_git
Initialized empty Git repository in /var/git/base_git/
3）修改配置文件，启动git服务（web1主机操作）。
[root@web1 ~]# vim /usr/lib/systemd/system/git@.service
修改前内容如下：
ExecStart=-/usr/libexec/git-core/git-daemon --base-path=/var/lib/git 
--export-all --user-path=public_git --syslog --inetd –verbose
修改后内容如下：
ExecStart=-/usr/libexec/git-core/git-daemon --base-path=/var/git 
--export-all --user-path=public_git --syslog --inetd –verbose
[root@web1 ~]# systemctl  start  git.socket
4）客户端访问方式（web2主机操作）
[root@web2 ~]# git clone git://192.168.2.100/base_git
步骤三：HTTP协议服务器（只读操作的服务器）

1）安装gitweb、httpd软件包（web1主机操作）。
[root@web1 ~]# yum -y install httpd gitweb
2）修改配置文件，设置仓库根目录（web1主机操作）。
[root@web1 ~]# vim +11 /etc/gitweb.conf 
$projectroot = "/var/git";                        #添加一行
3) 创建版本仓库（web1主机操作）
[root@web1 ~]# git init --bare /var/git/base_http
4）启动httpd服务器
[root@web1 ~]# systemctl start httpd
5）客户端访问方式（web2主机操作）
注意：调用虚拟机中的firefox浏览器，需要在远程时使用ssh -X 服务器IP，并且确保真实主机的firefox已经关闭。
[root@web2 ~]# firefox http://192.168.2.100/git/
步骤四：课外扩展知识：注册使用Github

1.登陆网站https://github.com，点击Sign up（注册），如图-1所示。

图-1
2.填写注册信息（用户名，邮箱，密码），如图-2所示。

图-2
3. 初始化操作，如图-3和图-4所示。

图-3

图-4
注意，初始化完成后，到邮箱中去激活Github账户。
4. 创建仓库、使用仓库
点击Start a project（如图-5所示），

图-5
填写项目名称（项目名称任意），如图-6所示。

图-6
往仓库中上传文件或新建文件，如图-7所示

图-7
下载仓库中的代码，如图-8所示。

图-8
5. 命令行操作（需要联网的主机，如真实机）
[root@pc001 ~]# yum -y install git
[root@pc001 ~]# git clone https://github.com/账户名称/仓库名称
#clone指令用于将服务器仓库中的资料打包下载到本地
[root@pc001 ~]# cd 仓库名称
[root@pc001 ~]# 任意修改文件，或新建文件
[root@pc001 ~]# git add .
#add添加新文件
[root@pc001 ~]# git commit -m "test"
[root@pc001 ~]# git push
#commit和push实现提交代码的功能
[root@pc001 ~]# git pull
5 案例5：制作nginx的RPM包
5.1 问题

本案例使用nginx-1.12.2版本的源码软件，生成对应的RPM包软件，具体要求如下：
软件名称为nginx
软件版本为1.12.2
RPM软件包可以查询描述信息
RPM软件包可以安装及卸载
5.2 方案

安装rpm-build软件包，编写SPEC配置文件，创建新的RPM软件包。
配置文件中的描述信息如表-2：
表－2 SPEC描述信息

5.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：安装rpm-build软件

1）安装rpm-build软件包
[root@web1 ~]# yum -y install  rpm-build
2）生成rpmbuild目录结构
[root@web1 ~]# rpmbuild -ba nginx.spec                //会报错，没有文件或目录
[root@web1 ~]# ls /root/rpmbuild                    //自动生成的目录结构
BUILD  BUILDROOT  RPMS  SOURCES  SPECS  SRPMS
3）准备工作，将源码软件复制到SOURCES目录
[root@web1 ~]# cp nginx-1.12.2.tar.gz /root/rpmbuild/SOURCES/
4）创建并修改SPEC配置文件
[root@web1 ~]# vim /root/rpmbuild/SPECS/nginx.spec 
Name:nginx                                        #源码包软件名称
Version:1.12.2                                    #源码包软件的版本号
Release:    10                                        #制作的RPM包版本号
Summary: Nginx is a web server software.            #RPM软件的概述    
License:GPL                                        #软件的协议
URL:    www.test.com                                    #网址
Source0:nginx-1.12.2.tar.gz                        #源码包文件的全称
#BuildRequires:                                    #制作RPM时的依赖关系
#Requires:                                        #安装RPM时的依赖关系
%description
nginx [engine x] is an HTTP and reverse proxy server.    #软件的详细描述
%post
useradd nginx                               #非必需操作：安装后脚本(创建账户)
%prep
%setup -q                                #自动解压源码包，并cd进入目录
%build
./configure
make %{?_smp_mflags}
%install
make install DESTDIR=%{buildroot}
%files
%doc
/usr/local/nginx/*                    #对哪些文件与目录打包
%changelog
步骤二：使用配置文件创建RPM包

1）安装依赖软件包
[root@web1 ~]# yum -y install  gcc  pcre-devel openssl-devel
2）rpmbuild创建RPM软件包
[root@web1 ~]# rpmbuild -ba /root/rpmbuild/SPECS/nginx.spec
[root@web1 ~]# ls /root/rpmbuild/RPMS/x86_64/nginx-1.12.2-10.x86_64.rpm
[root@web1 ~]# rpm -qpi RPMS/x86_64/nginx-1.12.2-10.x86_64.rpm 
Name        : nginx        Relocations: (not relocatable)
Version     : 1.12.2        Vendor: (none)
Release     : 10            Build Date: Mon 02 May 2016 02:30:53 AM PDT
Install Date: (not installed)            Build Host: localhost
Group       : Applications/Internet        Source RPM: nginx-1.8.0-1.src.rpm
Size        : 721243                    License: GPL
Signature   : (none)
URL         : www.nginx.org
Summary     : Nginx is a web server software.
Description :
nginx [engine x] is an HTTP and reverse proxy server.
[root@web1 ~]# rpm -qpl nginx-1.12.2-10.x86_64.rpm 
/usr
/usr/local
/usr/local/nginx
/usr/local/nginx/conf
/usr/local/nginx/conf/fastcgi.conf
/usr/local/nginx/conf/fastcgi.conf.default
/usr/local/nginx/conf/fastcgi_params
/usr/local/nginx/conf/fastcgi_params.default
/usr/local/nginx/conf/koi-utf
/usr/local/nginx/conf/koi-win
/usr/local/nginx/conf/mime.types
/usr/local/nginx/conf/mime.types.default
/usr/local/nginx/conf/nginx.conf
/usr/local/nginx/conf/nginx.conf.default
/usr/local/nginx/conf/scgi_params
/usr/local/nginx/conf/scgi_params.default
/usr/local/nginx/conf/uwsgi_params
/usr/local/nginx/conf/uwsgi_params.default
/usr/local/nginx/conf/win-utf
/usr/local/nginx/html
/usr/local/nginx/html/50x.html
/usr/local/nginx/html/index.html
/usr/local/nginx/logs
/usr/local/nginx/sbin
/usr/local/nginx/sbin/nginx
步骤三：安装、卸载软件

[root@web1 ~]# rpm -ivh RPMS/x86_64/nginx-1.12.2-10.x86_64.rpm 
[root@web1 ~]# rpm -qa |grep nginx
[root@web1 ~]# /usr/local/nginx/sbin/nginx
[root@web1 ~]# curl http://127.0.0.1/













Top
NSD OPERATION DAY07

案例1：配置GRE VPN
案例2：创建PPTP VPN
案例3：创建L2TP+IPSec VPN
案例4：NTP时间同步
1 案例1：配置GRE VPN
1.1 问题

本案例要求搭建一个GRE VPN环境，并测试该VPN网络是否能够正常通讯，要求如下：
启用内核模块ip_gre
创建一个虚拟VPN隧道(10.10.10.0/24)
实现两台主机点到点的隧道通讯
1.2 方案

使用lsmod查看当前计算机已经加载的模块，使用modprobe加载Linux内核模块，使用modinfo可以查看内核模块的信息。
准备实验所需的虚拟机环境，实验环境所需要的主机及对应的IP设置列表如表-1所示，正确配置IP地址、主机名称，并且为每台主机配置YUM源。
表－1 主机列表

实验拓扑如图-1所示。

图-1
1.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：启用GRE模块（client和proxy都需要操作）

1）查看计算机当前加载的模块
[root@client ~]# lsmod                            //显示模块列表
[root@client ~]# lsmod  | grep ip_gre            //确定是否加载了gre模块
2)加载模块ip_gre
[root@client ~]# modprobe  ip_gre 
3）查看模块信息
[root@client ~]# modinfo ip_gre
filename:       /lib/modules/3.10.0-693.el7.x86_64/kernel/net/ipv4/ip_gre.ko.xz
alias:          netdev-gretap0
alias:          netdev-gre0
alias:          rtnl-link-gretap
alias:          rtnl-link-gre
license:        GPL
rhelversion:    7.4
srcversion:     F37A2BF90692F86E3A8BD15
depends:        ip_tunnel,gre
intree:         Y
vermagic:       3.10.0-693.el7.x86_64 SMP mod_unload modversions 
signer:         CentOS Linux kernel signing key
sig_key:        DA:18:7D:CA:7D:BE:53:AB:05:BD:13:BD:0C:4E:21:F4:22:B6:A4:9C
sig_hashalgo:   sha256
parm:           log_ecn_error:Log packets received with corrupted ECN (bool)
      
步骤二：Client主机创建VPN隧道

1）创建隧道
[root@client ~]# ip tunnel add tun0  mode gre \ 
>  remote 201.1.2.5 local 201.1.2.10
//ip tunnel add创建隧道（隧道名称为tun0），ip tunnel help可以查看帮助
//mode设置隧道使用gre模式
//local后面跟本机的IP地址，remote后面是与其他主机建立隧道的对方IP地址
2）启用该隧道（类似与设置网卡up）
[root@client ~]# ip link show
[root@client ~]# ip link set tun0 up         //设置UP
[root@client ~]# ip link show
2）为VPN配置隧道IP地址
[root@client ~]# ip addr add 10.10.10.10/24 peer 10.10.10.5/24 \
>  dev tun0
//为隧道tun0设置本地IP地址（10.10.10.10.10/24）
//隧道对面的主机IP的隧道IP为10.10.10.5/24
[root@client ~]# ip a s                      //查看IP地址
3）关闭防火墙
[root@client ~]# firewall-cmd --set-default-zone=trusted
步骤三：Proxy主机创建VPN隧道

1）查看计算机当前加载的模块
[root@client ~]# lsmod                            //显示模块列表
[root@client ~]# lsmod  | grep ip_gre            //确定是否加载了gre模块
2)加载模块ip_gre
[root@client ~]# modprobe  ip_gre
3）创建隧道
[root@proxy ~]# ~]# ip tunnel add tun0  mode gre \ 
>  remote 201.1.2.10 local 201.1.2.5
//ip tunnel add创建隧道（隧道名称为tun0），ip tunnel help可以查看帮助
//mode设置隧道使用gre模式
//local后面跟本机的IP地址，remote后面是与其他主机建立隧道的对方IP地址
4）启用该隧道（类似与设置网卡up）
[root@proxy ~]# ip link show
[root@proxy ~]# ip link set tun0 up         //设置UP
[root@proxy ~]# ip link show
5）为VPN配置隧道IP地址
[root@proxy ~]# ip addr add 10.10.10.5/24 peer 10.10.10.10/24 \
>  dev tun0
//为隧道tun0设置本地IP地址（10.10.10.10.5/24）
//隧道对面的主机IP的隧道IP为10.10.10.10/24
[root@proxy ~]# ip a s                      //查看IP地址
6）开启路由转发、关闭防火墙
[root@proxy ~]# echo "1" > /proc/sys/net/ipv4/ip_forward
[root@proxy ~]# firewall-cmd --set-default-zone=trusted
7)测试连通性
[root@client ~]#  ping 10.10.10.5
[root@proxy ~]#   ping 10.10.10.10
2 案例2：创建PPTP VPN
2.1 问题

本案例要求搭建一个PPTP VPN环境，并测试该VPN网络是否能够正常通讯，要求如下:
使用PPTP协议创建一个支持身份验证的隧道连接
使用MPPE对数据进行加密
为客户端分配192.168.3.0/24的地址池
客户端连接的用户名为jacob，密码为123456
2.2 方案

准备实验所需的虚拟机环境，实验环境所需要的主机及对应的IP设置列表如表-2所示，正确配置IP地址、主机名称，并且为每台主机配置YUM源。
表－2 主机列表

实验拓扑如图-2所示。

图-2
2.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：部署VPN服务器

1）安装软件包（软件包参考lnmp_soft）
[root@proxy ~]# yum localinstall pptpd-1.4.0-2.el7.x86_64.rpm
[root@proxy ~]# rpm -qc pptpd
/etc/ppp/options.pptpd
/etc/pptpd.conf
/etc/sysconfig/pptpd
2)修改配置文件
[root@proxy ~]# vim /etc/pptpd.conf
.. ..
localip 201.1.2.5                                    //服务器本地IP
remoteip 192.168.3.1-50                            //分配给客户端的IP池
[root@proxy ~]# vim /etc/ppp/options.pptpd
require-mppe-128                                    //使用MPPE加密数据
ms-dns 8.8.8.8                                    //DNS服务器
[root@proxy ~]# vim /etc/ppp/chap-secrets            //修改账户配置文件
jacob           *               123456      *
//用户名    服务器标记    密码    客户端
[root@proxy ~]# echo "1" > /proc/sys/net/ipv4/ip_forward    //开启路由转发
3）启动服务
[root@proxy ~]# systemctl start pptpd
[root@proxy ~]# systemctl enable pptpd
[root@proxy ~]# firewall-cmd --set-default-zone=trusted
4）翻墙设置（非必需操作）
[root@proxy ~]# iptables -t nat -A POSTROUTING -s 192.168.3.0/24 \
>  -j SNAT --to-source 201.1.2.5
步骤二：客户端设置

启动一台Windows虚拟机，将虚拟机网卡桥接到public2，配置IP地址为201.1.2.20。
新建网络连接（具体操作如图-3所示），输入VPN服务器账户与密码（具体操作如图-4所示），连接VPN并测试网络连通性（如图-5所示）。

图-3

图-4

图-5
3 案例3：创建L2TP+IPSec VPN
3.1 问题

本案例要求搭建一个L2TP+IPSec VPN环境，并测试该VPN网络是否能够正常通讯，具体要求如下：
使用L2TP协议创建一个支持身份验证与加密的隧道连接
使用IPSec对数据进行加密
为客户端分配192.168.3.0/24的地址池
客户端连接的用户名为：jacob，密码为：123456
预共享密钥为：randpass
3.2 方案

准备实验所需的虚拟机环境，实验环境所需要的主机及对应的IP设置列表如表-3所示，正确配置IP地址、主机名称，并且为每台主机配置YUM源。
表－3 主机列表

实验拓扑如图-6所示。

图-6
3.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：部署IPSec服务

1）安装软件包
[root@client ~]# yum -y install libreswan
2)新建IPSec密钥验证配置文件
[root@client ~]# cat /etc/ipsec.conf                //仅查看一下该主配置文件
.. ..
include /etc/ipsec.d/*.conf                    //加载该目录下的所有配置文件
[root@client ~]# vim /etc/ipsec.d/myipsec.conf            
//新建该文件，参考lnmp_soft/vpn/myipsec.conf    
conn IDC-PSK-NAT
    rightsubnet=vhost:%priv                        //允许建立的VPN虚拟网络
    also=IDC-PSK-noNAT
conn IDC-PSK-noNAT
    authby=secret                                    //加密认证
        ike=3des-sha1;modp1024                        //算法
        phase2alg=aes256-sha1;modp2048                //算法
    pfs=no
    auto=add
    keyingtries=3
    rekey=no
    ikelifetime=8h
    keylife=3h
    type=transport
    left=201.1.2.10                                //重要，服务器本机的外网IP
    leftprotoport=17/1701
    right=%any                                    //允许任何客户端连接
    rightprotoport=17/%any
3)创建IPSec预定义共享密钥
[root@client ~]# cat /etc/ipsec.secrets                 //仅查看，不要修改该文件
include /etc/ipsec.d/*.secrets
[root@client ~]# vim /etc/ipsec.d/mypass.secrets        //新建该文件
201.1.2.10   %any:    PSK    "randpass"             //randpass为预共享密钥
                                                //201.1.2.10是VPN服务器的IP
4)启动IPSec服务
[root@client ~]# systemctl start ipsec        
[root@client ~]# netstat -ntulp |grep pluto
udp        0      0 127.0.0.1:4500          0.0.0.0:*           3148/pluto          
udp        0      0 192.168.4.10:4500      0.0.0.0:*           3148/pluto          
udp        0      0 201.1.2.10:4500         0.0.0.0:*           3148/pluto          
udp        0      0 127.0.0.1:500           0.0.0.0:*           3148/pluto          
udp        0      0 192.168.4.10:500       0.0.0.0:*           3148/pluto          
udp        0      0 201.1.2.10:500          0.0.0.0:*           3148/pluto          
udp6       0      0 ::1:500                 :::*                 3148/pluto
步骤二：部署XL2TP服务

1）安装软件包（软件包参考lnmp_soft）
[root@client ~]# yum localinstall xl2tpd-1.3.8-2.el7.x86_64.rpm
2) 修改xl2tp配置文件（修改3个配置文件的内容）
[root@client ~]#  vim  /etc/xl2tpd/xl2tpd.conf                //修改主配置文件
[global]
.. ..    
[lns default]
.. ..
ip range = 192.168.3.128-192.168.3.254                    //分配给客户端的IP池
local ip = 201.1.2.10                                    //VPN服务器的IP地址
[root@client ~]# vim /etc/ppp/options.xl2tpd            //认证配置
require-mschap-v2                                         //添加一行，强制要求认证
#crtscts                                                //注释或删除该行
#lock                                                //注释或删除该行
root@client ~]# vim /etc/ppp/chap-secrets                    //修改密码文件
jacob   *       123456  *                //账户名称   服务器标记   密码   客户端IP
3）启动服务
[root@client ~]# systemctl start xl2tpd
[root@client ~]# netstat  -ntulp |grep xl2tpd        
udp     0      0 0.0.0.0:1701      0.0.0.0:*          3580/xl2tpd
4）设置路由转发，防火墙
[root@client ~]# echo "1" > /proc/sys/net/ipv4/ip_forward
[root@client ~]# firewall-cmd --set-default-zone=trusted
5）翻墙设置（非必需操作）
[root@client ~]# iptables -t nat -A POSTROUTING -s 192.168.3.0/24 \
>  -j SNAT --to-source 201.1.2.10
步骤二：客户端设置

启动一台Windows虚拟机，将虚拟机网卡桥接到public2，配置IP地址为201.1.2.20。
1. 新建网络连接（参考案例2），输入VPN服务器账户与密码（参考案例2）。
设置VPN连接的属性，预共享密钥是IPSec配置文件中填写的randpass，具体操作如图-7所示。

图-7
2. 设置Windows注册表（不修改注册表，连接VPN默认会报789错误），具体操作如下：
单击"开始"，单击"运行"，键入"regedit"，然后单击"确定"
找到下面的注册表子项，然后单击它：
HKEY_LOCAL_MACHINE\ System\CurrentControlSet\Services\Rasman\Parameters
在"编辑"菜单上，单击"新建"->"DWORD值"
在"名称"框中，键入"ProhibitIpSec"
在"数值数据"框中，键入"1"，然后单击"确定"
退出注册表编辑器，然后重新启动计算机
连接VPN并测试网络连通性（参考案例2）。
4 案例4：NTP时间同步
4.1 问题

本案例要求搭建一个NTP服务器，为整个网络环境中的所有主机提供时间校准服务，具体要求如下：
部署一台NTP时间服务器
设置时间服务器上层与0.centos.pool.ntp.org同步
设置本地服务器层级数量为10
允许192.168.4.0/24网络的主机同步时间
客户端验证时间是否同步
4.2 方案

准备实验所需的虚拟机环境，实验环境所需要的主机及对应的IP设置列表如表-4所示，正确配置IP地址、主机名称，并且为每台主机配置YUM源。
表－4 主机列表

实验拓扑如图-8所示。

图-8
Network Time Protocol（网络时间协议）采用的是分层设计，如图-9所示，Stratum层的总数限制在15以内（包括15）。

图-9
4.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：部署NTP服务

1）安装软件包
[root@proxy ~]# yum -y install chrony
[root@proxy ~]# rpm -qc chrony                        //查看配置文件列表
/etc/chrony.conf
/etc/chrony.keys
.. ..
2)修改配置文件
[root@proxy ~]# cat /etc/chrony.conf
.. ..
server 0.centos.pool.ntp.org iburst         //server用户客户端指向上层NTP服务器
allow 192.168.4.0/24                        //允许那个IP或网络访问NTP
#deny  192.168.4.1                        //拒绝那个IP或网络访问NTP
local stratum 10                            //设置NTP服务器的层数量  ＃设置自已所在的层数
.. ..
4)启动NTP服务
[root@proxy ~]# systemctl  restart  chronyd
[root@proxy ~]# systemctl  enable  chronyd
5)设置防火墙
[root@proxy ~]# firewall-cmd --set-default-zone=trusted
步骤二：配置客户端

1）安装软件包
[root@client ~]# yum -y install chrony
2) 修改配置文件
[root@client ~]# vim /etc/chrony.conf
server 192.168.4.5 iburst                //设置与哪台服务器同步数据
                                        //iburst参数设置重启服务后尽快同步时间
3) 将客户端时间修改为错误的时间
[root@client ~]#  date  -s  "hour:minute"         //调整时间（小时：分钟）
[root@client ~]#  date                            //查看修改后的时间
4) 重启chrony与服务器同步时间
[root@client ~]# systemctl  restart  chronyd
5) 确认时间是否已经同步
[root@client ~]# date                            //多执行几次查看结果














roundrobin「rr」轮询      不支持权重
source hash「sh」
least connext「ls」

性能：nginx<lvs
功能：nginx>lvs   （例如不带健康检查）
（越底层的往往性能越好，功能越少）


Top
NSD CLUSTER DAY01

案例1：ipvsadm命令用法
案例2：部署LVS-NAT集群
案例3：部署LVS-DR集群
1 案例1：ipvsadm命令用法
1.1 问题

准备一台Linux服务器，安装ipvsadm软件包，练习使用ipvsadm命令，实现如下功能：
使用命令添加基于TCP一些的集群服务
在集群中添加若干台后端真实服务器
实现同一客户端访问，调度器分配固定服务器
会使用ipvsadm实现规则的增、删、改
保存ipvsadm规则
1.2 方案

安装ipvsadm软件包，关于ipvsadm的用法可以参考man ipvsadm资料。
常用ipvsadm命令语法格式如表-1及表-2所示。
表－1 ipvsadm命令选项

表－2 ipvsadm语法案例

1.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：使用命令增、删、改LVS集群规则

1）创建LVS虚拟集群服务器（算法为加权轮询：wrr）
[root@proxy ~]# yum -y install ipvsadm
[root@proxy ~]# ipvsadm -A -t 192.168.4.5:80 -s wrr
[root@proxy ~]# ipvsadm -Ln
IP Virtual Server version 1.2.1 (size=4096)
Prot LocalAddress:Port Scheduler Flags
  -> RemoteAddress:Port           Forward Weight ActiveConn InActConn
TCP  192.168.4.5:80 wrr
2）为集群添加若干real server
[root@proxy ~]# ipvsadm -a -t 192.168.4.5:80 -r 192.168.2.100 -m -w 1
[root@proxy ~]# ipvsadm -Ln
IP Virtual Server version 1.2.1 (size=4096)
Prot LocalAddress:Port Scheduler Flags
  -> RemoteAddress:Port           Forward Weight ActiveConn InActConn
TCP  192.168.4.5:80 wrr
  -> 192.168.2.100:80             Masq    1      0          0
[root@proxy ~]# ipvsadm -a -t 192.168.4.5:80 -r 192.168.2.200 -m -w 2
[root@proxy ~]# ipvsadm –a -t 192.168.4.5:80 -r 192.168.2.201 -m -w 3
[root@proxy ~]# ipvsadm –a -t 192.168.4.5:80 -r 192.168.2.202 -m -w 4
3）修改集群服务器设置(修改调度器算法，将加权轮询修改为轮询)
[root@proxy ~]# ipvsadm -E -t 192.168.4.5:80 -s rr
[root@proxy ~]# ipvsadm -Ln
IP Virtual Server version 1.2.1 (size=4096)
Prot LocalAddress:Port Scheduler Flags
  -> RemoteAddress:Port           Forward Weight ActiveConn InActConn
TCP  192.168.4.5:80 rr
  -> 192.168.2.100:80             Masq    1      0          0         
  -> 192.168.2.200:80             Masq    2      0          0         
  -> 192.168.2.201:80             Masq    2      0          0         
  -> 192.168.2.202:80             Masq    1      0          0
4）修改read server（使用-g选项，将模式改为DR模式）
[root@proxy ~]# ipvsadm -e -t 192.168.4.5:80 -r 192.168.2.202 -g
5）查看LVS状态
[root@proxy ~]# ipvsadm -Ln
6）创建另一个集群（算法为最少连接算法；使用-m选项，设置工作模式为NAT模式）
[root@proxy ~]# ipvsadm -A -t 192.168.4.5:3306 -s lc
[root@proxy ~]# ipvsadm -a -t 192.168.4.5:3306 -r 192.168.2.100 -m
[root@proxy ~]# ipvsadm -a -t 192.168.4.5:3306 -r 192.168.2.200 -m
6）永久保存所有规则
[root@proxy ~]# ipvsadm-save -n > /etc/sysconfig/ipvsadm
7）清空所有规则
[root@proxy ~]# ipvsadm -C
2 案例2：部署LVS-NAT集群
2.1 问题

使用LVS实现NAT模式的集群调度服务器，为用户提供Web服务：
集群对外公网IP地址为192.168.4.5
调度器内网IP地址为192.168.2.5
真实Web服务器地址分别为192.168.2.100、192.168.2.200
使用加权轮询调度算法，真实服务器权重分别为1和2
2.2 方案

实验拓扑结构主机配置细节如表-3所示。
表-3

使用4台虚拟机，1台作为Director调度器、2台作为Real Server、1台客户端，拓扑结构如图-1所示，注意：web1和web2必须配置网关地址。

图-1
2.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：配置基础环境

1）设置Web服务器（以web1为例）
[root@web1 ~]# yum -y install httpd
[root@web1 ~]# echo "192.168.2.100" > /var/www/html/index.html
2）启动Web服务器软件
[root@web1 ~]# systemctl restart httpd
3)关闭防火墙与SELinux
[root@web1 ~]# systmctl stop firewalld
[root@web1 ~]# setenforce 0
步骤三：部署LVS-NAT模式调度器

1)确认调度器的路由转发功能(如果已经开启，可以忽略)
[root@proxy ~]# echo 1 > /proc/sys/net/ipv4/ip_forward
[root@proxy ~]# cat /proc/sys/net/ipv4/ip_forward
1
[root@proxy ~]# echo "net.ipv4.ip_forward = 1" >> /etc/sysctl.conf
#修改配置文件，设置永久规则
2）创建集群服务器
[root@proxy ~]# yum -y install ipvsadm
[root@proxy ~]# ipvsadm -A -t 192.168.4.5:80 -s wrr
2）添加真实服务器
[root@proxy ~]# ipvsadm -a -t 192.168.4.5:80 -r 192.168.2.100 -w 1 -m
[root@proxy ~]# ipvsadm -a -t 192.168.4.5:80 -r 192.168.2.200 -w 1 -m
3）查看规则列表，并保存规则
[root@proxy ~]# ipvsadm -Ln
[root@proxy ~]# ipvsadm-save -n > /etc/sysconfig/ipvsadm
步骤四：客户端测试

客户端使用curl命令反复连接http://192.168.4.5，查看访问的页面是否会轮询到不同的后端真实服务器。
3 案例3：部署LVS-DR集群
3.1 问题

使用LVS实现DR模式的集群调度服务器，为用户提供Web服务：
客户端IP地址为192.168.4.10
LVS调度器VIP地址为192.168.4.15
LVS调度器DIP地址设置为192.168.4.5
真实Web服务器地址分别为192.168.4.100、192.168.4.200
使用加权轮询调度算法，web1的权重为1，web2的权重为2
说明：
CIP是客户端的IP地址；
VIP是对客户端提供服务的IP地址；
RIP是后端服务器的真实IP地址；
DIP是调度器与后端服务器通信的IP地址（VIP必须配置在虚拟接口）。
3.2 方案

使用4台虚拟机，1台作为客户端、1台作为Director调度器、2台作为Real Server，拓扑结构如图-2所示。实验拓扑结构主机配置细节如表-4所示。

图-2
表-4

3.3 步骤

实现此案例需要按照如下步骤进行。
说明：
CIP是客户端的IP地址；
VIP是对客户端提供服务的IP地址；
RIP是后端服务器的真实IP地址；
DIP是调度器与后端服务器通信的IP地址（VIP必须配置在虚拟接口）。
步骤一：配置实验网络环境

1）设置Proxy代理服务器的VIP和DIP

注意：为了防止冲突，VIP必须要配置在网卡的虚拟接口！！！

 [root@proxy ~]# cd /etc/sysconfig/network-scripts/
[root@proxy ~]# cp ifcfg-eth0{,:0}
[root@proxy ~]# vim ifcfg-eth0
TYPE=Ethernet                      ＃以太网
BOOTPROTO=none                     ＃手动配ip，＝dhcp时为自动配ip
NAME=eth0                          ＃网卡名
DEVICE=eth0
ONBOOT=yes                         ＃开机自启网卡  
IPADDR=192.168.4.5                 ＃ip地址     
PREFIX=24                          ＃子网掩码  
[root@proxy ~]# vim ifcfg-eth0:0
TYPE=Ethernet
BOOTPROTO=none
DEFROUTE=yes
NAME=eth0:0
DEVICE=eth0:0
ONBOOT=yes
IPADDR=192.168.4.15
PREFIX=24
[root@proxy ~]# systemctl restart network
2）设置Web1服务器网络参数
[root@web1 ~]# nmcli connection modify eth0 ipv4.method manual \
ipv4.addresses 192.168.4.100/24 connection.autoconnect yes
[root@web1 ~]# nmcli connection up eth0
接下来给web1配置VIP地址。
注意：这里的子网掩码必须是32（也就是全255），网络地址与IP地址一样，广播地址与IP地址也一样。
[root@web1 ~]# cd /etc/sysconfig/network-scripts/
[root@web1 ~]# cp ifcfg-lo{,:0}
[root@web1 ~]# vim ifcfg-lo:0
DEVICE=lo:0
IPADDR=192.168.4.15
NETMASK=255.255.255.255
NETWORK=192.168.4.15
BROADCAST=192.168.4.15
ONBOOT=yes
NAME=lo:0
防止地址冲突的问题：
这里因为web1也配置与代理一样的VIP地址，默认肯定会出现地址冲突；
sysctl.conf文件写入这下面四行的主要目的就是访问192.168.4.15的数据包，只有调度器会响应，其他主机都不做任何响应，这样防止地址冲突的问题。


[root@web1 ~]# sysctl -p
重启网络服务，设置防火墙与SELinux
[root@web1 ~]# systemctl restart network
[root@web1 ~]# ifconfig
[root@web1 ~]# systemctl stop firewalld
[root@web1 ~]# setenforce 0
3）设置Web2服务器网络参数
[root@web2 ~]# nmcli connection modify eth0 ipv4.method manual \
ipv4.addresses 192.168.4.200/24 connection.autoconnect yes
[root@web2 ~]# nmcli connection up eth0
接下来给web2配置VIP地址
注意：这里的子网掩码必须是32（也就是全255），网络地址与IP地址一样，广播地址与IP地址也一样。
[root@web2 ~]# cd /etc/sysconfig/network-scripts/
[root@web2 ~]# cp ifcfg-lo{,:0}
[root@web2 ~]# vim ifcfg-lo:0
DEVICE=lo:0
IPADDR=192.168.4.15
NETMASK=255.255.255.255
NETWORK=192.168.4.15
BROADCAST=192.168.4.15
ONBOOT=yes
NAME=lo:0
防止地址冲突的问题：
这里因为web1也配置与代理一样的VIP地址，默认肯定会出现地址冲突；
sysctl.conf文件写入这下面四行的主要目的就是访问192.168.4.15的数据包，只有调度器会响应，其他主机都不做任何响应，这样防止地址冲突的问题。
[root@web2 ~]# vim /etc/sysctl.conf
#手动写入如下4行内容
net.ipv4.conf.all.arp_ignore = 1
net.ipv4.conf.lo.arp_ignore = 1
net.ipv4.conf.lo.arp_announce = 2
net.ipv4.conf.all.arp_announce = 2
#当有arp广播问谁是192.168.4.15时，本机忽略该ARP广播，不做任何回应
#本机不要向外宣告自己的lo回环地址是192.168.4.15
[root@web2 ~]# sysctl -p
重启网络服务，设置防火墙与SELinux
[root@web2 ~]# systemctl restart network
[root@web2 ~]# ifconfig
[root@web2 ~]# systemctl stop firewalld
[root@web2 ~]# setenforce 0
步骤二：配置后端Web服务器

1）自定义Web页面
[root@web1 ~]# yum -y install httpd
[root@web1 ~]# echo "192.168.4.100" > /var/www/html/index.html
[root@web2 ~]# yum -y install httpd
[root@web2 ~]# echo "192.168.4.200" > /var/www/html/index.html
2）启动Web服务器软件
[root@web1 ~]# systemctl restart httpd
[root@web2 ~]# systemctl restart httpd
步骤三：proxy调度器安装软件并部署LVS-DR模式调度器

1）安装软件（如果已经安装，此步骤可以忽略）
[root@proxy ~]# yum -y install ipvsadm
2）清理之前实验的规则，创建新的集群服务器规则
[root@proxy ~]# ipvsadm -C                                #清空所有规则
[root@proxy ~]# ipvsadm -A -t 192.168.4.15:80 -s wrr
3）添加真实服务器(-g参数设置LVS工作模式为DR模式，-w设置权重)
[root@proxy ~]# ipvsadm -a -t 192.168.4.15:80 -r 192.168.4.100 -g -w 1
[root@proxy ~]# ipvsadm -a -t 192.168.4.15:80 -r 192.168.4.200 -g -w 1
4）查看规则列表，并保存规则
[root@proxy ~]# ipvsadm -Ln
TCP  192.168.4.15:80 wrr
  -> 192.168.4.100:80             Route   1      0          0         
  -> 192.168.4.200:80             Route   2      0          0
[root@proxy ~]# ipvsadm-save -n > /etc/sysconfig/ipvsadm
步骤四：客户端测试

客户端使用curl命令反复连接http://192.168.4.15，查看访问的页面是否会轮询到不同的后端真实服务器。
扩展知识：默认LVS不带健康检查功能，需要自己手动编写动态检测脚本，实现该功能：(参考脚本如下，仅供参考)
[root@proxy ~]# vim check.sh
#!/bin/bash
VIP=192.168.4.15:80
RIP1=192.168.4.100
RIP2=192.168.4.200
while :
do
   for IP in $RIP1 $RIP2
   do
           curl -s http://$IP &>/dev/vnull
if [ $? -eq 0 ];then
            ipvsadm -Ln |grep -q $IP || ipvsadm -a -t $VIP -r $IP
        else
             ipvsadm -Ln |grep -q $IP && ipvsadm -d -t $VIP -r $IP
        fi
   done
sleep 1
done
  
















Top
NSD CLUSTER DAY02

案例1：Keepalived高可用服务器
案例2：Keepalived+LVS服务器
案例3：配置HAProxy负载平衡集群
1 案例1：Keepalived高可用服务器
1.1 问题

准备三台Linux服务器，两台做Web服务器，并部署Keepalived高可用软件，一台作为客户端主机，实现如下功能：
使用Keepalived实现web服务器的高可用
Web服务器IP地址分别为192.168.4.100和192.168.4.200
Web服务器的浮动VIP地址为192.168.4.80
客户端通过访问VIP地址访问Web页面
1.2 方案

使用3台虚拟机，2台作为Web服务器，并部署Keepalived、1台作为客户端，拓扑结构如图-1所示，主机配置如表-1所示。

图-1
表-1

1.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：配置网络环境（如果在前面课程已经完成该配置，可以忽略此步骤）

1）设置Web1服务器网络参数、配置Web服务
[root@web1 ~]# nmcli connection modify eth0 ipv4.method manual ipv4.addresses 192.168.4.100/24 connection.autoconnect yes
[root@web1 ~]# nmcli connection up eth0
[root@web1 ~]# yum -y install httpd
[root@web1 ~]# echo "192.168.4.100" > /var/www/html/index.html
[root@web1 ~]# systemctl restart httpd
2）设置Web2服务器网络参数、配置Web服务
[root@web2 ~]# nmcli connection modify eth0 ipv4.method manual ipv4.addresses 192.168.4.200/24 connection.autoconnect yes
[root@web2 ~]# nmcli connection up eth0
[root@web2 ~]# yum -y install httpd
[root@web2 ~]# echo "192.168.4.200" > /var/www/html/index.html
[root@web2 ~]# systemctl restart httpd
3）配置proxy主机的网络参数（如果已经设置，可以忽略此步骤）
[root@proxy ~]# nmcli connection modify eth0 ipv4.method manual ipv4.addresses 192.168.4.5/24 connection.autoconnect yes
[root@proxy ~]# nmcli connection up eth0
步骤二：安装Keepalived软件

注意：两台Web服务器做相同的操作。
[root@web1 ~]# yum install -y keepalived
[root@web2 ~]# yum install -y keepalived 
步骤三：部署Keepalived服务

1）修改web1服务器Keepalived配置文件
[root@web1 ~]# vim /etc/keepalived/keepalived.conf
global_defs {
  notification_email {
    admin@tarena.com.cn                //设置报警收件人邮箱
  }
  notification_email_from ka@localhost    //设置发件人
  smtp_server 127.0.0.1                //定义邮件服务器
  smtp_connect_timeout 30
  router_id  web1                        //设置路由ID号（实验需要修改）
}
vrrp_instance VI_1 {
  state MASTER                         //主服务器为MASTER（备服务器需要修改为BACKUP）
  interface eth0                    //定义网络接口
  virtual_router_id 51                //主备服务器VRID号必须一致
  priority 100                     //服务器优先级,优先级高优先获取VIP（实验需要修改）
  advert_int 1
  authentication {
    auth_type pass
    auth_pass 1111                       //主备服务器密码必须一致
  }
  virtual_ipaddress {                   //谁是主服务器谁获得该VIP（实验需要修改）
192.168.4.80 
}    
}
2）修改web2服务器Keepalived配置文件
[root@web2 ~]# vim /etc/keepalived/keepalived.conf
global_defs {
  notification_email {
    admin@tarena.com.cn                //设置报警收件人邮箱
  }
  notification_email_from ka@localhost    //设置发件人
  smtp_server 127.0.0.1                //定义邮件服务器
  smtp_connect_timeout 30
  router_id  web2                        //设置路由ID号（实验需要修改）
}
vrrp_instance VI_1 {
  state BACKUP                             //备服务器为BACKUP（实验需要修改）
  interface eth0                        //定义网络接口
  virtual_router_id 51                    //主辅VRID号必须一致
  priority 50                             //服务器优先级（实验需要修改）
  advert_int 1
  authentication {
     auth_type pass
     auth_pass 1111                       //主辅服务器密码必须一致
  }
  virtual_ipaddress {                 //谁是主服务器谁配置VIP（实验需要修改）
192.168.4.80 
 }   
}
3）启动服务
[root@web1 ~]# systemctl start keepalived
[root@web2 ~]# systemctl start keepalived
4）配置防火墙和SELinux
启动keepalived会自动添加一个drop的防火墙规则，需要清空！
[root@web1 ~]# iptables -F
[root@web1 ~]# setenforce 0
[root@web2 ~]# iptables -F
[root@web1 ~]# setenforce 0
步骤四：测试

1）登录两台Web服务器查看VIP信息
[root@web1 ~]# ip addr show
[root@web2 ~]# ip addr show
2) 客户端访问
客户端使用curl命令连接http://192.168.4.80，查看Web页面；关闭Web1服务器的网卡，客户端再次访问http://192.168.4.80，验证是否可以正常访问服务。
2 案例2：Keepalived+LVS服务器
2.1 问题

使用Keepalived为LVS调度器提供高可用功能，防止调度器单点故障，为用户提供Web服务：
LVS1调度器真实IP地址为192.168.4.5
LVS2调度器真实IP地址为192.168.4.6
服务器VIP地址设置为192.168.4.15
真实Web服务器地址分别为192.168.4.100、192.168.4.200
使用加权轮询调度算法，真实web服务器权重不同
2.2 方案

使用5台虚拟机，1台作为客户端主机、2台作为LVS调度器、2台作为Real Server，实验拓扑环境结构如图-2所示，基础环境配置如表-2所示。

图-3
表-2

注意：所有主机都需要配置IP地址与有效的YUM源。
2.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：配置网络环境

1）设置Web1服务器的网络参数
[root@web1 ~]# nmcli connection modify eth0 ipv4.method manual \
ipv4.addresses 192.168.4.100/24 connection.autoconnect yes
[root@web1 ~]# nmcli connection up eth0
接下来给web1配置VIP地址
注意：这里的子网掩码必须是32（也就是全255），网络地址与IP地址一样，广播地址与IP地址也一样。
[root@web1 ~]# cd /etc/sysconfig/network-scripts/
[root@web1 ~]# cp ifcfg-lo{,:0}
[root@web1 ~]# vim ifcfg-lo:0
DEVICE=lo:0
IPADDR=192.168.4.15
NETMASK=255.255.255.255
NETWORK=192.168.4.15
BROADCAST=192.168.4.15
ONBOOT=yes
NAME=lo:0
注意：这里因为web1也配置与调度器一样的VIP地址，默认肯定会出现地址冲突。
写入这四行的主要目的就是访问192.168.4.15的数据包，只有调度器会响应，其他主机都不做任何响应。
[root@web1 ~]# vim /etc/sysctl.conf
#手动写入如下4行内容
net.ipv4.conf.all.arp_ignore = 1
net.ipv4.conf.lo.arp_ignore = 1
net.ipv4.conf.lo.arp_announce = 2
net.ipv4.conf.all.arp_announce = 2
#当有arp广播问谁是192.168.4.15时，本机忽略该ARP广播，不做任何回应
#本机不要向外宣告自己的lo回环地址是192.168.4.15
重启网络服务，设置防火墙与SELinux
[root@web1 ~]# systemctl restart network
[root@web1 ~]# ifconfig
[root@web1 ~]# systemctl stop firewalld
[root@web1 ~]# setenforce 0
2）设置Web2服务器的网络参数
[root@web2 ~]# nmcli connection modify eth0 ipv4.method manual \
ipv4.addresses 192.168.4.200/24 connection.autoconnect yes
[root@web2 ~]# nmcli connection up eth0
接下来给web2配置VIP地址
注意：这里的子网掩码必须是32（也就是全255），网络地址与IP地址一样，广播地址与IP地址也一样。
[root@web2 ~]# cd /etc/sysconfig/network-scripts/
[root@web2 ~]# cp ifcfg-lo{,:0}
[root@web2 ~]# vim ifcfg-lo:0
DEVICE=lo:0
IPADDR=192.168.4.15
NETMASK=255.255.255.255
NETWORK=192.168.4.15
BROADCAST=192.168.4.15
ONBOOT=yes
NAME=lo:0
注意：这里因为web2也配置与代理一样的VIP地址，默认肯定会出现地址冲突。
写入这四行的主要目的就是访问192.168.4.15的数据包，只有调度器会响应，其他主机都不做任何响应。
[root@web2 ~]# vim /etc/sysctl.conf
#手动写入如下4行内容
net.ipv4.conf.all.arp_ignore = 1
net.ipv4.conf.lo.arp_ignore = 1
net.ipv4.conf.lo.arp_announce = 2
net.ipv4.conf.all.arp_announce = 2
#当有arp广播问谁是192.168.4.15时，本机忽略该ARP广播，不做任何回应
#本机不要向外宣告自己的lo回环地址是192.168.4.15
重启网络服务，设置防火墙与SELinux
[root@web2 ~]# systemctl restart network
[root@web2 ~]# ifconfig
[root@web2 ~]# systemctl stop firewalld
[root@web2 ~]# setenforce 0
3）配置proxy1主机的网络参数(不配置VIP，由keepalvied自动配置)
[root@proxy1 ~]# nmcli connection modify eth0 ipv4.method manual \
ipv4.addresses 192.168.4.5/24 connection.autoconnect yes
[root@proxy1 ~]# nmcli connection up eth0
4）配置proxy2主机的网络参数(不配置VIP，由keepalvied自动配置)
注意：按照前面的课程环境，默认没有该虚拟机，需要重新建一台虚拟机proxy2。
[root@proxy2 ~]# nmcli connection modify eth0 ipv4.method manual \
ipv4.addresses 192.168.4.6/24 connection.autoconnect yes
[root@proxy2 ~]# nmcli connection up eth0
步骤二：配置后台web服务

1）安装软件，自定义Web页面（web1和web2主机）
[root@web1 ~]# yum -y install httpd
[root@web1 ~]# echo "192.168.4.100" > /var/www/html/index.html
[root@web2 ~]# yum -y install httpd
[root@web2 ~]# echo "192.168.4.200" > /var/www/html/index.html
3）启动Web服务器软件(web1和web2主机)
[root@web1 ~]# systemctl start httpd ; systemctl enable httpd
[root@web2 ~]# systemctl start httpd ; systemctl enable httpd
步骤三：调度器安装Keepalived与ipvsadm软件

注意：两台LVS调度器执行相同的操作（如何已经安装软件，可用忽略此步骤）。
安装软件
[root@proxy1 ~]# yum install -y keepalived
[root@proxy1 ~]# systemctl enable keepalived
[root@proxy1 ~]# yum install -y ipvsadm
[root@proxy1 ~]# ipvsadm -C
[root@proxy2 ~]# yum install -y keepalived
[root@proxy2 ~]# systemctl enable keepalived
[root@proxy2 ~]# yum install -y ipvsadm
[root@proxy2 ~]# ipvsadm -C
步骤四：部署Keepalived实现LVS-DR模式调度器的高可用

1）LVS1调度器设置Keepalived，并启动服务
[root@proxy1 ~]# vim /etc/keepalived/keepalived.conf
global_defs {
  notification_email {
    admin@tarena.com.cn                //设置报警收件人邮箱
  }
  notification_email_from ka@localhost    //设置发件人
  smtp_server 127.0.0.1                //定义邮件服务器
  smtp_connect_timeout 30
  router_id  lvs1                        //设置路由ID号(实验需要修改)
}
vrrp_instance VI_1 {
  state MASTER                             //主服务器为MASTER
  interface eth0                        //定义网络接口
  virtual_router_id 50                    //主辅VRID号必须一致
  priority 100                         //服务器优先级
  advert_int 1
  authentication {
    auth_type pass
    auth_pass 1111                       //主辅服务器密码必须一致
  }
  virtual_ipaddress {                   //配置VIP（实验需要修改）
192.168.4.15 
 }   
}
virtual_server 192.168.4.15 80 {           //设置ipvsadm的VIP规则（实验需要修改）
  delay_loop 6
  lb_algo wrr                          //设置LVS调度算法为WRR
  lb_kind DR                               //设置LVS的模式为DR
  #persistence_timeout 50
#注意这样的作用是保持连接，开启后，客户端在一定时间内始终访问相同服务器
  protocol TCP
  real_server 192.168.4.100 80 {         //设置后端web服务器真实IP（实验需要修改）
    weight 1                             //设置权重为1
    TCP_CHECK {                            //对后台real_server做健康检查
    connect_timeout 3
    nb_get_retry 3
    delay_before_retry 3
    }
  }
 real_server 192.168.4.200 80 {       //设置后端web服务器真实IP（实验需要修改）
    weight 2                          //设置权重为2
    TCP_CHECK {
    connect_timeout 3
    nb_get_retry 3
    delay_before_retry 3
    }
  }
}
[root@proxy1 ~]# systemctl start keepalived
[root@proxy1 ~]# ipvsadm -Ln                     #查看LVS规则
[root@proxy1 ~]# ip a  s                          #查看VIP配置
2）LVS2调度器设置Keepalived
[root@proxy2 ~]# vim /etc/keepalived/keepalived.conf
global_defs {
  notification_email {
    admin@tarena.com.cn                //设置报警收件人邮箱
  }
  notification_email_from ka@localhost    //设置发件人
  smtp_server 127.0.0.1                //定义邮件服务器
  smtp_connect_timeout 30
  router_id  lvs2                        //设置路由ID号（实验需要修改）
}
vrrp_instance VI_1 {
  state BACKUP                             //从服务器为BACKUP（实验需要修改）
  interface eth0                        //定义网络接口
  virtual_router_id 50                    //主辅VRID号必须一致
  priority 50                             //服务器优先级（实验需要修改）
  advert_int 1
  authentication {
    auth_type pass
    auth_pass 1111                       //主辅服务器密码必须一致
  }
  virtual_ipaddress {                   //设置VIP（实验需要修改）
192.168.4.15  
}  
}
virtual_server 192.168.4.15 80 {          //自动设置LVS规则（实验需要修改）
  delay_loop 6
  lb_algo wrr                          //设置LVS调度算法为WRR
  lb_kind DR                               //设置LVS的模式为DR
 # persistence_timeout 50
#注意这样的作用是保持连接，开启后，客户端在一定时间内始终访问相同服务器
  protocol TCP
  real_server 192.168.4.100 80 {        //设置后端web服务器的真实IP（实验需要修改）
    weight 1                              //设置权重为1
    TCP_CHECK {                         //对后台real_server做健康检查
    connect_timeout 3
    nb_get_retry 3
    delay_before_retry 3
    }
  }
 real_server 192.168.4.200 80 {         //设置后端web服务器的真实IP（实验需要修改）
    weight 2                              //设置权重为2
    TCP_CHECK {
    connect_timeout 3
    nb_get_retry 3
    delay_before_retry 3
    }
  }
[root@proxy2 ~]# systemctl start keepalived
[root@proxy2 ~]# ipvsadm -Ln                 #查看LVS规则
[root@proxy2 ~]# ip  a   s                    #查看VIP设置
步骤五：客户端测试

客户端使用curl命令反复连接http://192.168.4.15，查看访问的页面是否会轮询到不同的后端真实服务器。
3 案例3：配置HAProxy负载平衡集群
3.1 问题

准备4台Linux服务器，两台做Web服务器，1台安装HAProxy，1台做客户端，实现如下功能：
客户端访问HAProxy，HAProxy分发请求到后端Real Server
开启HAProxy监控页面，及时查看调度器状态
设置HAProxy为开机启动
3.2 方案

使用4台虚拟机，1台作为HAProxy调度器、2台作为Real Server、1台作为客户端，拓扑结构如图-3所示，具体配置如表-3所示。

图-3
表-3

3.3 步骤

实现此案例需要按照如下步骤进行。
注意事项：

将前面实验VIP、LVS等实验的内容清理干净！！！！！！

删除所有设备的VIP，清空所有LVS设置，关闭keepalived！！！

web1关闭多余的网卡与VIP，配置本地真实IP地址。
[root@web1 ~]# ifdown eth0
[root@web1 ~]# ifdown lo:0
[root@web1 ~]# nmcli connection modify eth1 ipv4.method manual \
ipv4.addresses 192.168.2.100/24 connection.autoconnect yes
[root@web1 ~]# nmcli connection up eth1
Web2关闭多余的网卡与VIP，配置本地真实IP地址。
[root@web2 ~]# ifdown eth0
[root@web2 ~]# ifdown lo:0
[root@web2 ~]# nmcli connection modify eth1 ipv4.method manual \
ipv4.addresses 192.168.2.200/24 connection.autoconnect yes
[root@web2 ~]# nmcli connection up eth1
proxy关闭keepalived服务，清理LVS规则。
[root@proxy ~]# systemctl stop keepalived
[root@proxy ~]# systemctl disable keepalived
[root@proxy ~]# ipvsadm -C
[root@proxy ~]# nmcli connection modify eth0 ipv4.method manual \
ipv4.addresses 192.168.4.5/24 connection.autoconnect yes
[root@proxy ~]# nmcli connection up eth0
[root@proxy ~]# nmcli connection modify eth1 ipv4.method manual \
ipv4.addresses 192.168.2.5/24 connection.autoconnect yes
[root@proxy ~]# nmcli connection up eth1
步骤一：配置后端Web服务器

设置两台后端Web服务（如果已经配置完成，可用忽略此步骤）
[root@web1 ~]# yum -y install httpd
[root@web1 ~]# systemctl start httpd
[root@web1 ~]# echo "192.168.2.100" > /var/www/html/index.html
[root@web2 ~]# yum -y install httpd
[root@web2 ~]# systemctl start httpd
[root@web2 ~]# echo "192.168.2.200" > /var/www/html/index.html
步骤二：部署HAProxy服务器

1）配置网络，安装软件
[root@haproxy ~]# yum -y install haproxy
2）修改配置文件
[root@haproxy ~]# vim /etc/haproxy/haproxy.cfg

global全局设置
。。。。。。
defaults默认设置
。。。。。
listen 集群设置
。。。。。。。



两种格式：
frontend main ＊：80
	use_badkend static
	default_backend








global
 log 127.0.0.1 local2   ###[err warning info debug]
 chroot /usr/local/haproxy
 pidfile /var/run/haproxy.pid ###haproxy的pid存放路径
 maxconn 4000     ###最大连接数，默认4000
 user haproxy
 group haproxy
 daemon       ###创建1个进程进入deamon模式运行
defaults
 mode http    ###默认的模式mode { tcp|http|health } log global   ###采用全局定义的日志
 option dontlognull  ###不记录健康检查的日志信息
 option httpclose  ###每次请求完毕后主动关闭http通道
 option httplog   ###日志类别http日志格式
 option forwardfor  ###后端服务器可以从Http Header中获得客户端ip
 option redispatch  ###serverid服务器挂掉后强制定向到其他健康服务器
 timeout connect 10000 #如果backend没有指定，默认为10s
 timeout client 300000 ###客户端连接超时
 timeout server 300000 ###服务器连接超时
 maxconn  60000  ###最大连接数
 retries  3   ###3次连接失败就认为服务不可用，也可以通过后面设置
listen stats 0.0.0.0:1080   #监听端口
    stats refresh 30s   #统计页面自动刷新时间
    stats uri /stats   #统计页面url
    stats realm Haproxy Manager #进入管理解面查看状态信息
    stats auth admin:admin  #统计页面用户名和密码设置
  #stats hide-version   #隐藏统计页面上HAProxy的版本信息
listen  websrv-rewrite 0.0.0.0:80
   balance roundrobin
   server  web1 192.168.2.100:80 check inter 2000 rise 2 fall 5
   server  web2 192.168.2.200:80 check inter 2000 rise 2 fall 5
3）启动服务器并设置开机启动
[root@haproxy ~]# systemctl start haproxy
[root@haproxy ~]# systemctl enable haproxy
步骤三：客户端验证

客户端配置与HAProxy相同网络的IP地址，并使用火狐浏览器访问http://192.168.4.5，测试调度器是否正常工作，客户端访问http://192.168.4.5:1080/stats测试状态监控页面是否正常。访问状态监控页的内容，参考图-4所示。

图-4
备注：
Queue队列数据的信息（当前队列数量，最大值，队列限制数量）；
Session rate每秒会话率（当前值，最大值，限制数量）；
Sessions总会话量（当前值，最大值，总量，Lbtot: total number of times a server was selected选中一台服务器所用的总时间）；
Bytes（入站、出站流量）；
Denied（拒绝请求、拒绝回应）；
Errors（错误请求、错误连接、错误回应）；
Warnings（重新尝试警告retry、重新连接redispatches）；
Server(状态、最后检查的时间（多久前执行的最后一次检查）、权重、备份服务器数量、down机服务器数量、down机时长)。

